<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringMVC系列(三)---参数解析流程</title>
    <url>/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>  本章详细的介绍了@RequestBody、@RequestParam、@PathVariable的参数解析原理。</p>
</blockquote>
<span id="more"></span>

<p>在之前的文章中我们介绍了@RequestMapping注解的原理和uri匹配规则的原理，感兴趣的小伙伴可以点击下面的链接访问。</p>
<ul>
<li>  <a href="https://blog.linwang.tech/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/">SpringMVC系列(一)—RequestMapping注解的原理</a></li>
</ul>
<ul>
<li><a href="https://blog.linwang.tech/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/#more">SpringMVC系列(二)—RequestMapping中Url匹配原理</a></li>
</ul>
<p>SpringMVC将Request成功匹配到某个指定的HandlerMethod后，那又是如何进行参数解析的呢，下面将为大家详细的介绍下参数解析的原理。<br>在开发的过程中，为了能够获取到url中的参数，我们常用的注解有：@RequestBody，@RequestParam，@PathVariable等，下面我们对这三个注解进行一个介绍。</p>
<h2 id="RequestBody注解原理"><a href="#RequestBody注解原理" class="headerlink" title="@RequestBody注解原理"></a>@RequestBody注解原理</h2><p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/1.png"></p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/2.png"></p>
<p>我们将以上述的例子来讲解RequestBody是如何将url中的参数解析到TestDemoAO类中的。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/3.png"></p>
<p>跳过前面url的匹配规则，不再赘述，直接来到通过RequestMappingHandlerAdapter调用handleMethod方法，看下handle的源码。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/4.png"></p>
<p>在handler方法中调用了invokeHandlerMethod方法，经过我们层层深入，终于找到了参数解析的地方，在InvocableHandlerMethod类中。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/5.png"></p>
<p>下面我们来一起看下InvocableHandlerMethod类中的getMethodArgumentValues函数的源码。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/6.png"></p>
<p>getMethodArgumentValues方法一共做了如下事情：</p>
<ul>
<li>获取HandlerMethod的所有参数</li>
<li>遍历每个参数，从参数解析器列表中获取能够解析当前参数的resolver</li>
<li>调用解析器来解析当前参数，并获取参数的值</li>
<li>返回参数值列表</li>
</ul>
<p>从上述步骤中，可以看到对于不同类型的参数，需要的解析器也不同。对于本例中含有@RequestBody注解的参数，对应的解析器为RequestResponseBodyMethodProcessor。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/7.png"></p>
<p>上述为RequestResponseBodyMethodProcessor解析器解析参数的源码，红框中的函数为解析的核心逻辑。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/8.png"></p>
<p>上图中的代码为readWithMessageConverters中的核心代码。通过遍历messageConverters获取适当的convert，并判断canRead，在RequestBody中，只有content-type为application/json时，canRead才会返回true，其余均返回false。看下其源码。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/9.png"></p>
<p>从上图可以看出，request中的mediaType必须为application/json时，canRead返回true，此时才会去获取Request中的body并解析为Java的实体对象。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/10.png"></p>
<p>之后调用父类AbstractJackson2HttpMessageConverter中的read方法将inputMessage中的body解析为javaType。如下图</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/17.png"></p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/11.png"></p>
<p>上述中ObjectMapper.readValue是jackson-databind包中的方法，将一个指定的inputStream解析为javaType类型，此处不再继续深入。通过上述步骤则将request请求中的body解析为了我们的TestDemoAO实体，然后通过反射继续调用HandlerMethod方法。</p>
<h2 id="PathVariable注解原理"><a href="#PathVariable注解原理" class="headerlink" title="@PathVariable注解原理"></a>@PathVariable注解原理</h2><p>在RequestMapping的url匹配规则文章中，我们知道了如果url匹配规则中包含{param}参数，MVC会将参数名作为key，参数值作为value存在request的attribute中，具体详解请看XXX文章。<br>我们可以大胆的猜想，@PathVariable注解的参数一定是从request的attribute中通过key来获取到这个参数值，并赋值给方法的参数的，下面我们一起来验证下这个猜想是否正确。<br>调用的过程与@RequestBody的完全一直，我们不再赘述。两者的区别在于通过参数获取的解析器不一致，被@PathVariable修饰的参数对应的解析器为PathVariableMethodArgumentResolver类。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/12.png"></p>
<p>该解析调用其父类AbstractNameValueMethodArgumentResolver的resolveArgument方法，其中主要逻辑在红框中的resolveName方法中。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/13.png"></p>
<p>上述图中可以验证我们的猜想是正确的，该方法会从request的attribute中拿到保存所有参数的Map，并从中通过key获取参数值并返回。</p>
<h2 id="RequestParam注解原理"><a href="#RequestParam注解原理" class="headerlink" title="@RequestParam注解原理"></a>@RequestParam注解原理</h2><p>在有了上述两个注解的学习经验后，我们这次直接来到获取解析器的源码位置。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/14.png"></p>
<p>从上图中可以看出@RequestParam修饰的参数对应的解析器为RequestParamMethodArgumentResolver。继续看该解析器的resolveArgument方法中的resolveName方法，在该方法中找到如下代码：</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/15.png"></p>
<p>从上图中可以发现RequestParamMethodArgumentResolver解析器从request的Paramter中查询指定name的value值，并返回。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>不管是RequestBody、PathVariable还是RequestParam注解，本质的区别就在于根据参数获取的解析器不同<ul>
<li>RequestBody修饰的参数  -&gt;   RequestResponseBodyMethodProcessor</li>
<li>PathVariable修饰的参数   -&gt;   PathVariableMethodArgumentResolver</li>
<li>RequestParam修饰的参数 -&gt;  RequestParamMethodArgumentResolver</li>
<li>未加任何注解的参数   -&gt;  RequestParamMethodArgumentResolver(这也是为啥我们可以省略RequestParam注解的原因）</li>
</ul>
</li>
</ul>
<p>下面附上这几个解析器的类图。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/16.png"></p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>SpringMVC系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC系列(二)---RequestMapping中url匹配原理</title>
    <url>/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>  本文详解的介绍了@RequestMapping中常见的url匹配类型：精准匹配、模糊匹配。并且分析了这几种类型下url的匹配规则原理</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MappingRegistry.registry</td>
<td>所有的url匹配规则均保存在此Map中</td>
</tr>
<tr>
<td>MappingRegistry.pathLookup</td>
<td>仅保存不含通配符的url匹配规则</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>在<a href="https://blog.linwang.tech/2022/01/23/RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86">SpringMVC系列(一)—RequestMapping注解的原理</a>这篇文章中，我们学习了@RequestMapping注解的原理，以及http请求的流程，但是springMVC到底是如何根据request的url请求来匹配到具体的url规则呢，本章我们就来详细的学习一下。<br>我们知道RequestMapping不仅仅支持精准匹配，还可以进行模糊匹配，即使用* ？ **等通配符，下面我们就分别来看下这两种方式是如何实现的。</p>
<h2 id="精准匹配"><a href="#精准匹配" class="headerlink" title="精准匹配"></a>精准匹配</h2><p>当我们自定义方法上的@RequestMappingMapping注解中不包含通配符时即为精准匹配，例如下面的匹配规则。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/%E7%A4%BA%E4%BE%8B%E5%9B%BE.png"></p>
<p>我们一起来看下上述例子中的匹配源码，如下图。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/1.png"></p>
<p>lookupHandlerMethod函数的作用就是根据给定的lookupPath，查找一个最佳匹配的handleMethod，下面我们继续深入看这个函数。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/2.png"></p>
<p>上图中红框中的函数getMappingsByDirectPath的作用是获取key为指定url的RequestMappingInfo。当返回结果directPathMatches不为空时，继续调用addMatchingMappings函数，我们继续看该函数的源码。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/11.png"></p>
<p>addMatchingMappings函数的作用是对比mapping和request，如果匹配结果不为null，则加入matcher列表中。在上述示例的精准匹配中，这里的mappings为</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/3.png"></p>
<p>此时获取到最佳的RequestMappingInfo匹配，并在mappingRegistry中查找对应的MappingRegistration。并返回其中的handleMethod。</p>
<h2 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h2><h3 id="URL中的通配符为："><a href="#URL中的通配符为：" class="headerlink" title="URL中的通配符为：* ? **"></a>URL中的通配符为：* ? **</h3><p>有时候我们在开发时，url中往往并不是某个具体的字符串，而是一个模糊的通配符，用来匹配特性相同的一类url。举个例子如下：</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/4.png"></p>
<p>假设我们当前http访问的路径为：“<a href="http://localhost:7001/RequestMappingDemoController/vagueMatch%E2%80%9D">http://localhost:7001/RequestMappingDemoController/vagueMatch”</a><br>对于上述的例子，getMappingsByDirectPath函数将无法获取到/RequestMappingDemoController/vagueMatch对应的value值，此时将进入下面的代码中。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/5.png"></p>
<p>可以看到依旧是调用了addMatchingMappings函数，和精准匹配的区别仅仅在于第一个参数不同，精准匹配中第一个参数为查找到的value，而模糊匹配中传入的是整个mappingRegistry中保存的所有key值，需要遍历去查找最佳的匹配。<br>匹配的源码如下：</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/6.png"></p>
<p>pathMatcher是一个Spring提供的工具类，用来校验两个字符串是否匹配，支持*，? ,**, {param}等通配符，RequestMapping注解中的通配符匹配规则本质就是通过pathMatcher来实现的。<br>常见的匹配场景如下：</p>
<table>
<thead>
<tr>
<th>pattern</th>
<th>lookupPath</th>
<th>match</th>
</tr>
</thead>
<tbody><tr>
<td>/a/*</td>
<td>/a/b</td>
<td>true</td>
</tr>
<tr>
<td>/a/?</td>
<td>/a/b</td>
<td>true</td>
</tr>
<tr>
<td>/a/**</td>
<td>/a/b</td>
<td>true</td>
</tr>
<tr>
<td>/a/**</td>
<td>/a/b/c</td>
<td>true</td>
</tr>
<tr>
<td>/a/{param}</td>
<td>/a/b</td>
<td>true</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>/a/*</td>
<td>/a</td>
<td>false</td>
</tr>
<tr>
<td>/a/*</td>
<td>/a/b/c</td>
<td>false</td>
</tr>
<tr>
<td>/a/?</td>
<td>/a</td>
<td>false</td>
</tr>
<tr>
<td>/a/?</td>
<td>/a/b/c</td>
<td>false</td>
</tr>
<tr>
<td>/a/{param}</td>
<td>/a</td>
<td>false</td>
</tr>
</tbody></table>
<h3 id="URL中的通配符包含：-param"><a href="#URL中的通配符包含：-param" class="headerlink" title="URL中的通配符包含：{param}"></a>URL中的通配符包含：{param}</h3><p>通过{param}的方式，我们可以获取url路径中的参数，那么SpringMVC又是怎么做的呢？</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/7.png"></p>
<p>通过addMatchingMappings函数获取到最佳的url匹配规则后，会通过handleMatch对匹配结果Match进行处理，我们继续深入看下HandleMatch源码。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/10.png">    </p>
<p>在handleMatch函数中，调用了extractMatchDetails函数，通过函数名我们可以了解该函数是用来提取Match详情的，我们通过源码来看下其真正的作用：</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/8.png"></p>
<p>在extractMatchDetails函数中，调用了PathMatcher工具类中的extractUriTemplateVariables函数，这个函数的入参有两个，一个是url匹配规则，一个是request中的url访问路径，extractUriTemplateVariables可以从url匹配规则中提取参数名作为key，从url访问路径中提取参数值作为value，存放在Map中，并将Map暴露在Request的Attribute中，如下图。</p>
<p><img src="/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/9.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在上述的篇幅中，我们重点介绍了SpringMVC针对不同类型的url匹配规则是如何获取HandlerMethod的，以及在过程中具体做了哪些操作等。</p>
<ul>
<li>精确匹配<ul>
<li>从MappingRegistry.pathLookup中直接获取指定的handlerMethod</li>
</ul>
</li>
<li>模糊匹配<ul>
<li>从MappingRegistry.registry中获取模糊的url匹配规则(根据PathMatch工具类来实现)</li>
<li>如果url匹配规则中包含{param}，则通过handleMatch获取param对应的参数中，并将其暴露在Request的Attribute中</li>
</ul>
</li>
</ul>
<p>在获取到HandlerMethod后，下一步就是要执行真正的函数了，但是在执行之前，有一步最重要的过程，就是参数解析和映射，这一块内容的详细讲解请看<a href="https://blog.linwang.tech/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%89)---%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/#more">SpringMVC系列(三)—参数解析流程</a>文章。</p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>SpringMVC系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC系列(一)---RequestMapping注解的原理</title>
    <url>/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>  本文将从源码的角度分析@RequestMapping注解的作用，以及不同的url请求是如何路由到对应的method中的</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">简要描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RequestMappingHandlerMapping</td>
<td align="center">用来解析@RequestMapping或者@Controlleriu修饰的类或者方法</td>
</tr>
<tr>
<td align="center">AbstractHandlerMethodMapping</td>
<td align="center">在解析过程中大多数的方法都是在此类中</td>
</tr>
<tr>
<td align="center">RequestMappingInfo</td>
<td align="center">保存方法或者类上@RequestMapping注解中的信息</td>
</tr>
<tr>
<td align="center">HandlerMethod</td>
<td align="center">@RequestMapping注解修饰的方法最终被解析为的目标对象</td>
</tr>
<tr>
<td align="center">MappingRegistry</td>
<td align="center">解析后url到RequestMappingInfo、RequestMappingInfo到HandlerMethod的映射均保存在该类中</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>​    在SpringBoot中，我们只需要在Controller的类和方法上增加一个@RequestMapping注解，就很容易的提供一个url匹配规则，这究竟是怎么做到的？下面我们从两个方面来分析。</p>
<ul>
<li>  应用启动时被@RequestMapping注解的类或者方法会被怎么处理？</li>
<li>  SpringBoot又是如何将http请求正确的路由到指定的方法上？</li>
</ul>
<h2 id="RequestMapping-—-应用启动"><a href="#RequestMapping-—-应用启动" class="headerlink" title="@RequestMapping — 应用启动"></a>@RequestMapping — 应用启动</h2><p>​    这个时候，就必须要提到SpringMVC中一个很重要的类了 – RequestMappingHandlerMapping类，这个类的作用是将我们的Controller中的方法转换为一个RequestMappingInfo类，首先我们先来看一下RequestMappingHandlerMapping的类图：</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123180434628.png"></p>
<p>​    从类图中可以看到，RequestMappingHandlerMapping类实现了InitializingBean接口，这个接口是Spring管理Bean的一个生命周期，实现了这个接口的Bean，spring会在实例化后执行该Bean的afterPropertiesSet()方法。再看这个方法的源码之前，我们要先思考一个问题，RequestMappingHandlerMapping是如何交给Spring来管理的呢？</p>
<h3 id="RMHM的注入"><a href="#RMHM的注入" class="headerlink" title="RMHM的注入"></a>RMHM的注入</h3><p>​    通过全局搜索，发现RequestMappingHandlerMapping会在类WebMvcAutoConfiguration中通过@Bean的方式注入，那WebMvcAutoConfiguration又是怎么注入的呢，其实通过这个类的名字就可以看出来了，这个类是通过SpringBoot提供的AutoConfiguration的机制注入的，这个机制今天不展开来讲，简单的说，就是SpringBoot会在启动的时候，扫描全局的spring.factories文件，并将其中的实现类注入spring容器中，如图所示：</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123183240651.png"></p>
<h3 id="RMHM的初始化"><a href="#RMHM的初始化" class="headerlink" title="RMHM的初始化"></a>RMHM的初始化</h3><p>​    回到我们之前提到的afterPropertiesSet方法，我们一起来看看这个方法中做了哪些事情？</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123184544242.png"></p>
<p>​    方法中主要是对RequestMappingInfo中配置参数的一些初始化，重点我们关注红框中的内容，可以看到其调用了super的afterPropertiesSet方法，我们继续深入查看其源码。</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123185209742.png"></p>
<p>从上图中可以看出，super类中的afterPropertiesSet调用了initHandlerMethods，这个方法主要干了两件事：</p>
<ul>
<li><p>  获取spring容器中的所有bean</p>
</li>
<li><p>  遍历这些bean，判断是否为isHandler()，如果为true，则执行detectHandlerMethods方法。</p>
</li>
</ul>
<p>isHandler的判断逻辑为(类上是否有Controller或者RequestMapping注解)：</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123190959468.png"></p>
<p>​    当检测到类上有Controller或者RequestMapping注解时，进入下面的方法，重点关注红框中的selectMethods方法。</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123191213205.png"> </p>
<p>​    MethodIntrospector.selectMethods方法的含义是：遍历指定class类中的方法，对每个方法执行inspect函数，并返回method -&gt; inspect返回值的Map集合。对于上图中detectHandlerMethods中的selectMethods，inspect的返回值为RequestMappingInfo类。</p>
<p>​    下面我们一起来看下getMappingForMethod中的具体内容：</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123193153797.png"></p>
<p>getMappingForMethod函数分为三个步骤：</p>
<ul>
<li><p>  将method上的RequestMapping注解封装为RequestMappingInfo</p>
</li>
<li><p>  将method所在类上的RequestMapping注解封装为RequestMappingInfo</p>
</li>
<li><p>  将两个结合在一起(结合在一起是为了将url的匹配规则结合起来)</p>
</li>
</ul>
<p>我们继续看detectHandlerMethods后面的代码，可以看到，后面就是将每个method注册为HandlerMethod了。</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123193720661.png"></p>
<p>从上图中的代码中，我们就可以发现，handlerMethod被保存在了mappingRegistry中，继续查看register方法。</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123193843918.png"></p>
<p>registry方法的主要步骤如下：</p>
<ul>
<li><p>   根据类和method创建一个handlerMethod类</p>
</li>
<li><p>  将RequestMappingInfo -&gt; HandlerMethod的映射放入mappingLookup中</p>
</li>
<li><p>  将url -&gt; RequestMappingInfo 的映射放入urlLookup中</p>
</li>
</ul>
<p>至此，应用启动过程中@RequestMapping注解的类的解析过程就完成了，我们总结一下主要的步骤</p>
<ul>
<li><p>  在RequestMappingHandlerMapping启动的过程执行afterPropertiesSet方法</p>
</li>
<li><p>  遍历容器中的所有bean，如果该bean存在@Controller或者@RequestMapping注解，则解析该bean</p>
</li>
<li><p>  解析该bean中所有的方法，查找方法上是否有@RequestMapping注解，如果存在，则将@RequestMapping中的信息保存到RequestMappingInfo中</p>
</li>
<li><p>  将方法返回的RequestMappingInfo和bean的RequestMappingInfo结合起来，并保存为Map&lt;Method, RequestMappingInfo&gt;集合</p>
</li>
<li><p>  对每个method创建HandlerMethod类，并将RequestMappingInfo -&gt; HandlerMethod保存到mappingRegistry的属性mappingLookup中</p>
</li>
<li><p>  将url -&gt; RequestMappingInfo 的映射保存到mappingRegistry的属性urlLookup中</p>
</li>
</ul>
<h2 id="RequestMapping-—-请求转发"><a href="#RequestMapping-—-请求转发" class="headerlink" title="@RequestMapping — 请求转发"></a>@RequestMapping — 请求转发</h2><p>​    上述部分主要讲述了，Springboot在启动的时候，RequestMappingHandlerMapping是如何解析被@RequestMapping修饰的类或者方法的，在本小节中，将带领大家了解一下http请求是如何被正确的路由到对应的方法中的。</p>
<p>​    我们知道SpringMVC中流量转发是通过DispatcherServlet类的doService方法中的doDispatch方法实现的，下面我们一起来看下doDispatch的源码。</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123200238042.png"></p>
<p>​    我们只关注doDispatch中部分相关源码。当http请求到来时，doDispatch会通过getHandler方法获取Request对应的Handler，此处的Handler就是我们自己编写的方法，所以我们只需要继续看getHandler的源码即可。</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123201008364.png"></p>
<p>​    getHandler函数的源码比较简单，就是通过遍历handlerMappings来获取Handler的执行链。我们从图中可以看到总共有7个handlerMappings，在前面小节中我们已经知道了RequestMappingHandlerMapping才是解析的关键，所以我们继续深入查看RequestMappingHandlerMapping中getHandler的源码。</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123201411809.png"></p>
<p>从图中可以看到getHandler调用了getHandlerInternal方法来获取handler，我们继续深入探索。</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123201623903.png"></p>
<p>图中红框的代码为关键代码，调用lookupHandlerMethod来获取指定lookupPath的handlerMethod，我们继续查看lookupHandlerMethod源码。</p>
<p><img src="/2022/01/23/SpringMVC%E7%B3%BB%E5%88%97(%E4%B8%80)---RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86/image-20220123202048571.png"></p>
<p>​    lookupHandlerMethod函数的作用就是通过给定的lookupPath，从mappingRegistry中获取HandlerMethod的最佳匹配，在我们实际的开发中，一个url可能不仅仅匹配到一个RequestMappingInfo，所以该方法会帮我们返回一个最佳的匹配。这部分的具体讲解请看文章<a href="https://blog.linwang.tech/2022/02/19/SpringMVC%E7%B3%BB%E5%88%97(%E4%BA%8C)---RequestMapping%E4%B8%ADUrl%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86/">SpringMVC系列(二)—RequestMapping中url匹配原理</a>。</p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>SpringMVC系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令总结</title>
    <url>/2022/01/06/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>  本文总结了平时生活中经常用到的Git命令，详细的描述了命令的用法，后续还会继续补充，方便以后查看。</p>
</blockquote>
<span id="more"></span>

<h2 id="Git的配置命令"><a href="#Git的配置命令" class="headerlink" title="Git的配置命令"></a>Git的配置命令</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.进入某个目录</span></span><br><span class="line">cd d:/gitDemo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 初始化(执行之后，在当前目录下会有一个.git文件夹)</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<h3 id="配置Git的邮箱和用户名"><a href="#配置Git的邮箱和用户名" class="headerlink" title="配置Git的邮箱和用户名"></a>配置Git的邮箱和用户名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置git的全局邮箱地址</span></span><br><span class="line">git config --global user.email &quot;903862530@qq.com&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置git的全局用户名</span></span><br><span class="line">git config --global user.name &quot;linwang-zf&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看全局配置的用户名和邮箱地址</span></span><br><span class="line">git config --global user.email</span><br><span class="line">git config --global user.name</span><br></pre></td></tr></table></figure>

<h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h3 id="add-和-commit"><a href="#add-和-commit" class="headerlink" title="add 和 commit"></a>add 和 commit</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.将工作区的修改提交到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.将暂存区的内容提交到版本库</span></span><br><span class="line">git commit -m &quot;note&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果修改的文件已经被Git管理，则上述命令可以简化为</span></span><br><span class="line">git commit -am &quot;note&quot;</span><br></pre></td></tr></table></figure>

<h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 该命令会比较 &lt;工作区和暂存区的内容&gt; 和 &lt;暂存区和版本库的内容&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比较结果用颜色区分：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 	（1）工作区和暂存区的内容不一致时，此时文件的颜色为红色</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 	（2）暂存区和版本库的内容不一致时，此时文件的颜色为绿色</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure>

<h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><p><code>git cherry-pick</code>可以将**某次提交或者某几个提交(其他分支)**检入当前分支，详细的操作如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将某次提交的commitHash值检入当前分支</span></span><br><span class="line">git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>

<p>举例来说，代码仓库目前有两个分支master和feature，提交历史如下图</p>
<p><img src="/2022/01/06/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/image-20220110230544989.png" alt="cherry-pick演示"></p>
<p>现在将feature分支的提交f应用到master分支上，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.切换到master分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.Cherry Pick操作</span></span><br><span class="line">git cherry-pick f</span><br></pre></td></tr></table></figure>

<p>除了上述的单次提交之外，cherry-pick还支持<strong>检入多次提交</strong>以及<strong>一段连续提交</strong>到当前分支，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将A和B两个提交检入当前分支</span></span><br><span class="line">git cherry-pick &lt;HashA&gt; &lt;HashB&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将A到B的所有提交检入当前分支(提交A必须先于提交B，且不会包含A提交)</span></span><br><span class="line">git cherry-pick A..B (不包含A提交,相当于(A,B])</span><br><span class="line">git cherry-pick A^..B (包含A提交,相当于[A,B])</span><br></pre></td></tr></table></figure>

<p>当检入的过程中发生了冲突，此时cherry-pick将停下来，让用户决定如何操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 发生冲突后，取消操作，并回退到操作之前的样子</span></span><br><span class="line">git cherry-pick --abort</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发生冲突后，取消操作，但是不会回退到操作之前的样子</span></span><br><span class="line">git cherry-pick --quit</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决完冲突后,并继续执行(最常用的方式)</span></span><br><span class="line">git add .</span><br><span class="line">git cherry-pick --continue</span><br></pre></td></tr></table></figure>

<p><code>cherry-pick</code>命令还支持配置参数，命令如下(命令中的 | 表示两者都可以)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在提交的时候，打开外部编辑器，可以编辑提交信息，如果发生冲突，在解决冲突之后仍然会打开</span></span><br><span class="line">git cherry-pick -e | --edit &lt;commitHash&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只将commitHash提交更新到工作区和暂存区，不提交到版本库</span></span><br><span class="line">git cherry-pick -n | --no-commit &lt;commitHash&gt; </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交的信息后面增加一行 “(cherry picked from commit ...)”，方便以后查到这个提交是如何产生的</span></span><br><span class="line">git cherry-pick -x &lt;commitHash&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在提交信息的末尾追加一行操作者的签名，方便以后查到这个提交是如何产生的。</span></span><br><span class="line">git cherry-pick -s | --signoff &lt;commitHash&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当commitHash提交是一个merge提交时，cherry-pick将默认失败，此时可以采用-m告诉git应该采用哪个分支的变动</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1表示接受变动的分支(merge时所处的分支)，2表示变动来源的分支(merge时指定合并的分支)</span></span><br><span class="line">git cherry-pick -m | --mainline 1 &lt;commitHash&gt; </span><br></pre></td></tr></table></figure>

<p><code>cherry-pick</code>还支持将远程仓库的某次提交检入当前分支，具体命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 增加远程仓库的地址</span></span><br><span class="line">git remote add origin git://gitAddress</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将远程仓库抓取到本地</span></span><br><span class="line">git fetch origin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找将要检入的commitHash</span></span><br><span class="line">git log origin/master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将上述获取的commitHash检入当前分支</span></span><br><span class="line">git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>

<h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p>某一天你在dev分支上开发新需求时，突然被要求改一个线上的紧急Bug，此时你新的功能还未开发完成，不想进行提交。这个时候你就可以采用stash命令，将工作区和暂存区的内容放入栈中，然后切换到其他分支修复bug，当修复完成后，再从栈顶中取出刚刚的内容继续后续的开发。详细的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 保存当前工作区和暂存区的修改内容,括号中的命令可以增加注释信息</span></span><br><span class="line">git stash (git stash save &quot;message&quot;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示栈中保存信息的列表</span></span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure>

<p>当需要从栈中取出之前保存的信息时，可以采用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从栈顶取出一次改动内容，并从栈中删除(恢复最新的进度到工作区)</span></span><br><span class="line">git stash pop</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复最新的进度到工作区和暂存区(尝试将原来暂存区的改动还恢复到暂存区)</span></span><br><span class="line">git stash pop --index</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指定的进度恢复到工作区</span></span><br><span class="line">git stash pop stash@&#123;1&#125;</span><br></pre></td></tr></table></figure>

<p>下面简要分析加–index和不加的区别。</p>
<p><img src="/2022/01/06/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/image-20220111223151327.png" alt="git statsh之前的文件状态"></p>
<p>从上图中可以看出，testStash文件此时处于暂存区的改动（即已经进行了add操作，还未进行commit操作），这时采用<code>git stash</code>将修改内容保存到栈中，当我们用<code>git stash pop</code>命令取出内容时，效果如下：</p>
<p><img src="/2022/01/06/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/image-20220111223513807.png" alt="git stash pop操作结果"></p>
<p>从上图中可以看到，如果不加–index，Git会将所有的改动全部放入工作区(即还未add的状态)，如果加了–index则和之前的状态保持一致。</p>
<p>如果恢复保存进度的时候不想要删除栈中的进度，则可以使用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> apply命令和pop命令的用法完全一致，区别仅在于pop会删除进度，而apply不会</span></span><br><span class="line">git stash apply </span><br></pre></td></tr></table></figure>

<p><strong>删除栈中进度命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除stash_id对应的进度，如果没有指定，则删除最新的进度</span></span><br><span class="line">git stash drop [stash_id]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除栈中所有存储的进度</span></span><br><span class="line">git stash clear</span><br></pre></td></tr></table></figure>

<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><h4 id="rebase常用命令"><a href="#rebase常用命令" class="headerlink" title="rebase常用命令"></a>rebase常用命令</h4><h4 id="rebase和merge的区别"><a href="#rebase和merge的区别" class="headerlink" title="rebase和merge的区别"></a>rebase和merge的区别</h4><p>当我们在自己的分支上开发完成后，通常需要合并其他分支，我们一般会使用merge命令来合并，但是其实也可以采用rebase命令。</p>
<p>假设git当前的Commit提交记录如下所示：</p>
<p><img src="/2022/01/06/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/image-20220113231142561.png" alt="git原始commit图"></p>
<p>此时分别在master分支和mywork分支上进行两次提交，提交之后状态如下图：</p>
<p><img src="/2022/01/06/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/image-20220113231336735.png" alt="提交两次之后的commit图"></p>
<p>此时在master上合并mywork分支，如果使用merge命令，则合并之后的图如下所示：</p>
<p><img src="/2022/01/06/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/image-20220113231555007.png" alt="merge合并示意图"></p>
<p>如果采用rebase合并，则合并之后如下所示：</p>
<p><img src="/2022/01/06/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/image-20220113231647697.png" alt="rebase合并示意图"></p>
<p>从上述分析可以知道，rebase在合并的时候采用的方法时变基，这样的好处是让提交更整齐，但是可能会带来很多冲突；merge合并则直接将两个分支进行合并为一个分支，简单粗暴。</p>
<h2 id="Git远程仓库命令"><a href="#Git远程仓库命令" class="headerlink" title="Git远程仓库命令"></a>Git远程仓库命令</h2><h3 id="删除远程仓库"><a href="#删除远程仓库" class="headerlink" title="删除远程仓库"></a>删除远程仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将空分支推送到远程dev分支，即删除远程dev分支</span></span><br><span class="line">1. git push origin :dev</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程的dev分支</span></span><br><span class="line">2. git push --delete origin/dev</span><br></pre></td></tr></table></figure>



<h3 id="筛选远程仓库地址"><a href="#筛选远程仓库地址" class="headerlink" title="筛选远程仓库地址"></a>筛选远程仓库地址</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看远程仓库的地址,只显示一行，并筛选中第二列元素(仓库地址)</span></span><br><span class="line">git remote -v|head -1|awk &#x27;&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h3><p>在关联远程分支的同时，在本地创建一个同名分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关联远程dev分支，并在本地创建一个同名dev分支</span></span><br><span class="line">git checkout --track origin/dev</span><br></pre></td></tr></table></figure>

<h3 id="同步远程分支"><a href="#同步远程分支" class="headerlink" title="同步远程分支"></a>同步远程分支</h3><p>同步远程分支，并且可以删除远程不存在的本地分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 同步远程分支</span></span><br><span class="line">1. git remote prune origin</span><br></pre></td></tr></table></figure>

<h2 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将某个提交(其他分支)检入当前分支</span></span><br><span class="line">git cherry-pick hashCommit</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将某个分支连续的提交检入当前分支(包含开始的提交的分支e1223b03)</span></span><br><span class="line">git cherry-pick e1223b03^..47eee952</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发生冲突之后，解决冲突</span></span><br><span class="line">git add .</span><br><span class="line">git cherry-pick --continue</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分支名，并匹配以*开头的分支(当前分支)，并打印最后一个字符串的值(以空格分割)</span></span><br><span class="line">git branch|egrep &#x27;^\*&#x27;|awk &#x27;&#123;print $NF&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="checkout相关命令"><a href="#checkout相关命令" class="headerlink" title="checkout相关命令"></a>checkout相关命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将dev分支的某个文件检入master分支</span></span><br><span class="line">1. git checkout master</span><br><span class="line">2. git checkout --patch dev filePath</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统</title>
    <url>/2022/09/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p><strong>CAP</strong> 是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong> 这三个单词首字母组合。由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 <strong>布鲁尔定理（Brewer’s theorem）</strong>。</p>
<ul>
<li>一致性：所有节点访问的数据均为最新的数据副本</li>
<li>可用性：非故障的节点在合理的时间范围内返回合理的响应</li>
<li>分区容错性：分布式系统出现网络分区时，仍然可以对外提供服务</li>
</ul>
<p> CAP理论的含义是在发生网络分区时，如果我们要继续提供服务，那么强一致性和高可用性只能2选1，这就是我们常说的CAP理论无法同时满足，最多只能满足2个。</p>
<p>这是为什么呢？举个例子：</p>
<p>若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p>
<p>因此，分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>
<p>总结：<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。</p>
<blockquote>
<p>即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p>
</blockquote>
<ul>
<li><p>基本可用</p>
<p>允许系统出现故障之后，在功能上或响应时间上有部分损失，但是系统依然基本可用</p>
</li>
<li><p>软状态</p>
<p>允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p>
</li>
<li><p>最终一致性</p>
<p>在达到一定的时间后，系统中的数据副本可以保持一致，达到最终一致性，不需要保证系统的实时一致性</p>
</li>
</ul>
<h3 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h3><p>在分布式集群中，集群之间信息的交互一般有两种方式：</p>
<ul>
<li>集中式的散发消息，由主节点将消息共享给其他的节点</li>
<li>发散式的散发消息，每个节点都可以发送 &amp; 接收消息</li>
</ul>
<p>Gossip协议就是一个发散式的算法，该协议是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员</p>
<p>Redis Cluster、Apache Cassandra等集群都使用到了Gossip协议来进行信息同步。</p>
<p>Gossip协议的两种消息传播模式：</p>
<ul>
<li><p>反熵</p>
<p>具体是如何反熵的呢？集群中的节点，每隔一段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。</p>
</li>
<li><p>谣言传播</p>
<p>谣言传播指的是分布式系统中的一个节点一旦有了新数据之后，就会变为活跃节点，活跃节点会周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。（<strong>仅传播节点新增的数据</strong>）</p>
</li>
</ul>
<h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><p>在日常的系统设计中，我们经常会使用ID来唯一标识一个物品、角色等。比如身份证、车牌号、订单号等等，我们可以认为这个ID就是数据的唯一标识。</p>
<p>分布式ID就是在分布式系统中的ID，分布式ID需要我们保证多个数据节点下， ID依然时唯一的。</p>
<p>分布式ID的特性：</p>
<ul>
<li>全局唯一</li>
<li>高性能、高可用（分布式ID是分布式系统的重要部分，一定要保证性能和SLA）</li>
<li>安全、递增等（锦上添花）</li>
</ul>
<p>下面介绍几种常见的生成分布式ID的算法</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="主键自增"><a href="#主键自增" class="headerlink" title="主键自增"></a>主键自增</h4><p>通过关系型数据库的自增主键来生成唯一ID</p>
<p>优点：这种方式实现简单，ID有序递增，存储空间也比较小</p>
<p>缺点：存在数据库单点问题，每次获取ID需要访问一次数据库，性能不高</p>
<h4 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h4><p>从数据库中批量获取ID，并存储在内存中，当ID快不够时，重新读取数据库获取ID集</p>
<p><img src="/2022/09/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20230418200857471.png" alt="image-20230418200857471"></p>
<p>优点：相比较主键自增的方式，减少了数据库的访问次数，并且ID有序递增，存储空间小</p>
<p>缺点：ID无含义、存在安全问题</p>
<h3 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h3><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UUID.randomUUID()</span><br></pre></td></tr></table></figure>

<p>UUID是全局唯一标识符，由32个16进制的数字组成，总共128位</p>
<p>我们很少会使用UUID作为主键，尽管它是全局唯一的，因为它消耗的存储空间比较大</p>
<p>优点：生成速度快，简单易用</p>
<p>缺点：存储空间占用大，生成的ID无序。</p>
<h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64 bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：</p>
<ul>
<li><p><strong>第 0 位</strong>： 符号位（标识正负），始终为 0，没有用，不用管。</p>
</li>
<li><p><strong>第 1~41 位</strong> ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</p>
</li>
<li><p><strong>第 42~52 位</strong> ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。</p>
</li>
<li><p><strong>第 53~64 位</strong> ：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。</p>
<p><img src="/2022/09/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20230418202116160.png" alt="image-20230418202116160"></p>
<p>优点：生成速度比较快、生成的 ID 有序递增</p>
<p>缺点：可能产生重复ID的问题，强依赖服务器时钟，可能出现时钟回拨或时钟跳跃。</p>
</li>
</ul>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><h4 id="UidGenerator（百度）"><a href="#UidGenerator（百度）" class="headerlink" title="UidGenerator（百度）"></a>UidGenerator（百度）</h4><p>UidGenerator是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。</p>
<p>不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下。</p>
<p><img src="/2022/09/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20230418213437860.png" alt="image-20230418213437860"></p>
<h4 id="Leaf（美团）"><a href="#Leaf（美团）" class="headerlink" title="Leaf（美团）"></a>Leaf（美团）</h4><p>Leaf 提供了 <strong>号段模式</strong> 和 <strong>Snowflake(雪花算法)</strong> 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。</p>
<p>Leaf 对原有的号段模式进行改进，增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段。</p>
<p><img src="/2022/09/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20230418213503777.png" alt="image-20230418213503777"></p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>在单个JVM进程中，我们通常使用Synchronized、Lock、Semaphore等来实现多个线程对共享资源的互斥访问。</p>
<p><img src="/2022/09/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20230417212716576.png" alt="image-20230417212716576"></p>
<p>但是，在分布式系统中，不同的服务器通常运行在不同的节点（即部署在独立的JVM进程中），那上图中的本地锁就无法实现共享资源的互斥访问了，于是就有了 分布式锁。</p>
<p>分布式锁需要满足一下特点：</p>
<ul>
<li>互斥访问：资源在同一时间只能被一个进程访问</li>
<li>可用性：获取锁、释放锁的服务需要保证一定的可用性，防止出现问题造成死锁</li>
<li>重入锁：一个进程获取锁后，可以重复获取锁</li>
</ul>
<p>常见的分布式锁的实现方案有三种：</p>
<h3 id="基于表主键唯一的特性"><a href="#基于表主键唯一的特性" class="headerlink" title="基于表主键唯一的特性"></a>基于表主键唯一的特性</h3><p>利用表主键唯一的特性，如果多个节点同时访问共享资源，那么数据库会保证相同的主键只有一个会被成功插入表中，那么我们就认为插入成功的节点获取锁成功，可以对共享资源进行访问。</p>
<p><img src="/2022/09/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20230417214940302.png" alt="image-20230417214940302"></p>
<p>​    上述实现分布式锁的方法比较简单，存在一些问题：</p>
<p>​    （1）锁的实现强依赖于数据库，数据库是一个单点，一旦数据库服务出现问题，那么会导致分布式锁不可用</p>
<p>​    （2）没有给锁设置失效时间，如果解锁过程出现问题，那么其他节点将永远无法获取该锁</p>
<h3 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h3><p>Redis实现分布式锁的原理其实和表主键唯一的类似，通过SETNX命令设置Key值（意思是当xxx不存在时设置），当我们可以设置成功时，表明节点获取锁成功，如果Key存在，那么获取锁失败。当节点需要释放锁时，直接DEL Key即可。</p>
<p><img src="/2022/09/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20230417220608982.png" alt="image-20230417220608982"></p>
<p>基于Redis实现的分布式锁和表主键唯一存在同样的一个问题，就是当释放锁的逻辑未执行成功时，会导致分布式锁无法在被别的节点使用。</p>
<p>这个问题我们可以通过给key增加一个过期时间来解决，当key过期后，将其删除掉（设置Key和指定过期时间为原子操作）。但是这样做依然会有一个问题：如果过期时间设置过短，节点还未操作完共享资源，那么分布式锁会提前失效；如果过期时间设置过长，又会出现性能问题。</p>
<p>所以我们可以通过给Key自动续期来解决这个问题，Redis提供了一个Java语言的客户端Redisson，可以用来实现分布式锁，并实现锁的自动续期，原理也十分简单，通过在后台启动一个Watch Dog线程（看门狗机制），定时去检测节点是否还在操作共享资源，如果未结束，则更新锁的过期时间。</p>
<p><img src="/2022/09/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20230417223530080.png" alt="image-20230417223530080"></p>
<p>Redisson还可以实现可重入锁，原理也比较简单，Redisson会为每个客户端分配一个唯一ID，客户端获取锁成功时，Key为锁标识，Value是一个Hash类型（其中Key是Redisson为每个客户端分配的ID，value是锁的计数器）。</p>
<p><img src="/2022/09/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20230417224236696.png" alt="image-20230417224236696"></p>
<p>我们继续分析，上述的Redis存在单点问题，所以实际情况中，一般我们会采用Redis集群来保证可用性，但是在Redis集群下，存在一个问题：由于Redis集群之间的数据同步是异步执行的，当某个客户端成功获取到分布式锁后，此时锁的Key记录在Master节点，如果在数据同步至Slave节点之前，Master节点就宕机了，那么此时其他的客户端依然可以获取到分布式锁。</p>
<p>Redis之父Antirez提出了RedLock算法来解决上述问题，原理是每次客户端在获取锁时，会依次向Redis集群中的多个实例获取锁，如果可以和半数以上的实例成功获取锁，那么才认为客户端获取锁成功。此算法保证只要Redis集群中有半数以上的节点可用，分布式锁服务就是正常的，不过不推荐使用，性能较差。</p>
<h3 id="基于Zookeeper实现分布式锁"><a href="#基于Zookeeper实现分布式锁" class="headerlink" title="基于Zookeeper实现分布式锁"></a>基于Zookeeper实现分布式锁</h3><p>Zookeeper的分布式锁基于临时顺序节点和Watcher（事件监听器）实现的。</p>
<p>对于每个锁，首先会创建一个持久节点lock，当客户端获取锁时，会在lock下创建一个临时的顺序节点，如果这个节点的数字是当前lock下最小的节点，则获取锁成功，如果不是，则获取锁失败，然后此时创建一个事件监听器注册在前一个节点上，等待被唤醒（不会自旋，大大降低了对cpu的性能消耗）</p>
<p>总结一下获取锁和释放锁的步骤：</p>
<p>获取锁</p>
<ul>
<li>创建临时顺序节点</li>
<li>判断节点是否是持久节点（锁节点）下最小节点，如果是，获取锁成功，否则下一步</li>
<li>创建一个事件监听器（节点删除监听器），并注册给前一个临时顺序节点，等待被唤醒</li>
</ul>
<p>释放锁</p>
<ul>
<li>删除对应的临时顺序节点即可，此时该节点上的事件监听器触发，唤醒别该锁阻塞的下一个客户端。</li>
<li>如果客户端挂掉了，也没关系，临时节点的生命周期仅是客户端会话级别，当客户端挂掉后，节点会被自动删除，防止其他客户端永远无法获取锁。</li>
</ul>
<p><img src="/2022/09/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20230418212120114.png" alt="image-20230418212120114"></p>
]]></content>
      <categories>
        <category>分布式系列</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-中介模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解行为型模式中的中介者模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>中介模式定义了一个单独的中介对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
<h2 id="二、示意图"><a href="#二、示意图" class="headerlink" title="二、示意图"></a>二、示意图</h2><p><img src="/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/image-20220903163432655.png" alt="image-20220903163432655"></p>
<h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h2><h3 id="航空管制"><a href="#航空管制" class="headerlink" title="航空管制"></a>航空管制</h3><p>为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信，飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来负责每架飞机的航线调度。这样就大大简化了通信网络。</p>
<p>但是中介模式有好处也有坏处，好处是简化了对象之间的交互，坏处是中介类有可能会变成大而复杂的上帝类，所以在使用中介模式的时候，我们要根据实际情况，平衡对象之间交互的复杂度和中介类本身的复杂度。</p>
<h2 id="四、中介模式-VS-观察者模式"><a href="#四、中介模式-VS-观察者模式" class="headerlink" title="四、中介模式 VS 观察者模式"></a>四、中介模式 VS 观察者模式</h2><ul>
<li><p>  在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也讲到，它有可能会产生大而复杂的上帝类。</p>
</li>
<li><p>  除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java设计模式之行为型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-解释器模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解行为型模式中的解释器模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>解释器模式为某个语言定义它的语法表示，并定义一个解释器用来处理这个语法。</p>
<p>上面的定义不太好理解，通俗的讲，就是我们可以自定义一个语法规则来作为信息的载体，然后通过解释器模式中定义好的解释器来解析语法规则，进而可以正确识别出传递的信息。</p>
<h2 id="二、案例"><a href="#二、案例" class="headerlink" title="二、案例"></a>二、案例</h2><p>自定义接口告警规则</p>
<p>在平时的项目开发中，我们需要监控业务系统的运行情况，及时将异常报告给开发者。比如，如果每分钟接口出错数超过100，监控系统就通过短信、微信等方式发送告警给开发者。</p>
<p>假设，我们现在定义一个表达式，来表示一个告警规则，当表达式满足的时候，表示告警规则生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">api_error &gt; <span class="number">100</span> || api_count &lt; <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>对于我们的告警模块来讲，我们需要解析上面的表达式并且根据这两个参数的当前值来判断是否触发告警。</p>
<p>假设自定义的告警规则只包含“||、&amp;&amp;、&gt;、&lt;、==”，并且“&gt;、&lt;、==”的优先级高于“||、&amp;&amp;”，“&amp;&amp;”的运算符优先级高于“||”。则代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String,Long&gt; map)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GtOperator</span> <span class="keyword">implements</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Long desired;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GtOperator</span><span class="params">(String gtExpression)</span> </span>&#123;</span><br><span class="line">        String[] element = gtExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.key = element[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.desired = Long.parseLong(element[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; map)</span> </span>&#123;</span><br><span class="line">        Long current = map.get(key);</span><br><span class="line">        <span class="keyword">return</span> current &gt; desired;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LtOperator</span> <span class="keyword">implements</span> <span class="title">Operator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Long desired;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LtOperator</span><span class="params">(String ltExpression)</span> </span>&#123;</span><br><span class="line">        String[] element = ltExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.key = element[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.desired = Long.parseLong(element[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; map)</span> </span>&#123;</span><br><span class="line">        Long current = map.get(key);</span><br><span class="line">        <span class="keyword">return</span> current &lt; desired;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualOperator</span> <span class="keyword">implements</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Long desired;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualOperator</span><span class="params">(String equalExpression)</span> </span>&#123;</span><br><span class="line">        String[] element = equalExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.key = element[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.desired = Long.parseLong(element[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; map)</span> </span>&#123;</span><br><span class="line">        Long current = map.get(key);</span><br><span class="line">        <span class="keyword">return</span> current.equals(desired);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndOperator</span> <span class="keyword">implements</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Operator&gt; operate = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndOperator</span><span class="params">(String andExpression)</span> </span>&#123;</span><br><span class="line">        String[] element = andExpression.split(<span class="string">&quot;&amp;&amp;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : element) &#123;</span><br><span class="line">            s = s.trim();</span><br><span class="line">            <span class="keyword">if</span> (s.contains(<span class="string">&quot;&gt;&quot;</span>)) &#123;</span><br><span class="line">                operate.add(<span class="keyword">new</span> GtOperator(s));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.contains(<span class="string">&quot;&lt;&quot;</span>)) &#123;</span><br><span class="line">                operate.add(<span class="keyword">new</span> LtOperator(s));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.contains(<span class="string">&quot;==&quot;</span>)) &#123;</span><br><span class="line">                operate.add(<span class="keyword">new</span> EqualOperator(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Operator operator : operate) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!operator.interpret(map)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrOperator</span> <span class="keyword">implements</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Operator&gt; operate = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrOperator</span><span class="params">(String orExpression)</span> </span>&#123;</span><br><span class="line">        String[] element = orExpression.split(<span class="string">&quot;\\|\\|&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : element) &#123;</span><br><span class="line">            s = s.trim();</span><br><span class="line">            operate.add(<span class="keyword">new</span> AndOperator(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Operator operator : operate) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operator.interpret(map)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用解释器模式，我们把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertRuleInterpreter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Long&gt; stats = <span class="keyword">new</span> HashMap&lt;String, Long&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&quot;key1&quot;</span>, <span class="number">11L</span>);</span><br><span class="line">        put(<span class="string">&quot;key2&quot;</span>, <span class="number">9L</span>);</span><br><span class="line">        put(<span class="string">&quot;key3&quot;</span>, <span class="number">22L</span>);</span><br><span class="line">        put(<span class="string">&quot;key4&quot;</span>, <span class="number">881L</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Operator operator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlertRuleInterpreter</span><span class="params">(String ruleExpression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.operator = <span class="keyword">new</span> OrOperator(ruleExpression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operator.interpret(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ruleExpression = <span class="string">&quot;key1 &gt; 100 &amp;&amp; key2 &lt; 30 || key3 &lt; 100 &amp;&amp; key4 == 88&quot;</span>;</span><br><span class="line">        AlertRuleInterpreter interpreter = <span class="keyword">new</span> AlertRuleInterpreter(ruleExpression);</span><br><span class="line">        <span class="keyword">boolean</span> interpret = interpreter.interpret(stats);</span><br><span class="line">        System.out.println(interpret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java设计模式之行为型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-命令模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解行为型模式中的命令模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>命令模式将请求封装为一个对象，这样可以使用不同的请求参数化其他对象，并且能够支持请求的排队执行、记录日志、撤销等功能。</p>
<p>其实上述就是再说，将请求封装为一个对象后，可以将对象进行传递、保存给其他对象，达到实现延迟执行、排队执行、记录日志的功能。</p>
<p>（命令模式将请求封装成对象，方便作为函数参数传递和赋值变量。它主要的应用场景是给命令的执行附加功能，换句话说，就是控制命令的执行，比如：排队、异步、延迟执行命令、给命令记录日志、撤销重做命令等）</p>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><p>命令模式和策略模式的代码实现非常相似，区别在于它们的设计意图、应用场景不同。策略模式不同策略的区别在于算法的实现方式不同，本质是可以互相替换的。但是命令模式下不同命令完全是不同的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute CommandA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute CommandB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Command&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            List&lt;Request&gt; requests = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//从网络中获取request请求</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (Request request : requests) &#123;</span><br><span class="line">                Command command = <span class="keyword">null</span>;</span><br><span class="line">                Event event = request.getEvent();</span><br><span class="line">                <span class="keyword">if</span> (event == Event.CommandA) &#123;</span><br><span class="line">                    command = <span class="keyword">new</span> CommandA();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event = Event.CommandB)&#123;</span><br><span class="line">                    command = <span class="keyword">new</span> CommandB();</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(command);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Command command : list) &#123;</span><br><span class="line">                command.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java设计模式之行为型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-备忘录模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解行为型模式中的备忘录模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p>
<h2 id="二、结构图"><a href="#二、结构图" class="headerlink" title="二、结构图"></a>二、结构图</h2><p><img src="/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/image-20220903115120826.png" alt="image-20220903115120826"></p>
<p>备忘录模式的定义中强调了要不违背封装原则。</p>
<p>备忘录模式通过创建快照来保证不违背封装原则，快照类只暴露了get方法。</p>
<h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存最新数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputText</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        sb.append(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreSnapshot</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        sb.replace(<span class="number">0</span>, sb.length(), text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快照类，备份数据的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Snapshot</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Snapshot</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.text = text;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快照保存的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Stack&lt;Snapshot&gt; holder = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Snapshot snapshot)</span> </span>&#123;</span><br><span class="line">            holder.push(snapshot);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Snapshot <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> holder.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputText inputText = <span class="keyword">new</span> InputText();</span><br><span class="line">        SnapshotHolder snapshotHolder = <span class="keyword">new</span> SnapshotHolder();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String input = scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (input.equals(<span class="string">&quot;:list&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(inputText.getText());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.equals(<span class="string">&quot;:undo&quot;</span>)) &#123;</span><br><span class="line">                Snapshot pop = snapshotHolder.pop();</span><br><span class="line">                inputText.restoreSnapshot(pop.getText());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                snapshotHolder.push(<span class="keyword">new</span> Snapshot(inputText.getText()));</span><br><span class="line">                inputText.append(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java设计模式之行为型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-访问者模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解行为型模式中的访问者模式</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p>
<h2 id="二、结构图"><a href="#二、结构图" class="headerlink" title="二、结构图"></a>二、结构图</h2><p><img src="/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/image-20220901085536606.png" alt="image-20220901085536606"></p>
<p>一般来说，访问者模式针对的是一组类型不同的对象（ResourceA、ResourceB），它们有相同的接口或者抽象父类。在不同的场景下，我们可能需要对这一组对象进行一系列不相关的业务操作（Extractor、Compressor）等。但为了避免不断添加功能导致类不断膨胀，职责越来越不单一。以及避免频繁地添加功能导致地频繁代码修改。可以使用访问者模式，将对象和操作解耦，将这些操作定义在访问者类中。</p>
<h2 id="三、代码示例"><a href="#三、代码示例" class="headerlink" title="三、代码示例"></a>三、代码示例</h2><p>资源类接口及实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filePath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resource</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visit)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfFile</span> <span class="keyword">extends</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PdfFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visit)</span> </span>&#123;</span><br><span class="line">        visit.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问者类（操作类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(PdfFile file)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Extractor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(PdfFile file)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提取文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Compressor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(PdfFile file)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Visitor compressor = <span class="keyword">new</span> Compressor();</span><br><span class="line">    Visitor extractor = <span class="keyword">new</span> Extractor();</span><br><span class="line">    List&lt;Resource&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> PdfFile(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (Resource resource : list) &#123;</span><br><span class="line">        resource.accept(extractor);</span><br><span class="line">        resource.accept(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">提取文件</span><br><span class="line">压缩文件</span><br></pre></td></tr></table></figure>

<h2 id="四、引申"><a href="#四、引申" class="headerlink" title="四、引申"></a>四、引申</h2><h3 id="双分派的语言不需要访问者"><a href="#双分派的语言不需要访问者" class="headerlink" title="双分派的语言不需要访问者"></a>双分派的语言不需要访问者</h3><p>单分派指的是执行哪个对象的方法，是根据对象的运行时类型来决定的。执行对象的哪个方法，是根据方法参数在编译时声明的类型来决定的；</p>
<p>双分派指的是执行哪个对象的方法，是根据对象的运行时类型来决定的。执行对象的哪个方法，是根据方法参数的运行时类型来决定的。（与Java静态单分配、动态多分配一起理解）</p>
<p>如果支持双分派的语言，我们将不需要在资源文件中引用访问者的对象，而是直接在访问者中重载函数即可（函数参数为不同的资源实现类），这样根据资源类在运行时的实际类型也可以找到正确的函数调用。（其实访问者模式就是用单分派来模拟多分派的代码实现）</p>
]]></content>
      <categories>
        <category>Java设计模式之行为型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-迭代器模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解行为型模式中的迭代器模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>迭代器模式，它是用来遍历集合对象的，迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器中，让两者的职责更加单一。</p>
<h2 id="二、结构图"><a href="#二、结构图" class="headerlink" title="二、结构图"></a>二、结构图</h2><p><img src="/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20220830231841637.png" alt="image-20220830231841637"></p>
<p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口和容器实现类，迭代器又包含迭代器接口和迭代器实现类。对于迭代器模式的类图如上图所示。</p>
<h2 id="三、原理实现"><a href="#三、原理实现" class="headerlink" title="三、原理实现"></a>三、原理实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayIter</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> List&lt;E&gt; elementData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayIter</span><span class="params">(List&lt;E&gt; elementData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.elementData = elementData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != elementData.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor &gt;= elementData.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elementData.get(cursor++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bds&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;adfsd&quot;</span>);</span><br><span class="line">        ArrayIter&lt;String&gt; iter = <span class="keyword">new</span> ArrayIter&lt;&gt;(list);</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，集合的遍历一般有三种方式：for循环、foreach循环和迭代器。foreach只是一种语法糖，底层还是迭代器。迭代器相比于for循环，有以下几个好处。</p>
<ul>
<li>  迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可</li>
<li>  迭代器模式将集合对象的遍历操作从集合类中拆分出来，放在迭代器类中，让两者的职责更加单一。</li>
<li>  迭代器模式让添加新的遍历算法更加容器，更符合开闭原则。并且由于迭代器模式基于接口而非实现编程，替换迭代器也十分的容易。</li>
</ul>
<p>迭代器在遍历的时候，无法通过容器删除、添加元素，因为这种行为会导致程序出现无法预期的行为，比如遍历不到某些元素、重复遍历某些元素等，所以Java采用fail-fast机制，如果在迭代器遍历的时候，通过容器删除、添加了元素，直接抛出异常。Java在迭代器中提供了remove方法来实现遍历过程中的删除，但是迭代器中的remove方法仅可以删除游标cursor的前一个元素，而且每次next之后只能remove一个元素，连续两次remove会报错。</p>
<h2 id="四、实现支持“快照”功能的迭代器"><a href="#四、实现支持“快照”功能的迭代器" class="headerlink" title="四、实现支持“快照”功能的迭代器"></a>四、实现支持“快照”功能的迭代器</h2><p>第三节中利用fail-fast机制，保证在迭代器遍历容器的时候不会增加、删除元素，但是如果我们可以在迭代器遍历的时候，对当前容器的数据做一份快照，那么哪怕容器增加、删除元素，对迭代器也是没有影响的。代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> List&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnapshotIterator</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.list.addAll(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(cursor++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bds&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;adfsd&quot;</span>);</span><br><span class="line">        SnapshotIterator&lt;String&gt; iter = <span class="keyword">new</span> SnapshotIterator&lt;&gt;(list);</span><br><span class="line">        iter.next();</span><br><span class="line">        list.add(<span class="number">0</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的原理其实也很简单，其实就是迭代器中对容器的数据进行了一份拷贝，由于Java默认是浅拷贝，所以内存的损耗不是很大，还是可以接受的。但是如果不想对数据做拷贝呢？如何在原来数据的基础实现快照功能。</p>
<p>其实我们只需要给ArrayList中增加两个成员变量，一个是addTime，一个是delTime（默认为Integer的MAX_VALUE），表示数据添加的时间和数据删除的时间。在创建迭代器时保存一个迭代器创建的时间，当addTime &lt; snapshotTime &lt; delTime时，迭代器才会遍历该元素。代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> total;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> actually;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">private</span> Long[] addTime;</span><br><span class="line">    <span class="keyword">private</span> Long[] delTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elementData = <span class="keyword">new</span> Object[CAPACITY];</span><br><span class="line">        addTime = <span class="keyword">new</span> Long[CAPACITY];</span><br><span class="line">        delTime = <span class="keyword">new</span> Long[CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SnapshotIterator2&lt;E&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        elementData[total] = e;</span><br><span class="line">        addTime[total] = System.currentTimeMillis();</span><br><span class="line">        delTime[total] = Long.MAX_VALUE;</span><br><span class="line">        total++;</span><br><span class="line">        actually++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elementData[i].equals(obj)) &#123;</span><br><span class="line">                delTime[i] = System.currentTimeMillis();</span><br><span class="line">                actually--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings((&quot;Unchecked&quot;))</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= total) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActually</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> actually;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addTime[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDel</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delTime[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotIterator2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> snapshotTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnapshotIterator2</span><span class="params">(ArrayList&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.snapshotTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.size = list.getActually();</span><br><span class="line">        <span class="keyword">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        justNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E e = list.get(cursor++);</span><br><span class="line">        justNext();</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">justNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cursor &lt; list.getTotal()) &#123;</span><br><span class="line">            <span class="keyword">long</span> add = list.getAdd(cursor);</span><br><span class="line">            <span class="keyword">long</span> del = list.getDel(cursor);</span><br><span class="line">            <span class="keyword">if</span> (snapshotTime &gt; add &amp;&amp; snapshotTime &lt; del) &#123;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bds&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;adfsd&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中上述的代码还是有点问题，在不真正删除元素的情况下，将无法随机访问list中的元素，必须遍历一边，找到真正的索引数据。解决方法也很简单，list中保存一个删除元素的数组，每次get的时候从该数组中获取元素即可。</p>
]]></content>
      <categories>
        <category>Java设计模式之行为型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-状态模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解行为型模式中的状态模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有很多种，除了状态模式，比较常用的还有分支逻辑法和查表法。</p>
<h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p><img src="/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20220830222926235.png" alt="image-20220830222926235"></p>
<p>有限状态机有三个组成部分：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只是转移状态，不执行任何状态。</p>
<h2 id="三、应用场景和案例"><a href="#三、应用场景和案例" class="headerlink" title="三、应用场景和案例"></a>三、应用场景和案例</h2><img src="image-20220830223633480.png" alt="image-20220830223633480" style="zoom: 25%;" />

<p>上图为“超级马里奥”游戏的多种形态，我们以此为例，来讲解状态模式的三种实现方式。</p>
<h3 id="分支逻辑法"><a href="#分支逻辑法" class="headerlink" title="分支逻辑法"></a>分支逻辑法</h3><p>状态表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    SMALL(<span class="number">0</span>),</span><br><span class="line">    SUPER(<span class="number">1</span>),</span><br><span class="line">    FIRE(<span class="number">2</span>),</span><br><span class="line">    CAPE(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState == State.SMALL) &#123;</span><br><span class="line">            score += <span class="number">100</span>;</span><br><span class="line">            currentState = State.SUPER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState == State.SMALL || currentState == State.SUPER) &#123;</span><br><span class="line">            score += <span class="number">200</span>;</span><br><span class="line">            currentState = State.CAPE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState == State.SMALL || currentState == State.SUPER) &#123;</span><br><span class="line">            score += <span class="number">300</span>;</span><br><span class="line">            currentState = State.FIRE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState == State.SUPER) &#123;</span><br><span class="line">            score -= <span class="number">100</span>;</span><br><span class="line">            currentState = State.SMALL;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentState == State.CAPE) &#123;</span><br><span class="line">            score -= <span class="number">200</span>;</span><br><span class="line">            currentState = State.SMALL;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentState == State.FIRE) &#123;</span><br><span class="line">            score -= <span class="number">300</span>;</span><br><span class="line">            currentState = State.SMALL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StateMachine machine = <span class="keyword">new</span> StateMachine();</span><br><span class="line">        machine.obtainFireFlower();</span><br><span class="line">        System.out.println(machine.getScore());</span><br><span class="line">        System.out.println(machine.getCurrentState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于简单的状态机，分支逻辑这种实现方式是可以接受的。但是对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的if-else语句。可读性和可维护性很差。</p>
<h3 id="查表法"><a href="#查表法" class="headerlink" title="查表法"></a>查表法</h3><p>状态的表示和上述分支逻辑法相同，不同的是状态机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    GET_MUSHROOM(<span class="number">0</span>),</span><br><span class="line">    GET_CAPE(<span class="number">1</span>),</span><br><span class="line">    GET_FIRE(<span class="number">2</span>),</span><br><span class="line">    MEET_MONSTER(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Event</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachine2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StateMachine2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.currentState = SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> State[][] transitionTable = &#123;</span><br><span class="line">            &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">            &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">            &#123;CAPE, CAPE, CAPE, SMALL&#125;,</span><br><span class="line">            &#123;FIRE, FIRE, FIRE, SMALL&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] actionTable = &#123;</span><br><span class="line">            &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">200</span>, <span class="number">300</span>, -<span class="number">100</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">200</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">300</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = currentState.getValue();</span><br><span class="line">        currentState = transitionTable[state][event.getValue()];</span><br><span class="line">        score = actionTable[state][event.getValue()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executeEvent(Event.GET_MUSHROOM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executeEvent(Event.GET_CAPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executeEvent(Event.GET_FIRE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executeEvent(Event.MEET_MONSTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StateMachine2 machine = <span class="keyword">new</span> StateMachine2();</span><br><span class="line">        machine.obtainFireFlower();</span><br><span class="line">        System.out.println(machine.getScore());</span><br><span class="line">        System.out.println(machine.getCurrentState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比较分支逻辑的实现方式，查表法的代码更加清晰，可读性和可维护性更好，当修改状态机时，我们只需要修改二维数组即可。</p>
<h3 id="状态模式法"><a href="#状态模式法" class="headerlink" title="状态模式法"></a>状态模式法</h3><p>状态表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMario</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">State <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">(StateMachine3 machine)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">(StateMachine3 machine)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainFire</span><span class="params">(StateMachine3 machine)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">(StateMachine3 machine)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallMario</span> <span class="keyword">implements</span> <span class="title">IMario</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SmallMario small = <span class="keyword">new</span> SmallMario();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SmallMario</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SmallMario <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> State.SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">(StateMachine3 machine)</span> </span>&#123;</span><br><span class="line">        machine.setCurrentState(SuperMario.getInstance());</span><br><span class="line">        machine.setScore(machine.getScore() + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">(StateMachine3 machine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFire</span><span class="params">(StateMachine3 machine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">(StateMachine3 machine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMario</span> <span class="keyword">implements</span> <span class="title">IMario</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SuperMario small = <span class="keyword">new</span> SuperMario();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SuperMario</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SuperMario <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> State.SUPER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">(StateMachine3 machine)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">(StateMachine3 machine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFire</span><span class="params">(StateMachine3 machine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">(StateMachine3 machine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachine3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> IMario currentState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StateMachine3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.currentState = SmallMario.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.obtainMushRoom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.obtainCape(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.obtainFire(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.obtainMushRoom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(IMario currentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMario <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StateMachine3 machine = <span class="keyword">new</span> StateMachine3();</span><br><span class="line">        machine.obtainMushRoom();</span><br><span class="line">        System.out.println(machine.getScore());</span><br><span class="line">        System.out.println(machine.getCurrentState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在查表法的代码中，事件触发的动作只是简单的积分加减，所以，我们用一个int类型的二维数组就能表示。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作，那么查表法就无法满足要求了。虽然分支逻辑法不存在这个问题，但是它又存在之前讲到的其他问题。所以采用上述状态模式的方法，将事件触发的状态转移和动作执行拆分到不同的状态类中。</p>
]]></content>
      <categories>
        <category>Java设计模式之行为型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-职责链模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解行为型模式中的职责链模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p>
<p>职责链模式、模板模式、策略模式常常用在框架的开发中，我们可以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p>
<h2 id="二、结构图"><a href="#二、结构图" class="headerlink" title="二、结构图"></a>二、结构图</h2><p><img src="/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/image-20220829220542776.png" alt="image-20220829220542776"></p>
<p>一般来讲，责任链有两种实现方式，一种是每个过滤器持有下一个过滤器的引用，还有一种是过滤器链中保存一个过滤器数组，包含所有的过滤器。下面通过具体代码示例讲解。</p>
<h2 id="三、原理和实现"><a href="#三、原理和实现" class="headerlink" title="三、原理和实现"></a>三、原理和实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(FilterChain chain)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterA</span> <span class="keyword">extends</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(FilterChain chain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器A...请求&quot;</span>);</span><br><span class="line">        chain.doChain();</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器A...响应&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterB</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(FilterChain chain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器B...请求&quot;</span>);</span><br><span class="line">        chain.doChain();</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器B...响应&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码为过滤器的结构定义，下面为过滤器链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Filter[] filters = <span class="keyword">new</span> Filter[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">            Filter filter = filters[pos++];</span><br><span class="line">            filter.doFilter(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(Filter filter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == filters.length) &#123;</span><br><span class="line">            Filter[] newFilters = <span class="keyword">new</span> Filter[n + <span class="number">10</span>];</span><br><span class="line">            System.arraycopy(filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, n);</span><br><span class="line">            filters = newFilters;</span><br><span class="line">        &#125;</span><br><span class="line">        filters[n++] = filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Filter filter1 = <span class="keyword">new</span> FilterA();</span><br><span class="line">        Filter filter2 = <span class="keyword">new</span> FilterB();</span><br><span class="line">        FilterChain filterChain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        filterChain.addFilter(filter1);</span><br><span class="line">        filterChain.addFilter(filter2);</span><br><span class="line">        filterChain.doChain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">过滤器A...请求</span><br><span class="line">过滤器B...请求</span><br><span class="line">过滤器B...响应</span><br><span class="line">过滤器A...响应</span><br></pre></td></tr></table></figure>

<p>上述采用的方式和Servlet的ApplicationFilterChain的思路一致，通过这种递归的方式，既可以拦截请求，也可以拦截响应。如果通过for循环来遍历调用filters中的过滤器，将无法拦截响应。</p>
<h2 id="四、Spring-Interceptor的实现原理"><a href="#四、Spring-Interceptor的实现原理" class="headerlink" title="四、Spring Interceptor的实现原理"></a>四、Spring Interceptor的实现原理</h2><p>Spring MVC的拦截器也是采用责任链的方式，和上述的思路基本一致，不过并没有采用递归的方式来实现，为了也可以在拦截器前后执行操作，在Interceptor中定义了两个函数：preHandler 和 postHandler，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorA</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截器A---拦截客户端发送的请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截器A---拦截返回给客户端的响应&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截器A---总是执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorB</span> <span class="keyword">extends</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截器B---拦截客户端发送的请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截器B---拦截返回给客户端的响应&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截器B---总是执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器的执行链如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorExecutionChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Interceptor[] interceptors = <span class="keyword">new</span> Interceptor[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Integer index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Interceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="keyword">if</span> (!interceptor.preHandle()) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                afterCompletion();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Interceptor interceptor = interceptors[i];</span><br><span class="line">            interceptor.postHandle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = index == <span class="keyword">null</span> ? n - <span class="number">1</span> : index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Interceptor interceptor = interceptors[i];</span><br><span class="line">            interceptor.afterCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == interceptors.length) &#123;</span><br><span class="line">            Interceptor[] newInterceptors = <span class="keyword">new</span> Interceptor[n + <span class="number">10</span>];</span><br><span class="line">            System.arraycopy(interceptors, <span class="number">0</span>, newInterceptors, <span class="number">0</span>, n);</span><br><span class="line">            interceptors = newInterceptors;</span><br><span class="line">        &#125;</span><br><span class="line">        interceptors[n++] = interceptor;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Interceptor interceptor1 = <span class="keyword">new</span> InterceptorA();</span><br><span class="line">        Interceptor interceptor2 = <span class="keyword">new</span> InterceptorB();</span><br><span class="line">        InterceptorExecutionChain chain = <span class="keyword">new</span> InterceptorExecutionChain();</span><br><span class="line">        chain.addInterceptor(interceptor1);</span><br><span class="line">        chain.addInterceptor(interceptor2);</span><br><span class="line">        <span class="keyword">boolean</span> result = chain.preHandle();</span><br><span class="line">        <span class="keyword">if</span>(!result) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        chain.postHandle();</span><br><span class="line">		chain.afterCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">拦截器A---拦截客户端发送的请求</span><br><span class="line">拦截器B---拦截客户端发送的请求</span><br><span class="line">拦截器B---拦截返回给客户端的响应</span><br><span class="line">拦截器A---拦截返回给客户端的响应</span><br><span class="line">拦截器B---总是执行</span><br><span class="line">拦截器A---总是执行</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java设计模式之行为型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-策略模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解行为型模式中的策略模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>策略模式定义一族算法类，将每个算法分别封装起来，让它们可以互相替换，策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p>
<h2 id="二、结构图"><a href="#二、结构图" class="headerlink" title="二、结构图"></a>二、结构图</h2><p><img src="/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-20220826082013840.png" alt="image-20220826082013840"></p>
<p>策略模式包含三个部分，分别是策略的定义、创建和使用。</p>
<ul>
<li>  策略的定义包含一个策略的接口和策略的不同实现类</li>
<li>  策略的创建一般会通过工厂类来实现，通过type来选择创建不同的策略</li>
<li>  策略的使用最常见的是在动态时根据配置来决定使用哪种策略。</li>
</ul>
<h2 id="三、场景和应用"><a href="#三、场景和应用" class="headerlink" title="三、场景和应用"></a>三、场景和应用</h2><p>需求：实现对一个文件的排序功能，文件中只包含整型数，并且，相邻的数字通过逗号来分割。</p>
<p>思路：如果文件不大，可以将文件内容加载到内存中，然后进行排序；如果文件很大，我们无法将其一次性全部加载到内存中，那么我们就要用外部排序算法了；如果文件更大，我们为了利用cpu多核的优势，可以在外部排序算法的基础上进行优化，加入多线程并发排序的功能；如果文件非常大，则需要利用多机的处理能力，提高排序效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sorter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(String filePath)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QuickSort,ExternalSort,ConcurrentExternalSort...等排序算法的实现类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SorterFactory</span></span>&#123;</span><br><span class="line">	Map&lt;String,Sorter&gt; sorts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sorter <span class="title">getSorter</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortFile</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">long</span> size = file.length();</span><br><span class="line">        Sorter sorter;</span><br><span class="line">        <span class="keyword">if</span>(size &lt; 6GB) sorter = SorterFactory.getSorter(<span class="string">&quot;quickSort&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(size &lt; 10GB) sorter = SorterFactory.getSorter(<span class="string">&quot;externalSort&quot;</span>);</span><br><span class="line">        ....</span><br><span class="line">        sorter.sort(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码采用策略模式来实现这个需求，涵盖了策略的定义、创建和使用三个部分。当我们添加一个新的排序算法时，是需要增加一个Sorter的实现类即可，并且需要稍微修改下SorterFactory和Demo类，如果完全不想修改这两个文件，则可以将排序算法写入配置文件或者写一个自定义的注解。排序工厂类每次扫描注解或者读取配置文件来确定有哪些排序算法，并通过反射来创建排序对象。</p>
]]></content>
      <categories>
        <category>Java设计模式之行为型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-模板模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解行为型模式中的模板模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>模板模式全称是模板方式设计模式，在GoF的《设计模式》一书中，它是这么定义的：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>
<h2 id="二、结构图"><a href="#二、结构图" class="headerlink" title="二、结构图"></a>二、结构图</h2><p><img src="/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/image-20220825083539421.png" alt="image-20220825083539421"></p>
<h2 id="三、原理及实现"><a href="#三、原理及实现" class="headerlink" title="三、原理及实现"></a>三、原理及实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass demo = <span class="keyword">new</span> ConcreteClass1();</span><br><span class="line">        demo.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板模式有两大作用：一是代码复用；二是扩展。</p>
<p>我们先来看它的第一个作用：代码复用，模板方法将不变的流程抽象到父类的模板方法中，将可变的方法留给不同的子类来实现。所有的子类都可以复用父类中定义的流程代码。比如Java中的InputStream和AbstractList等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off ,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="number">0xff</span>) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理AbstractList也用到了模板设计模式，在该类中的addAll方法调用了add方法，add方法默认抛出异常，需要各自子类自己实现。</p>
<p>模板模式的第二大作用：扩展</p>
<p>扩展功能常常是在一些框架中，框架中定义好一套标准的方法流程，并流程一些抽象方法作为hook点，来让业务自己实现，通过这种方法可以在不改变框架代码的前提下，实现不同的功能。比如Java的Servlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当请求过来时，会进入到对应的Servlet，然后执行service函数，该函数定义了标准的http请求方法流程，并根据不同的请求方法调用不同的函数，这些doGet和doPost就是留个业务的扩展点。</p>
<h2 id="四、回调函数"><a href="#四、回调函数" class="headerlink" title="四、回调函数"></a>四、回调函数</h2><p>回调函数的原理和实现和模板方法非常类似，唯一的区别在于模板方法是通过继承父类，并实现父类的抽象方法来实现。而回调函数则是通过将回调函数传入到方法中来等待回调触发。根据触发时机可以分为同步回调和异步回调。</p>
<h3 id="同步回调"><a href="#同步回调" class="headerlink" title="同步回调"></a>同步回调</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SyncCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executeCallback</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TemplateClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">(SyncCallback syncCallback)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;业务逻辑&quot;</span>);</span><br><span class="line">            syncCallback.executeCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TemplateClass demo = <span class="keyword">new</span> TemplateClass();</span><br><span class="line">        demo.templateMethod(<span class="keyword">new</span> SyncCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;同步回调执行成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述的代码中可以看到同步回调本质也是模板方法，只是用组合代替了继承（这里的组合指的是模板类持有指向回调函数对象的引用，继承是必须实现模板类中定义的抽象方法）。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SyncCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executeCallback</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TemplateClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SyncCallback callback;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TemplateClass</span><span class="params">(SyncCallback callback)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.callback = callback;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;业务逻辑&quot;</span>);</span><br><span class="line">            callback.executeCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TemplateClass demo = <span class="keyword">new</span> TemplateClass(<span class="keyword">new</span> SyncCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;异步回调执行成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        demo.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出，异步调用本质就是先将回调函数的引用赋值给模板类，然后由模板类决定调用时机。该种实现方式和观察者模式非常类似（需要先将观察者提前注册给事件，等待事件发布后响应观察者）。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>模板模式可以用在具有相同或者相似的流程，只是流程中的具体细节稍有不同的场景下。并且不仅仅可以通过模板模式，还可以通过回调来实现。</p>
<p>回调和模板的区别</p>
<ul>
<li>  模板采用继承的方式，回调采用组合的方式</li>
<li>  模板需要继承父类，所有不再其他的继承能力</li>
<li>  如果模板类中定义了多个模板方法，那么子类需要全部实现，但是回调不需要</li>
</ul>
]]></content>
      <categories>
        <category>Java设计模式之行为型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-观察者模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解行为型模式中的观察者模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>观察者模式也被称为发布订阅模式，在GoF的《设计模式》中的定义是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>
<h2 id="二、结构图"><a href="#二、结构图" class="headerlink" title="二、结构图"></a>二、结构图</h2><p><img src="/dimage-20220824074936472.png" alt="image-20220824074936472"></p>
<p>一般情况下，被依赖的对象叫作被观察者，依赖的对象叫做观察者。当被观察者的事件成功触发时，此时将触发所有依赖的观察者的d响应时间。</p>
<h2 id="三、场景"><a href="#三、场景" class="headerlink" title="三、场景"></a>三、场景</h2><p>假设现在有一个P2P的投资理财系统，用户注册成功之后，需要给用户发放投资体验金、优惠券、欢迎注册站内信等，传统的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">register</span><span class="params">(String account,String password)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 校验参数</span></span><br><span class="line">        <span class="keyword">long</span> userId = userService.register(account,password);</span><br><span class="line">        <span class="comment">// 1. 发送体验金</span></span><br><span class="line">        <span class="comment">// 2. 发放优惠券</span></span><br><span class="line">        <span class="comment">// 3. 发送站内信</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上述的接口中做了4件事，违反了单一职责原则，如果以后还有更多的需求需要在注册后实现，那么这个方法将变得越来越臃肿，所以此时就可以用观察者模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegObserver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(<span class="keyword">long</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略发送体验金、优惠券等实现类</span></span><br><span class="line">... </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    List&lt;RegObserver&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">register</span><span class="params">(String account,String password)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 校验参数</span></span><br><span class="line">        <span class="keyword">long</span> userId = userService.register(account,password);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(RegObserver observer : observers)&#123;</span><br><span class="line">            observer.handleRegSuccess(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们后期增加新的需求后，只需要实现RegObserver接口，并将其加入到注册事件的观察者列表中即可。</p>
<p>常见的应用场景还有：邮件订阅、RSS Feeds等</p>
<p>常见的实现方式：同步阻塞、异步非阻塞、进程内、进程间的实现方式。</p>
<ul>
<li>  同步阻塞：最经典的实现方式，主要是为了代码解耦</li>
<li>  异步非阻塞：不仅能代码解耦，还能提高代码的执行效率</li>
<li>  进程间：解耦更彻底，一般是基于消息队列来实现。</li>
</ul>
<h3 id="异步非阻塞观察者模式的简易实现"><a href="#异步非阻塞观察者模式的简易实现" class="headerlink" title="异步非阻塞观察者模式的简易实现"></a>异步非阻塞观察者模式的简易实现</h3><p>EventBus是一个事件发布/订阅框架，基于此框架，我们可以在代码中非常容易的实现观察者模式，并且还支持同步阻塞 + 异步非阻塞模式。</p>
<p>框架的作用：隐藏实现细节、降低开发难度、做到代码复用、解耦业务与非业务代码、让程序员聚焦业务开发</p>
<h4 id="手把手实现一个EventBus框架"><a href="#手把手实现一个EventBus框架" class="headerlink" title="手把手实现一个EventBus框架"></a>手把手实现一个EventBus框架</h4><p>下面是自己手写的一个EventBus框架，总共涉及到5个类</p>
<ul>
<li>  EventBus ： 该类是阻塞同步观察者模式的实现类</li>
<li>  AsyncEventBus：该类是异步非阻塞观察者模式的实现类</li>
<li>  ObserverRegistry：该类中保存了Event 和 执行方法的注册关系（简单的说就是event该执行哪些方法）</li>
<li>  ObserverHandlerMethod：执行的方法（包含方法所在的类和方法句柄）</li>
<li>  Subscribe：注解，表明观察者中该方法是可以用来接受消息的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverHandlerMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String observerObj;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObserverHandlerMethod</span><span class="params">(String observerObj, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observerObj = observerObj;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeMethod</span><span class="params">(Object param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(observerObj);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            Method method = clazz.getMethod(methodName, param.getClass());</span><br><span class="line">            method.invoke(obj, param);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | InvocationTargetException | IllegalAccessException | ClassNotFoundException | InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, List&lt;ObserverHandlerMethod&gt;&gt; registryMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Method[] methods = obj.getClass().getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getParameterCount() != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Subscribe annotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; pararm = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                addMap(pararm, createHandlerMethod(obj, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ObserverHandlerMethod&gt; <span class="title">getHandlerMethods</span><span class="params">(Class&lt;?&gt; obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registryMap.get(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ObserverHandlerMethod <span class="title">createHandlerMethod</span><span class="params">(Object obj, Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObserverHandlerMethod(obj.getClass().getName(), method.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addMap</span><span class="params">(Class&lt;?&gt; param, ObserverHandlerMethod method)</span> </span>&#123;</span><br><span class="line">        List&lt;ObserverHandlerMethod&gt; methods = registryMap.getOrDefault(param, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        methods.add(method);</span><br><span class="line">        registryMap.put(param, methods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ObserverRegistry registry = <span class="keyword">new</span> ObserverRegistry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        registry.register(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        List&lt;ObserverHandlerMethod&gt; handlerMethods = registry.getHandlerMethods(obj.getClass());</span><br><span class="line">        <span class="keyword">for</span> (ObserverHandlerMethod handlerMethod : handlerMethods) &#123;</span><br><span class="line">            executor.execute(() -&gt; handlerMethod.invokeMethod(obj));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncEventBus</span> <span class="keyword">extends</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncEventBus</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的代码实现过程中，ObserverHandlerMethod其实可以进行优化，不需要保存类名和方法名的字符串，直接保存类的实例对象，方法句柄即可。可以简化代码。懒得改了….</p>
]]></content>
      <categories>
        <category>Java设计模式之行为型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-享元模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解结构型模式中的享元模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>享元就是被共享的单元，享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p>
<h2 id="二、原理与实现"><a href="#二、原理与实现" class="headerlink" title="二、原理与实现"></a>二、原理与实现</h2><p>当在一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元</p>
<h2 id="三、场景案例"><a href="#三、场景案例" class="headerlink" title="三、场景案例"></a>三、场景案例</h2><h3 id="棋牌游戏"><a href="#棋牌游戏" class="headerlink" title="棋牌游戏"></a>棋牌游戏</h3><p>一个游戏厅有成千上外的棋牌室，每个棋牌室对应一个棋局，棋局要保存每个棋子的数据，比如：棋子类型、棋子颜色、棋子的位置等。利用这些数据，我们就能显式一个完整的棋盘给玩家。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPiece</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionY;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessPiece</span><span class="params">(<span class="keyword">int</span> id, String text, Color color, <span class="keyword">int</span> positionX, <span class="keyword">int</span> positionY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.positionX = positionX;</span><br><span class="line">        <span class="keyword">this</span>.positionY = positionY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">        RED, BLACK,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChessBoard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> ChessPiece(<span class="number">1</span>, <span class="string">&quot;马&quot;</span>, ChessPiece.Color.BLACK, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        chessPieces.put(<span class="number">2</span>, <span class="keyword">new</span> ChessPiece(<span class="number">1</span>, <span class="string">&quot;马&quot;</span>, ChessPiece.Color.RED, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的数据结构可以表示一个棋牌室的布局，但是一个游戏厅有成千上万个棋牌室，那么保存这么多棋局对象就会消耗大量的内存，所以通过将相似对象id、text、color设计成享元模式来复用对象，以达到节省内存的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 享元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> ChessPiece.Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessPieceUnit</span><span class="params">(<span class="keyword">int</span> id, String text, ChessPiece.Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnitFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChessPieceUnit <span class="title">getChessPieceUnit</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pieces.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在传统的设计中1万个棋局需要32万个棋子对象，通过上述复用享元对象，只需要32个棋子即可，大大节省了内存的消耗。</p>
<h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>假设文本编辑器只实现了文本编辑功能，不包含图片、表格等复杂的编辑功能，我们要在内存中表示一个文本文件，只需要记录文字和格式即可。我们把每个文字当作一个对象来看待，并且在其中包含它的格式信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">private</span> Font font;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> colorRGB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Character</span><span class="params">(<span class="keyword">char</span> a, Font font, <span class="keyword">int</span> size, <span class="keyword">int</span> colorRGB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.font = font;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.colorRGB = colorRGB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Character&gt; chars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendCharacter</span><span class="params">(<span class="keyword">char</span> c, Font font, <span class="keyword">int</span> size, <span class="keyword">int</span> colorRGB)</span> </span>&#123;</span><br><span class="line">        Character character = <span class="keyword">new</span> Character(c, font, size, colorRGB);</span><br><span class="line">        chars.add(character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的代码中，每有一个文字，我们就会创建一个对象，如果一个文本中有几十万文字，那我们就要在内存中存储这么多Character对象，如果节省内存中。</p>
<p>实际上，在一个文本文件中，用到的字体格式并不会太多，所以对于字体格式来说，我们可以将其设计为享元，让不同的文字共享使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 享元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FontStyle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Font font;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> colorRGB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FontStyle</span><span class="params">(Font font, <span class="keyword">int</span> size, <span class="keyword">int</span> colorRGB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.font = font;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.colorRGB = colorRGB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FontStyleFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;FontStyle&gt; styles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FontStyle <span class="title">getStyle</span><span class="params">(Font font, <span class="keyword">int</span> size, <span class="keyword">int</span> colorRGB)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">private</span> FontStyle style;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Character</span><span class="params">(<span class="keyword">char</span> a, FontStyle style)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.FontStyle = style;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Character&gt; chars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendCharacter</span><span class="params">(<span class="keyword">char</span> c, Font font, <span class="keyword">int</span> size, <span class="keyword">int</span> colorRGB)</span> </span>&#123;</span><br><span class="line">        Character character = <span class="keyword">new</span> Character(c, FontStyleFactory.getStyle(font,size,colorRGB));</span><br><span class="line">        chars.add(character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Integer和String"><a href="#Integer和String" class="headerlink" title="Integer和String"></a>Integer和String</h3><p>Java中的-128到127的int值对应的Integer是一样的，因为有IntegerCache，它也可以看作是享元对象。</p>
<p>String的字面量在运行的时候也会存储到字符串常量池中。</p>
]]></content>
      <categories>
        <category>Java设计模式之结构型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-组合模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解结构型模式中的组合模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>组合模式和面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事，这里将的组合模式，主要是用来处理树形结构数据。</p>
<p>将一组对象组织成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端可以统一单个对象和组合对象的处理逻辑。</p>
<h2 id="二、场景"><a href="#二、场景" class="headerlink" title="二、场景"></a>二、场景</h2><h3 id="文件目录树结构"><a href="#文件目录树结构" class="headerlink" title="文件目录树结构"></a>文件目录树结构</h3><p>需求</p>
<ul>
<li>  动态的添加、删除某个目录下的子目录文件</li>
<li>  统计目录下文件的个数</li>
<li>  统计目录下文件的总大小</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemNode</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">countFileCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">countFileSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">FileSystemNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countFileCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countFileSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        java.io.File file = <span class="keyword">new</span> java.io.File(path);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> file.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">FileSystemNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;FileSystemNode&gt; subNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countFileCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileSystemNode subNode : subNodes) &#123;</span><br><span class="line">            count += subNode.countFileCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countFileSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileSystemNode subNode : subNodes) &#123;</span><br><span class="line">            size += subNode.countFileSize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(FileSystemNode node)</span> </span>&#123;</span><br><span class="line">        subNodes.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSubNode</span><span class="params">(FileSystemNode node)</span> </span>&#123;</span><br><span class="line">        subNodes.removeIf(next -&gt; next.path.equals(node.getPath()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Directory fileSystemTree = <span class="keyword">new</span> Directory(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        Directory node_dire1 = <span class="keyword">new</span> Directory(<span class="string">&quot;/node_dire1&quot;</span>);</span><br><span class="line">        Directory node_dire2 = <span class="keyword">new</span> Directory(<span class="string">&quot;/node_dire2&quot;</span>);</span><br><span class="line">        File node_file = <span class="keyword">new</span> File(<span class="string">&quot;/test.txt&quot;</span>);</span><br><span class="line">        fileSystemTree.addSubNode(node_dire1);</span><br><span class="line">        fileSystemTree.addSubNode(node_dire2);</span><br><span class="line">        fileSystemTree.addSubNode(node_file);</span><br><span class="line"></span><br><span class="line">        Directory node_dire1_a = <span class="keyword">new</span> Directory(<span class="string">&quot;/node_dire1/a&quot;</span>);</span><br><span class="line">        Directory node_dire1_b = <span class="keyword">new</span> Directory(<span class="string">&quot;/node_dire1/b&quot;</span>);</span><br><span class="line">        File node_dire1_file = <span class="keyword">new</span> File(<span class="string">&quot;/node_dire1/d.txt&quot;</span>);</span><br><span class="line">        node_dire1.addSubNode(node_dire1_a);</span><br><span class="line">        node_dire1.addSubNode(node_dire1_b);</span><br><span class="line">        node_dire1.addSubNode(node_dire1_file);</span><br><span class="line"></span><br><span class="line">        System.out.println(fileSystemTree.countFileCount());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="公司的人员架构图"><a href="#公司的人员架构图" class="headerlink" title="公司的人员架构图"></a>公司的人员架构图</h3><p>需求</p>
<ul>
<li>  动态的添加、删除部门</li>
<li>  统计部门下的人员个数</li>
<li>  统计部门下人员的总薪资</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HumanResource</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">calculateSalary</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">HumanResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">HumanResource</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;HumanResource&gt; subNode = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (HumanResource humanResource : subNode) &#123;</span><br><span class="line">            count += humanResource.calculateSalary();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.salary = count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(HumanResource node)</span> </span>&#123;</span><br><span class="line">        subNode.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ROOT_ID = <span class="number">1001</span>;</span><br><span class="line">    <span class="keyword">private</span> DepartmentDao departmentDao;</span><br><span class="line">    <span class="keyword">private</span> EmployeeDao employeeDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildOrganization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Department rootDepartment = <span class="keyword">new</span> Department(ROOT_ID);</span><br><span class="line">        buildOrganization(rootDepartment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildOrganization</span><span class="params">(Department department)</span> </span>&#123;</span><br><span class="line">        List&lt;Long&gt; subIds = departmentDao.getSubDepartmentIds(department.getId());</span><br><span class="line">        <span class="keyword">for</span> (Long subId : subIds) &#123;</span><br><span class="line">            Department tmp = <span class="keyword">new</span> Department(subId);</span><br><span class="line">            department.addSubNode(tmp);</span><br><span class="line">            buildOrganization(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Long&gt; employeeIds = employeeDao.getDepartmentEmployeeIds(department.getId());</span><br><span class="line">        <span class="keyword">for</span> (Long employeeId : employeeIds) &#123;</span><br><span class="line">            <span class="keyword">double</span> salary = employeeDao.getEmployeeSalary(employeeId);</span><br><span class="line">            Employee employee = <span class="keyword">new</span> Employee(employeeId, salary);</span><br><span class="line">            department.addSubNode(employee);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java设计模式之结构型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-门面模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解结构型模式中的门面模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>门面模式（也叫外观模式）为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p>
<h2 id="二、场景"><a href="#二、场景" class="headerlink" title="二、场景"></a>二、场景</h2><p>当我们接口粒度设计的过大时（比如一个接口中干了N件事），那么这个接口的复用性就会变差；当我们接口粒度设计的过小时，那么这个接口的易用性就会不好，所以通过门面模式，包裹多个粒度小的接口来使接口的复用性和易用性达到一个微妙的平衡。</p>
<ul>
<li><p>解决易用性问题</p>
<p>  门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如：Linux系统调用函数就可以看作一种门面。</p>
</li>
<li><p>解决性能问题</p>
<p>  将接口的多次调用，封装为一次调用，减少网络通信的时间来提高性能。</p>
</li>
<li><p>解决分布式事务问题</p>
<p>  将两个SQL放在一个接口中，并通过Spring提供的事务机制来保证事务的一致性。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java设计模式之结构型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-适配模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E9%80%82%E9%85%8D%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文给大家讲解结构型模式中的适配器模式，以及其常见的使用场景。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。比如USB转接头。</p>
<h2 id="二、结构图"><a href="#二、结构图" class="headerlink" title="二、结构图"></a>二、结构图</h2><p><img src="/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E9%80%82%E9%85%8D%E6%A8%A1%E5%BC%8F/image-20220822090643057.png" alt="image-20220822090643057"></p>
<p>在适配器中的角色有：</p>
<ul>
<li>  标准的接口定义(ITarget)：表示对外提供的标准接口</li>
<li>  不兼容ITarget接口类(Adaptee)：不兼容ITarget</li>
<li>  适配器类(Adaptor)：适配ITarget和Adaptee</li>
</ul>
<h2 id="三、-代码示例"><a href="#三、-代码示例" class="headerlink" title="三、                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             代码示例"></a>三、                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             代码示例</h2><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>标准接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不兼容类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method3 invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适配器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> <span class="keyword">implements</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adaptor</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述类适配器和对象适配器的区别在于，类适配器采用继承的结构，对象适配器采用组合的方法来实现。</p>
<p>针对上述的两种实现方式，到底该如何选择使用哪一个？</p>
<ul>
<li>  如果Adaptee中的方法不多，那两种方式都可以</li>
<li>  如果Adaptee中的方法很多，但是大部分不需要做兼容，可以采用类适配器，因为继承的方式可以省略一些代码的编写</li>
<li>  如果Adaptee中的方法很多，而且大部分都需要做适配，则可以采用对象适配器，因为组合结构相对于继承来说更加灵活。</li>
</ul>
<h2 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h2><h3 id="封装有缺陷的接口"><a href="#封装有缺陷的接口" class="headerlink" title="封装有缺陷的接口"></a>封装有缺陷的接口</h3><p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量的静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以用适配器模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来自外部sdk，无权修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CD</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器模式进行重构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITarget</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDAdaptor</span> <span class="keyword">extends</span> <span class="title">CD</span> <span class="keyword">implements</span> <span class="title">ITarget</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="统一多个类的接口设计"><a href="#统一多个类的接口设计" class="headerlink" title="统一多个类的接口设计"></a>统一多个类的接口设计</h3><p>某个功能实现依赖多个外部系统，通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter1</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter2</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter3</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未使用适配器模式之前的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo</span></span>&#123;</span><br><span class="line">    Filter1 filter1 = <span class="keyword">new</span> Filter1();</span><br><span class="line">    Filter1 filter2 = <span class="keyword">new</span> Filter2();</span><br><span class="line">    Filter1 filter3 = <span class="keyword">new</span> Filter3();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">filter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterA</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Filter1 filter1 = <span class="keyword">new</span> Filter1();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">filter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo</span></span>&#123;</span><br><span class="line">    List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Filter filter : filters)&#123;</span><br><span class="line">            filter.filter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="替换依赖的外部系统"><a href="#替换依赖的外部系统" class="headerlink" title="替换依赖的外部系统"></a>替换依赖的外部系统</h3><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fa</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略IA的实现类A</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IA a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(IA a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo(<span class="keyword">new</span> A());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将外部系统A替换为B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BAdaptor</span> <span class="title">implement</span> <span class="title">IA</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BAdaptor</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	b.fb();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Demo d = <span class="keyword">new</span> Demo(<span class="keyword">new</span> BAdaptor(<span class="keyword">new</span> B()));</span><br></pre></td></tr></table></figure>

<h3 id="兼容老版本接口"><a href="#兼容老版本接口" class="headerlink" title="兼容老版本接口"></a>兼容老版本接口</h3><p>在做版本升级的时候，对于一些废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。</p>
<h3 id="适配不同格式的数据"><a href="#适配不同格式的数据" class="headerlink" title="适配不同格式的数据"></a>适配不同格式的数据</h3><p>Java中Arrays.asList()可以看作是一种数据适配器，将数组类型的数据转化为集合容器类型。</p>
]]></content>
      <categories>
        <category>Java设计模式之结构型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-装饰器模式</title>
    <url>/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文通过JDK的IO流的数据结构来讲解装饰器模式</p>
</blockquote>
<span id="more"></span>

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。他的主要作用是对原始类添加增强功能，这也是判断是否该用装饰器模式的一个重要依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器，为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p>
<h2 id="二、结构图"><a href="#二、结构图" class="headerlink" title="二、结构图"></a>二、结构图</h2><p><img src="/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20220822081344070.png" alt="image-20220822081344070"></p>
<p>在装饰器模式中的角色有：</p>
<ul>
<li>  <strong>抽象构件(InputStream)角色：</strong>给出一个抽象接口，已规范准备接收附加责任的对象。</li>
<li>  <strong>具体构件(FileInputStream)角色：</strong>定义一个将要接收附加责任的类</li>
<li>  <strong>装饰(FilterInputStream)角色：</strong>持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。</li>
<li>  <strong>具体装饰(BufferedInputStream、DataInputStream)角色：</strong>负责给构件对象“贴上”附加的责任。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>抽象构件角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserLogin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体构件角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginImpl</span> <span class="keyword">implements</span> <span class="title">UserLogin</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装饰角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginDecorate</span> <span class="keyword">implements</span> <span class="title">UserLogin</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserLogin userLogin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserLoginDecorate</span><span class="params">(UserLogin userLogin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userLogin = userLogin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userLogin.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体装饰角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateUserLoginDecorate</span> <span class="keyword">extends</span> <span class="title">UserLoginDecorate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidateUserLoginDecorate</span><span class="params">(UserLogin userLogin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(userLogin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对登录的用户进行权限校验、账号密码校验等&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    UserLogin userLogin = <span class="keyword">new</span> UserLoginImpl();</span><br><span class="line">    UserLogin userLogin1 = <span class="keyword">new</span> ValidateUserLoginDecorate(userLogin);</span><br><span class="line">    userLogin1.login();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">对登录的用户进行权限校验、账号密码校验等</span><br><span class="line">登录成功</span><br></pre></td></tr></table></figure>

<p>大家可能会好奇为什么装饰器也需要分为父类和子类，而不是直接定义一个装饰器类继承自抽象构建即可。其实这样的原因是为了代码的简化，我们以InputStream来举例，假如没有FilterInputStream这个父类装饰器，而是直接BufferedInputStream继承自InputStream，那么BufferedInputStream需要重写InputStream的所有方法，简单包裹对inputStream对象的函数调用，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span></span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.in  = in;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// f()函数不需要增强，只是重新调用一下in对象的f()</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">       in.f();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如此时抽象构件还有其他的装饰器，那么这些装饰类中不需要增强的方法也全部都要按照上面的方法进行简单包裹，这样的后果就是有大量的代码重复，所给所有的装饰器类增加一个共同的父类，将这部分代码在父类中进行简单包裹即可。</p>
]]></content>
      <categories>
        <category>Java设计模式之结构型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系列---Java虚拟机</title>
    <url>/2022/08/13/Java%E7%B3%BB%E5%88%97-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<blockquote>
<p>对于Java程序员来说，虚拟机是一个熟悉且陌生的词汇，熟悉是因为我们天天在用它，而陌生是我们对它的了解比较少。</p>
<p>Java虚拟机是实现Java语言平台无关性的关键。它帮我们屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>
<p>并且Java虚拟机提供了自动内存管理机制，我们无需像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>
</blockquote>
<h2 id="一、Java内存模型"><a href="#一、Java内存模型" class="headerlink" title="一、Java内存模型"></a>一、Java内存模型</h2><h3 id="1-1-运行时数据区域"><a href="#1-1-运行时数据区域" class="headerlink" title="1.1 运行时数据区域"></a>1.1 运行时数据区域</h3><p><img src="/2022/08/13/Java%E7%B3%BB%E5%88%97-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230416124511371.png" alt="image-20230416124511371"></p>
<p>线程私有：</p>
<ul>
<li><p>程序计数器</p>
<p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p>
</li>
<li><p>Java虚拟机栈</p>
<p>Java虚拟机栈描述的是Java方法执行的线程内存模型：每个方法执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接和方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。当虚拟机栈扩展无法申请到更多的内存时，就会OOM，当虚拟机中栈深度大于虚拟机允许的最大深度时，会StackOverflow。</p>
</li>
<li><p>本地方法栈</p>
<p>本地方法栈和Java虚拟机栈所发挥的作用非常相似，其区别只是Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的本地方法服务。同样本地方法栈也会在栈深度溢出或者栈扩展失败时抛出StackOverflow和OOM异常。</p>
</li>
</ul>
<p>线程共享：</p>
<ul>
<li><p>堆</p>
<p>Java堆内存是虚拟机所管理的内存中最大的一块，是被所有线程共享的一块区域，此内存区域的唯一目的就是存放对象实例。Java堆是GC收集器管理的内存区域。通过-Xms和-Xmx来使用初始堆大小和最大的堆大小。如果在Java堆中没有内存完成实例分配，并且堆也无法在扩展时，Java虚拟机将会抛出OOM的异常。</p>
</li>
<li><p>方法区（元空间）</p>
<p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类型信息、常量、静态变量和即时编译后的代码缓存等数据。根据Java虚拟机规范的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p>
</li>
<li><p>直接内存</p>
<p>直接内存并不是Java虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁的使用到，而且也有可能导致OOM异常。在JDK1.4中新加入的NIO类，引入了一种基于通道与缓冲区的I/O方式，可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。在一些场景中提高性能，避免了在Java堆和Native堆中来回复制数据。直接内存不会受到Java堆大小的限制，但是既然是内存，肯定会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OOM异常。</p>
</li>
</ul>
<h3 id="1-2-对象创建和定位"><a href="#1-2-对象创建和定位" class="headerlink" title="1.2 对象创建和定位"></a>1.2 对象创建和定位</h3><p>对象创建过程：</p>
<ul>
<li>当Java虚拟机遇到一条new字节码指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化，如果没有，则必须先执行相应的类加载过程。</li>
<li>在类加载检查通过后，虚拟机将为新生对象分配内存，Java虚拟机为对象分配内存有两种方式：<strong>指针碰撞、空闲列表</strong>。指针碰撞指的是Java堆中已用区域和空闲区域时分开的，中间用一个指针来分界，在分配内存的时候，仅需要向空闲区域移动对象大小的距离即可。空闲列表则是虚拟机维护一个列表，用来记录哪些内存块是可用的，哪些是已用的，分配对象内存时，从可用的区域中找到一块足够大的空间划分给对象实例。</li>
<li>对象创建时一个十分频繁的行为，所以如果多个线程同时创建对象需要进行同步处理，或者采用<strong>TLAB</strong>方式（本地线程分配缓冲Thread Local Allocation Buffer），即哪个线程要分配内存，就在哪个线程的本地缓冲区中分配。</li>
<li>给对象分配完内存空间后，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头中。</li>
<li>对象产生后，然后调用对象的构造函数，即class文件中的init方法。</li>
<li>将引用指向对象的内存起始地址</li>
</ul>
<p>对象布局：</p>
<ul>
<li>对象头：对象头包含两个部分，第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；第二类是类型指针，即对象指向它的类型元数据的指针。Java虚拟机通过这个指针来确定对象是哪个类的实例。如果对象是数组，在对象头中还必须有一块用于记录数组长度的数据。</li>
<li>实例数据：示例数据是对象真正存储的有效信息，即我们在代码里面所定义的各种类型的字段内容，无论是从父类继承的，还是子类中定义的字段。Java虚拟机默认的分配顺序是相同宽度的字段放在一起，在这个前提下，父类中定义的字段会出现在子类之前。</li>
<li>对齐填充：Java虚拟机规范要求对象的起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。所以需要通过对齐填充来补全</li>
</ul>
<p>对象定位：</p>
<ul>
<li><p>句柄访问</p>
<p>句柄访问就是在Java堆中维护一个句柄池，栈上的Reference数据只需要存储对象的句柄地址即可。而句柄中包含了对象实例数据与类型元数据的地址信息。这种方式的缺点是需要定位两次才可以访问对象，优点是对象的移动不需要修改Reference的存储内容，仅需要修改句柄中存储的地址。</p>
</li>
<li><p>直接指针访问</p>
<p>Reference直接存储对象的地址，这种方式的优点就是访问对象速度快，比第一种方式少了一次指针定位的时间开销。缺点就是Java对象的内存布局需要考虑如何放置访问类型元数据的相关信息。HotSpot虚拟机采用第二种方式进行对象访问。</p>
</li>
</ul>
<h3 id="1-3-OOM异常"><a href="#1-3-OOM异常" class="headerlink" title="1.3 OOM异常"></a>1.3 OOM异常</h3><ul>
<li><p>Java堆异常</p>
<p>Java堆中存储对象的实例，所以我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后，就会产生OOM异常，详情请看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// VM Args : -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaHeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; arrays = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建对象个数:&quot;</span> + ++i);</span><br><span class="line">            arrays.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">创建对象个数:<span class="number">810326</span></span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid9044.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">28945836</span> bytes in <span class="number">0.079</span> secs]</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure></li>
<li><p>Java虚拟机栈和本地方法栈异常</p>
<ul>
<li><p>线程请求的栈深度大于虚拟机允许的最大栈深度，抛出StackOverflow异常（其实Java虚拟机并没有规定最大的栈深度，这里抛出异常仅仅是因为超过了Java虚拟机栈的容量而已）</p>
</li>
<li><p>如果虚拟机栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，抛出OOM异常</p>
</li>
</ul>
<p>在HotSpot虚拟机中，不支持虚拟机栈的动态扩展，所以除非在<strong>创建线程申请内存时就因无法获得足够内存而出现OOM异常</strong>，否则在线程运行过程时不会出现因为扩展而导致的OOM异常。</p>
<p>在线程运行的过程中，有两种情况会抛出StackOverflow异常，一种是栈深度过深（方法递归调用太多），第二种是栈帧很大，导致栈容量无法容纳栈帧。这两种异常其实本质是相同的，都是由于Java虚拟机栈的容量不够导致的。</p>
</li>
<li><p>方法区和本地内存异常</p>
<p>使用CGLIB在运行时直接生成动态代理类，将方法区打满。</p>
<p>通过Unsafe类的AllocateMemory可以申请本地直接内存。</p>
</li>
</ul>
<h2 id="二、类文件结构"><a href="#二、类文件结构" class="headerlink" title="二、类文件结构"></a>二、类文件结构</h2><h3 id="2-1-Class文件结构格式"><a href="#2-1-Class文件结构格式" class="headerlink" title="2.1 Class文件结构格式"></a>2.1 Class文件结构格式</h3><p>Class文件是一组以字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有任何的分隔符。当遇到需要占用单个字节以上空间的数据项时，则会按照高位在前（大端存储）的方式分割成若干字节进行存储。</p>
<p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。</p>
<ul>
<li>  无符号数：基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节的无符号数。</li>
<li>  表是由多个无符号数或者其他表作为数据项构成的复合数据类型。所有表的命名都习惯性地以_info结尾。</li>
</ul>
<p><img src="/2022/08/13/Java%E7%B3%BB%E5%88%97-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230416131808068.png" alt="image-20230416131808068"></p>
<p>如上图所示，整个 Class 文件 按如下排列：<strong>魔数(4) – 次版本号(2) – 主版本号(2) – 常量池常量数(2) – 常量池表(不确定长度) – 访问标志(2) – 类索引(2) – 父类索引(2) – 实现的接口数(2) – 实现的接口集合(2) – 实现的字段数(2) – 字段集合表(不确定长度) – 方法数(2) – 方法集合表(不确定长度) – 属性数(2) – 属性集合表(不确定长度)。</strong></p>
<h3 id="2-2-具体组成部分"><a href="#2-2-具体组成部分" class="headerlink" title="2.2 具体组成部分"></a>2.2 具体组成部分</h3><ul>
<li><p>魔数</p>
<p>每个Class文件的头4个字节被称为魔数，0xCAFEBABE，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p>
</li>
<li><p>版本号</p>
<p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。 Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
</li>
<li><p>常量池</p>
<p>常量池是Class文件里的资源仓库，常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（从1开始，如果计数值为22，代表常量索引从1~21），常量池0空出来是表示如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。</p>
<p>常量池中主要存放两大类常量：<code>字面量（Literal）和符号引用（Symbolic References）</code>，字面量比较接近于Java语言层面的常量概念，如文本字符串、 声明为final的常量值等。 而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>  类和接口的全限定名</li>
<li>  字段的名称和描述符</li>
<li>  方法的名称和描述符</li>
</ul>
</li>
<li><p>访问标志</p>
<p>常量池结束后，紧接着的2个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为Public类型；是否定义为Abstract类型；如果是类的话，是否被声明为final。</p>
</li>
<li><p>类索引、父类索引、接口集合</p>
<p>类索引用于确定这个类的全限定名（指向一个常量池中一个表项），父类索引用于确定这个类的父类的全限定名。接口集合用于描述这个类实现了哪些接口。</p>
</li>
<li><p>字段表集合</p>
<p>Class文件中的集合全部都由一个计数值 + 数据构成的，字段表用于描述接口或者类中声明的变量，字段表最后跟随着一个属性表集合，用于存储一些额外的信息（比如常量的值）</p>
</li>
<li><p>方法表集合</p>
<p>用来描述接口或者类中的方法的，方法表的最后也跟随着一个属性表集合，用来存储每个方法的信息。</p>
</li>
<li><p>属性表集合</p>
<p>Class文件、字段表、方法表都可以携带自己的属性表集合。</p>
<ul>
<li>  Code属性：存储该方法的字节码指令</li>
<li>  Exceptions属性：和Code属性平级的一项属性，该属性的作用是列举出方法中可能抛出的受查异常。</li>
<li>  LineNumberTable属性：字节码行号和源码行号的对应关系</li>
<li>  LocalVariableTable属性：局部变量表与Java源码中定义的变量之间的关系</li>
<li>  …</li>
</ul>
</li>
</ul>
<h3 id="2-3-常用字节码指令"><a href="#2-3-常用字节码指令" class="headerlink" title="2.3 常用字节码指令"></a>2.3 常用字节码指令</h3><ul>
<li><p>加载和存储指令</p>
<ul>
<li><p>  将一个局部变量加载到操作数栈：iload、iload_<n>、lload、aload…..</p>
</li>
<li><p>  将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、astore……</p>
</li>
<li><p>  将一个常量加载到操作数栈：iconst、iconst_<n>、ldc、bipush、sipush</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>运算指令<ul>
<li>  iadd、isub、imul、idiv…..</li>
</ul>
</li>
</ul>
<ul>
<li>类型转换<ul>
<li>  i2b、i2c、i2s….</li>
</ul>
</li>
</ul>
<ul>
<li><p>创建对象和访问指令</p>
<ul>
<li><p>  创建类实例的指令：new</p>
</li>
<li><p>  创建数组的指令：newarray</p>
</li>
<li><p>  访问类字段和实例字段：getfield、getstatic、putfield、putstatic</p>
</li>
<li><p>  把一个数组元素加载到操作数栈的指令：iaload、laload</p>
</li>
<li><p>  将一个操作数栈的值存储到数组元素中的指令：iastore、lastore….</p>
</li>
<li><p>  取数组长度的指令：arraylength</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>操作数栈管理指令</p>
<ul>
<li><p>  出栈：pop、pop2</p>
</li>
<li><p>  复制栈顶元素并重新压入栈：dup、dup2</p>
</li>
<li><p>  交换栈顶两个数值：swap</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>控制转移指令<ul>
<li>  ifeq、ifgt、iflt、goto、</li>
</ul>
</li>
</ul>
<ul>
<li><p>方法调用和返回指令</p>
<ul>
<li><p>  invokevirtual：调用对象的实例方法</p>
</li>
<li><p>  invokeinterface：调用接口方法</p>
</li>
<li><p>  invokespecial：调用私有方法、父类方法、实例初始化方法（构造函数）</p>
</li>
<li><p>  invokestatic：调用静态方法</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>异常处理指令<ul>
<li>  throw</li>
</ul>
</li>
</ul>
<ul>
<li><p>同步指令</p>
<ul>
<li><p>  monitorenter</p>
</li>
<li><p>  monitorexit</p>
</li>
</ul>
</li>
</ul>
<h2 id="三、类加载过程"><a href="#三、类加载过程" class="headerlink" title="三、类加载过程"></a>三、类加载过程</h2><p>类从加载至虚拟机内存 开始到 卸载出内存，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，加载后的三个阶段可以统称为连接（Linking）。</p>
<h3 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h3><p>类加载过程的第一步，主要进行下面几个步骤：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流。</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li>
</ol>
<h3 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<ul>
<li>文件格式验证：</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<p><img src="/2022/08/13/Java%E7%B3%BB%E5%88%97-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230414091338577.png" alt="image-20230414091338577"></p>
<h3 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h3><p><strong>准备阶段主要是给静态变量和常量分配内存并赋初始值。</strong></p>
<p><img src="/2022/08/13/Java%E7%B3%BB%E5%88%97-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230414091600975.png" alt="image-20230414091600975"></p>
<h3 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h3><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p>
<h3 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h3><p>初始化阶段主要执行类中的<Clinit>方法，是类加载的最后一步</p>
<blockquote>
<p><Clinit>方法是编译之后自动生成的。并且Java虚拟机会保证其在多线程环境下的安全性（加锁，所以多线程下进行类的初始化有可能会阻塞线程）</p>
</blockquote>
<p>类初始化的几个触发时机</p>
<ul>
<li>遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有初始化，必须先对类进行初始化（实例化对象、读取类的静态变量、修改类的静态变量、调用类的静态方法）</li>
<li>对类进行反射调用时，如果类未初始化，需要先进行初始化</li>
<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>
<li>入口函数Main所在的类会在Java虚拟机启动时被初始化</li>
<li>一个接口中存在默认方法时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ul>
<h3 id="2-6-类卸载"><a href="#2-6-类卸载" class="headerlink" title="2.6 类卸载"></a>2.6 类卸载</h3><p>类卸载指的是Class对象被GC回收</p>
<p>GC回收Class对象的3个要求：</p>
<ul>
<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象</li>
<li>该类的类加载器的实例已被 GC</li>
<li>该类没有在其他任何地方被引用，即无法通过反射调用类的方法</li>
</ul>
<p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<h2 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h2><h3 id="4-1-对象是否存活算法"><a href="#4-1-对象是否存活算法" class="headerlink" title="4.1 对象是否存活算法"></a>4.1 对象是否存活算法</h3><ul>
<li>  引用计数法</li>
<li>可达性分析算法<ul>
<li>GC ROOTS<ol>
<li>  虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>  方法区中的类静态属性引用的对象，常量引用的对象</li>
<li>  本地方法栈中JNI引用的对象</li>
<li>  Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException，OutOfMemoryError等）还有系统类加载器。</li>
<li>  被同步锁持有的对象</li>
<li>  反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
</li>
<li>引用类型<ul>
<li>  强引用：程序代码中普遍存在的引用赋值，只要强引用关系存在，垃圾收集器就不会回收掉被引用的对象</li>
<li>  软引用：描述一些还有用，但非必须的对象，被软引用关联的对象，在发生内存异常前，会把这些对象列进回收范围内进行二次回收，如果这次回收还没有足够的内存，才会排除内存溢出异常。</li>
<li>  弱引用：被弱引用关联的对象只能生存到下次垃圾收集发生为止。</li>
<li>  虚引用：是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取对象实例，为一个对象设置虚引用关联的唯一目的就是为了能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-对象自救"><a href="#4-2-对象自救" class="headerlink" title="4.2 对象自救"></a>4.2 对象自救</h3><p>​        对象在被标记为不存活之后，还可以有一次自救的机会。Java虚拟机会看该对象是否实现了finalize()方法，如果实现了这个方法，虚拟机会将该对象加入队列中，等待执行，在finalize方法中，如果对象可以和引用链上的任一一个对象建立起引用关系，即自救成功。另外，虚拟机会触发对象的finalize方法，但是并不保证一定会等方法执行完，这样做的原因是，如果某个对象的finalize方法执行缓慢，将导致队列中的其他对象永久处于等待，甚至导致内存回收子系统的崩溃。</p>
<h3 id="4-3-方法区回收"><a href="#4-3-方法区回收" class="headerlink" title="4.3 方法区回收"></a>4.3 方法区回收</h3><ul>
<li>类对象回收的条件<ul>
<li>  类的所有实例被回收</li>
<li>  类的加载器被回收</li>
<li>  类的Class对象在任何地方没有被引用</li>
</ul>
</li>
</ul>
<h3 id="4-4-垃圾收集算法"><a href="#4-4-垃圾收集算法" class="headerlink" title="4.4 垃圾收集算法"></a>4.4 垃圾收集算法</h3><p>分代收集理论：</p>
<pre><code> 1. 弱分代假说：绝大多数对象都是朝生夕灭的
 2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
 3. 跨代引用假说：跨代引用相对于同代引用来说仅占少数
</code></pre>
<ul>
<li><p>标记-清除算法（CMS使用的算法）</p>
<p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<ul>
<li>效率问题</li>
<li>内存碎片问题</li>
</ul>
<img src="image-20230416133731064.png" alt="image-20230416133731064" style="zoom:67%;" /></li>
<li><p>标记-复制算法（Serial、ParNew、Parallel Scavenge新生代收集器）</p>
<p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<img src="image-20230416133748841.png" alt="image-20230416133748841" style="zoom:67%;" /></li>
<li><p>标记-整理算法（Serial Old，Parallel Old、G1、Shenandoah等收集器采用此算法）</p>
<p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<img src="image-20230416133959914.png" alt="image-20230416133959914" style="zoom:67%;" /></li>
</ul>
<h3 id="4-5-垃圾收集器"><a href="#4-5-垃圾收集器" class="headerlink" title="4.5 垃圾收集器"></a>4.5 垃圾收集器</h3><h4 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h4><ul>
<li>  Serial收集器</li>
</ul>
<p>Serial收集器是单线程模型，运行在客户端模式的Java虚拟机中，是新生代的收集器，和Serial Old配合使用。Serial采用标记复制算法。</p>
<ul>
<li>  ParNew收集器</li>
</ul>
<p>ParNew是多线程的垃圾收集器，是CMS的默认新生代收集器(JDK 5推出了CMS收集器)。ParNew收集器采用标记复制算法。</p>
<ul>
<li>  Parallel Scavenge收集器</li>
</ul>
<p>也是多线程的垃圾收集器，同样是基于标记-复制算法。目标是提高吞吐量。(吞吐量是处理器用于运行用户代码的时间与处理器总消耗时间的比值)，在JDK 6之前和Serial Old配合来使用，但是Serial Old由于是单线程的，导致效果不太好，对不起Parallel Scavenge的名字，直到Parallel Old的出现，它是一个多线程的老年代收集器。</p>
<h4 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h4><ul>
<li><p>Serial Old收集器</p>
<p>Serial Old是Serial收集器的老年代版本，同样是一个单线程收集器，采用标记-整理算法。</p>
</li>
<li><p>Parallel Old收集器</p>
<p>Parallel Old收集器是Parallel Scavenge的老年代版本，支持多线程收集，基于标记-整理算法，JDK 6才提供。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>
</li>
<li><p>CMS收集器（Concurrent Mark Sweep）</p>
<ul>
<li><p>  CMS收集器是一种以获取最短停顿时间为目标的老年代收集器，采用标记-清除算法。</p>
</li>
<li><p>  由于CMS和用户线程是并发执行的，所以垃圾回收时需要预留一部分内存空闲给用户线程使用，当预留的内存空间不足时，会发生Concurrent Mode Failure，此时虚拟机会临时启用Serial Old收集器来进行老年代的垃圾回收。</p>
</li>
<li><p>  另外CMS由于采用的是标记-清除算法， 会造成大量的空间碎片，可能出现老年代还有很多剩余空间，但是无法找到足够大的连续空间来分配当前对象，而不得不提前出发一次FULL GC。所以CMS为了解决这个问题，CMS收集器提供了一个开关参数，用于FULL GC时开启内存碎片的整理工作（标记-整理算法）。但是由于整理空间碎片需要移动存活对象，需要暂停用户线程，所以会增加停顿时间，所以CMS又提供了另一个参数，用来设置在进行几次Full GC后，下一次Full GC开启内存碎片整理（默认为0，即每次Full GC都进行碎片整理）。</p>
</li>
<li><p>CMS收集器的步骤：</p>
<ol>
<li>  初始标记（STW）</li>
<li>  并发标记</li>
<li>  重新标记（STW + 增量更新）</li>
<li>  并发清除</li>
</ol>
</li>
</ul>
</li>
<li><p>G1收集器（Garbage First收集器）</p>
<ul>
<li>  G1收集器采用了面向局部收集的设计思路和基于Region的内存布局形式。是一款主要面向服务端应用的垃圾收集器。</li>
<li>  G1可以实现在指定的停顿时间内，优先处理回收价值收益最大的Region</li>
<li>  G1将堆内存划分为了多个Region区域，并会计算每个Region区域的回收价值，并组成一个回收集，在回收的时候，根据用户指定的允许停顿时间，计算出收益最大化的回收集，并回收。</li>
<li>  G1依然采用记忆集的形式来记录不同Region间的跨代引用，不过比CMS的记忆集要复杂， CMS中用数组来表示，但是G1中采用类似与哈希表的数据结构来存储，key是其他Region的起始地址，value是该Region中卡表的索引号（表明哪些索引中的对象存在指向其的跨代引用）。</li>
<li>  G1收集器采用原始快照来实现并发标记</li>
<li>G1收集器的步骤<ol>
<li>  初始标记（STW）</li>
<li>  并发标记</li>
<li>  重新标记（STW + 原始快照）</li>
<li>  筛选回收（需要移动存活的对象，所以需要STW）</li>
</ol>
</li>
</ul>
</li>
<li><p>Shenandoah收集器</p>
<ul>
<li><p>  RedHat公司开发的一款低延迟的垃圾收集器</p>
</li>
<li><p>  和G1收集器的设计思路一致，也是基于Region的内存布局来进行回收</p>
</li>
<li><p>  通过“连接矩阵”来记录不同Region之间的跨代引用。</p>
</li>
<li><p>  采用原始快照来实现并发标记</p>
</li>
<li><p>Shenandoah收集器的步骤</p>
<ol>
<li><p>  初始标记（STW）</p>
</li>
<li><p>  并发标记</p>
</li>
<li><p>  最终标记（STW + 原始快照，并计算各Region的回收价值）</p>
</li>
<li><p>  并发清理：清理掉那些整个区域没有一个存活对象的Region</p>
</li>
<li><p>  并发回收：采用Brooks Pointers将回收集Region中的存活对象复制到其他未使用的Region中</p>
</li>
<li><p>  初始引用更新：确保并发回收阶段中进行的收集器线程都已经完成分配给它们的对象移动任务。（STW）</p>
</li>
<li><p>  并发引用更新：将对象的引用从旧值改为新值</p>
</li>
<li><p>  最终引用更新：更新GC Roots中的引用。（STW）</p>
</li>
<li><p>  并发清理</p>
</li>
</ol>
</li>
<li><p>  Brooks解决复制对象和用户线程并发访问的方法是：在对象头中增加了一个新的引用字段，在正常不处于并发移动的情况下，指向对象自己，在移动时，将其指向复制后的对象地址。这样用户线程在访问对象的时候就会被转发到新的对象地址进行访问。Brooks操作需要同步。</p>
</li>
</ul>
</li>
<li><p>ZGC收集器</p>
<ul>
<li>  在JDK11中新加入的具有实验性质的低延迟垃圾收集器，是Oracle公司研发的。</li>
<li>  和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</li>
<li>ZGC也采用基于Region的堆内存布局，但与它们不同的是，ZGC的Region具有动态性，并且有大、中、小三类容量<ul>
<li>  小型Region：2MB，用于放置小于256KB的小对象。</li>
<li>  中型Region：32MB，用于放置大于等于256KB但是小于4MB的对象</li>
<li>  大型Region：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象。大型Region在ZGC的实现中是不会被重分配的。</li>
</ul>
</li>
<li>ZGC采用了染色指针技术，其是一种直接将少量额外的信息存储在指针上的技术。有4TB的内存限制，不支持32位平台，不能支持压缩指针。<ul>
<li>  染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能被释放和重用掉。</li>
<li>  染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量。</li>
</ul>
</li>
<li>ZGC收集的步骤<ul>
<li>  初始标记（STW）</li>
<li>  并发标记</li>
<li>  最终标记（STW）</li>
<li>  并发预备重分配：统计得出本次收集过程要清理哪些Region</li>
<li>  并发重分配：将存活的对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表，记录从旧对象到新对象的转向关系。</li>
<li>  并发重映射：修正整个堆中指向重分配集中旧对象的所有引用。ZGC这一阶段并不迫切，所以ZGC将这一操作放到了下一次垃圾收集的并发标记阶段。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-6-内存分配与回收策略"><a href="#4-6-内存分配与回收策略" class="headerlink" title="4.6 内存分配与回收策略"></a>4.6 内存分配与回收策略</h3><ul>
<li><p>对象优先在Eden分配</p>
<p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间时，虚拟机将发起一次MinorGC。</p>
</li>
<li><p>大对象直接进入老年代</p>
<p>-XX:PretenureSizeThreshold参数指定大于该设置值的对象直接在老年代分配。只对Serial和ParNew有效。</p>
</li>
<li><p>长期存活的对象将进入老年代</p>
<p>-XX:MaxTenuringThreshold参数为晋升老年代的年龄阈值，Eden中的对象每熬过一次MinorGC后，年龄加1。</p>
</li>
<li><p>动态对象年龄判断</p>
<p>如果在Survivor空间中低于或等于某年龄的所有对象大小综合大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。</p>
</li>
<li><p>空间分配担保</p>
<ul>
<li><p>计算老年代的最大连续可用内存空间，为oldMax</p>
</li>
<li><p>当oldMax &gt;= 新生代所有对象总大小 ||  oldMax &gt;= 历年晋升到老年代对象的平均大小时，触发Minor GC，否则出发Full GC</p>
</li>
</ul>
</li>
</ul>
<h2 id="五、JVM相关参数"><a href="#五、JVM相关参数" class="headerlink" title="五、JVM相关参数"></a>五、JVM相关参数</h2><h3 id="JVM相关参数"><a href="#JVM相关参数" class="headerlink" title="JVM相关参数"></a>JVM相关参数</h3><table>
<thead>
<tr>
<th align="left">JVM参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-Xms</td>
<td align="center">初始化堆内存大小</td>
</tr>
<tr>
<td align="left">-Xmx</td>
<td align="center">最大堆内存大小</td>
</tr>
<tr>
<td align="left"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">-XX:NewSize</td>
<td align="center">新生代最小内存大小</td>
</tr>
<tr>
<td align="left">-XX:MaxNewSize</td>
<td align="center">新生代最大内存大小</td>
</tr>
<tr>
<td align="left">-Xmn</td>
<td align="center">新生代分配内存大小（和上面两个含义一，最大=最小）</td>
</tr>
<tr>
<td align="left">-XX:NewRatio</td>
<td align="center">老年代和新生代的比例</td>
</tr>
<tr>
<td align="left">-XX:SurvivorRatio</td>
<td align="center">eden和survivor的比例</td>
</tr>
<tr>
<td align="left">-XX:MaxTenuringThreshold</td>
<td align="center">对象晋升至老年代的年龄阈值</td>
</tr>
<tr>
<td align="left">XX:TargetSurvivorRatio</td>
<td align="center">当&lt;=某个年龄的对象内存达到这个比例时，将&gt;该年龄的对象存放到老年代</td>
</tr>
<tr>
<td align="left"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">-XX:PermSize</td>
<td align="center">永久代初始大小（JDK1.8之前）</td>
</tr>
<tr>
<td align="left">-XX:MaxPermSize</td>
<td align="center">永久代最大大小（JDK1.8之前）</td>
</tr>
<tr>
<td align="left"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">-XX:MetaspaceSize</td>
<td align="center">当元空间扩容到此阈值时，触发full gc，之后每次扩容都会触发</td>
</tr>
<tr>
<td align="left">-XX:MaxMetaspaceSize</td>
<td align="center">元空间的最大大小（JDK1.8）</td>
</tr>
<tr>
<td align="left"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">-XX:+UseSerialGC <br />-XX:+UseParallelGC<br />-XX:+UseParNewGC<br />-XX:+UseG1GC</td>
<td align="center">选择不同类型的垃圾收集器</td>
</tr>
<tr>
<td align="left"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">-XX:+PrintGCDetails</td>
<td align="center">打印GC的详细日志</td>
</tr>
<tr>
<td align="left"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">-XX:+HeapDumpOnOutOfMemoryError<br /> -XX:+HeapDumpPath</td>
<td align="center">发生OOM时，将heap转储到文件中</td>
</tr>
<tr>
<td align="left"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">-Xss</td>
<td align="center">线程栈的空间大小</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者和消费者模式示例 --- 多线程（五）</title>
    <url>/2022/08/07/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>  本文介绍了三种常见的生产者和消费者模式的写法</p>
</blockquote>
<span id="more"></span>

<h1 id="生产者和消费者模式"><a href="#生产者和消费者模式" class="headerlink" title="生产者和消费者模式"></a>生产者和消费者模式</h1><p>生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者问题能够让我们对并发编程的理解加深。所谓生产者-消费者问题，实际上主要是包含了两类线程，一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。但是，这个共享数据区域中应该具备这样的线程间并发协作的功能：</p>
<ol>
<li> 如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；</li>
<li> 如果共享数据区为空的话，阻塞消费者继续消费数据；</li>
</ol>
<p>在实现生产者消费者问题时，可以采用三种方式：</p>
<p>1.使用 Object 的 wait/notify 的消息通知机制；</p>
<p>2.使用 Lock 的 Condition 的 await/signal 的消息通知机制；</p>
<p>3.使用 BlockingQueue 实现。本文主要将这三种实现方式进行总结归纳。</p>
<h2 id="1-wait-notify-机制"><a href="#1-wait-notify-机制" class="headerlink" title="1. wait/notify 机制"></a>1. wait/notify 机制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.global.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> :  zhufeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> :  2022/8/7 15:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wait_notify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object a = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] data = <span class="keyword">new</span> Object[MAX_SIZE];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        wait_notify wait_notify = <span class="keyword">new</span> wait_notify();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait_notify.producer();</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait_notify.consumer();</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">            <span class="keyword">while</span> (size == MAX_SIZE) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者线程被阻塞&quot;</span>);</span><br><span class="line">                a.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            data[size++] = <span class="keyword">new</span> Object();</span><br><span class="line">            System.out.println(<span class="string">&quot;生产：&quot;</span> + size);</span><br><span class="line">            a.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">            <span class="keyword">while</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者线程被阻塞&quot;</span>);</span><br><span class="line">                a.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            data[--size] = <span class="keyword">null</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费：&quot;</span> + size);</span><br><span class="line">            a.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-await-signal-机制"><a href="#2-await-signal-机制" class="headerlink" title="2. await/signal 机制"></a>2. await/signal 机制</h2><p>这个我在之前有写过。不过其实我觉得，producer 和 consumer 应该两把锁会更加合适一些，生产者和消费者不应该有资源冲突。而这刚好就是 ArrayBlockingQueue 和 LinkedBlockingQueue 的区别，前者是生产者和消费者共一把独占锁，但是后者是分开，两把锁，这样并发的效率也就越高，线程等待的机会会更少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.global.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> :  zhufeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> :  2022/8/6 10:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">await_signal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition empty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition full = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] data = <span class="keyword">new</span> Object[MAX_SIZE];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count == MAX_SIZE) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;data满了，producer方法进入等待&quot;</span>);</span><br><span class="line">                full.await();</span><br><span class="line">            &#125;</span><br><span class="line">            data[count++] = <span class="keyword">new</span> Object();</span><br><span class="line">            empty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;producer &quot;</span> + count);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;data空了，consumer方法进入等待&quot;</span>);</span><br><span class="line">                empty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            data[--count] = <span class="keyword">null</span>;</span><br><span class="line">            full.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;consumer &quot;</span> + count);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        await_signal as = <span class="keyword">new</span> await_signal();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        as.producer();</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        as.consumer();</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-BlockingQueue-实现"><a href="#3-BlockingQueue-实现" class="headerlink" title="3. BlockingQueue 实现"></a>3. BlockingQueue 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.global.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> :  zhufeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> :  2022/8/7 15:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Long&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">                        queue.put(value);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::-------PRODUCER--------  &quot;</span> + value);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        value = queue.take();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::-------CONSUMER--------  &quot;</span> + value);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>生产者/消费者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrent并发工具包 --- 多线程（四）</title>
    <url>/2022/08/07/concurrent%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>  本文介绍了concurrent下常见的一些工具类的用法</p>
</blockquote>
<span id="more"></span>

<h1 id="CountDownLatch-倒计时器"><a href="#CountDownLatch-倒计时器" class="headerlink" title="CountDownLatch(倒计时器)"></a>CountDownLatch(倒计时器)</h1><p>在多线程协作完成业务功能时，有时候<strong>需要等待其他多个线程完成任务之后，主线程才能继续往下执行业务功能</strong>，在这种的业务场景下，通常可以使用</p>
<ol>
<li> Thread 类的 join 方法，让主线程等待被 join 的线程执行完之后，主线程才能继续往下执行。</li>
<li> 使用线程间消息通信机制也可以完成。</li>
<li> 使用Executor体系中的 FutureTask,主线程调用其他线程 get() 方法</li>
</ol>
<p>其实，java 并发工具类中为我们提供了类似“倒计时”这样的工具类，可以十分方便的完成所说的这种业务场景。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="/2022/08/07/concurrent%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/00831rSTgy1gcdnpux2e4j30ug09imyh.jpg" alt="image-20200229224934309"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await() <span class="keyword">throws</span> InterruptedException <span class="comment">//调用该方法的线程等到构造方法传入的 N 减到 0 的时候，才能继续往下执行；</span></span><br><span class="line">await(<span class="keyword">long</span> timeout, TimeUnit unit) <span class="comment">//与上面的 await 方法功能一致，只不过这里有了时间限制，调用该方法的线程等到指定的 timeout 时间后，不管 N 是否减至为 0，都会继续往下执行；</span></span><br><span class="line">countDown() <span class="comment">//使 CountDownLatch 初始值 N 减 1；</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> <span class="comment">//获取当前 CountDownLatch 维护的值；</span></span></span><br><span class="line"><span class="function"><span class="title">CountDownLatch</span><span class="params">()</span> <span class="comment">//参数为倒计时数量</span></span></span><br></pre></td></tr></table></figure>

<p>为了能够理解 CountDownLatch，举一个很通俗的例子，运动员进行跑步比赛时，假设有 6 个运动员参与比赛，裁判员在终点会为这 6 个运动员分别计时，可以想象每当一个运动员到达终点的时候，对于裁判员来说就少了一个计时任务。直到所有运动员都到达终点了，裁判员的任务也才完成。这 6 个运动员可以类比成 6 个线程，当线程调用 CountDownLatch.countDown 方法时就会对计数器的值减一，直到计数器的值为 0 的时候，裁判员（调用 await 方法的线程）才能继续往下执行。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.并发工具包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//用来表示裁判员需要维护的是6个运动员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch endSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 运动员等待裁判员响哨！！！&quot;</span>);</span><br><span class="line">                    startSignal.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在全力冲刺&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  到达终点&quot;</span>);</span><br><span class="line">                    endSignal.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;裁判员发号施令啦！！！&quot;</span>);</span><br><span class="line">        startSignal.countDown();</span><br><span class="line">        endSignal.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有运动员到达终点，比赛结束！&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/07/concurrent%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/00831rSTgy1gcdnsp6oh2j30im0mwgpc.jpg" alt="image-20200229225217749"></p>
<h1 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h1><p>CyclicBarrier 也是一种多线程并发控制的实用工具，和 CountDownLatch 一样具有等待计数的功能，但是相比于 CountDownLatch 功能更加强大。</p>
<p>循环栅栏，也就是有一个临界点，所有人到了这个临界点，才可以一起继续工作，然后再等下一次所有人都到这个临界点，继续工作…如此循环…</p>
<h2 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.global.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> :  zhufeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> :  2022/8/7 12:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> : 三个线程交替输出ABC，如果需要按照ABC的顺序输出，可以通过Thread.sleep或者CountDownLatch来实现</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, () -&gt; System.out.println(<span class="string">&quot;线程A、B、C已经执行完一轮&quot;</span>));</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CountDownLatch-与-CyclicBarrier-的比较"><a href="#CountDownLatch-与-CyclicBarrier-的比较" class="headerlink" title="CountDownLatch 与 CyclicBarrier 的比较"></a>CountDownLatch 与 CyclicBarrier 的比较</h1><p>CountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p>
<ul>
<li>  CountDownLatch 一般用于<strong>某个线程 A 等待若干个其他线程执行完任务</strong>之后，它才执行，最重要的是有一个主心骨，主线程是核心，他等所有人干完；而 CyclicBarrier 一般用于<strong>一组线程互相等待至某个状态</strong>，然后这一组线程再同时执行；CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进。所以两者 await 的地方不一样，前者是对主线程进行 await，而后者则是所有一起工作的进行 await。</li>
<li>  CountDownLatch 方法比较少，操作比较简单，而 CyclicBarrier 提供的方法更多，比如能够通过 getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，<strong>并且 CyclicBarrier 的构造方法可以传入 barrierAction</strong>，指定当所有线程都到达时执行的业务功能。</li>
</ul>
<h1 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h1><p>信号量，看源码就是基于 AQS 实现的，类似于***共享锁***，只不过这个共享是有限制的共享，它能够控制共享的线程数量。Semaphore 就相当于一个许可证，线程需要先通过 acquire 方法获取该许可证，该线程才能继续往下执行，否则只能在该方法出阻塞等待。当执行完业务功能后，需要通过<code>release()</code>方法将许可证归还，以便其他线程能够获得许可证继续执行。</p>
<p>Semaphore 可以用于做流量控制，特别是<strong>公共资源有限的应用场景，比如数据库连接</strong>。假如有多个线程读取数据后，需要将数据保存在数据库中，而可用的最大数据库连接只有 10 个，这时候就需要使用 Semaphore 来控制能够并发访问到数据库连接资源的线程个数最多只有 10 个。在限制资源使用的应用场景下，Semaphore 是特别合适的。</p>
<p><img src="/2022/08/07/concurrent%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/00831rSTgy1gcdp7doykcj30u00u4wjf.jpg" alt="image-20200229234039915"></p>
<blockquote>
<p>  这里的队列就是就是很简单的用 ArrayList 进行存储，存储那些等待许可证的线程，没有阻塞然后加入队列然后唤醒这么麻烦…</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.并发工具包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示老师只有5支笔</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表示10个学生</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  同学获取到笔，填表格&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Exchanger-交换器"><a href="#Exchanger-交换器" class="headerlink" title="Exchanger (交换器)"></a>Exchanger (交换器)</h1><p>可以直接在某个临界点，两个线程交换数据，不需要使用 wait/notify 或者是 condition 机制。</p>
<p>它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。具体交换数据是通过 exchange 方法来实现的，如果一个线程先执行 exchange 方法，那么它会同步等待另一个线程也执行 exchange 方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当一个线程执行该方法的时候，会等待另一个线程也执行该方法，因此两个线程就都达到了同步点</span></span><br><span class="line"><span class="comment">//将数据交换给另一个线程，同时返回获取的数据</span></span><br><span class="line"><span class="function">V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//同上一个方法功能基本一样，只不过这个方法同步等待的时候，增加了超时时间</span></span></span><br><span class="line"><span class="function">V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException, TimeoutException</span></span><br><span class="line"><span class="function">copypackage 多线程.并发工具包</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代表男生和女生</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        service.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//男生对女生说的话</span></span><br><span class="line">                String girl = exchanger.exchange(<span class="string">&quot;我其实暗恋你很久了......&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;女孩儿说：&quot;</span> + girl);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;女生慢慢的从教室你走出来......&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                <span class="comment">//男生对女生说的话</span></span><br><span class="line">                String boy = exchanger.exchange(<span class="string">&quot;我也很喜欢你......&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;男孩儿说：&quot;</span> + boy);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">copy女生慢慢的从教室你走出来......</span><br><span class="line">男孩儿说：我其实暗恋你很久了......</span><br><span class="line">女孩儿说：我也很喜欢你......</span><br></pre></td></tr></table></figure>

<p>两句话交换了，这个真的牛逼！</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>并发工具包下用法</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池 --- 多线程（三）</title>
    <url>/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>  本文详细的介绍了Java中的线程池的用法及原理</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>  <a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95">深入理解Java线程池：ThreadPoolExecutor ps:不过说实话，写的败笔就是线程状态转换那一块~</a></p>
<p>  <a href="https://juejin.im/post/5aeec0106fb9a07ab379574f#comment">简略介绍线程池</a></p>
</blockquote>
<blockquote>
<p>  转：<a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95">http://www.ideabuffer.cn/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/#addWorker方法</a></p>
</blockquote>
<h1 id="线程池（一）：ThreadPoolExecutor"><a href="#线程池（一）：ThreadPoolExecutor" class="headerlink" title="线程池（一）：ThreadPoolExecutor"></a>线程池（一）：ThreadPoolExecutor</h1><h2 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h2><p>在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：</p>
<p><strong>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</strong></p>
<p>那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p>
<p>这就是线程池的目的了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。</p>
<p><strong>什么时候使用线程池？</strong></p>
<ul>
<li>  单个任务处理时间比较短</li>
<li>  需要处理的任务数量很大</li>
</ul>
<p><strong>使用线程池的好处</strong></p>
<p>引用自 <a href="http://ifeve.com/java-threadpool/">http://ifeve.com/java-threadpool/</a> 的说明：</p>
<ul>
<li>  降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>  提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>  提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p>Java中的线程池是用ThreadPoolExecutor类来实现的. 本文就结合JDK 1.8对该类的源码来分析一下这个类内部对于线程的创建, 管理以及后台任务的调度等方面的执行原理。</p>
<p>先看一下线程池的类图：</p>
<p><img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdhivqmggj30ke0damy5.jpg" alt="QQ20170331-004227.png"></p>
<h2 id="Executor框架接口"><a href="#Executor框架接口" class="headerlink" title="Executor框架接口"></a>Executor框架接口</h2><p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。</p>
<p>J.U.C中有三个Executor接口：</p>
<ul>
<li>  <strong>Executor</strong>：一个运行新任务的简单接口；</li>
<li>  <strong>ExecutorService</strong>：扩展了Executor接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；</li>
<li>  <strong>ScheduledExecutorService</strong>：扩展了ExecutorService。支持Future和定期执行任务。</li>
</ul>
<h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor接口只有一个execute方法，用来替代通常创建或启动线程的方法。例如，使用Thread来创建并启动线程的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>使用Executor来启动线程执行任务的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">executor.execute(t);</span><br></pre></td></tr></table></figure>

<p>对于不同的Executor实现，execute()方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程。</p>
<h3 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h3><p>ExecutorService接口继承自Executor接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。增加了shutDown()，shutDownNow()，invokeAll()，invokeAny()和submit()等方法。如果需要支持即时关闭，也就是shutDownNow()方法，则任务需要正确处理中断。</p>
<h3 id="ScheduledExecutorService接口"><a href="#ScheduledExecutorService接口" class="headerlink" title="ScheduledExecutorService接口"></a>ScheduledExecutorService接口</h3><p>ScheduledExecutorService扩展ExecutorService接口并增加了schedule方法。调用schedule方法可以在指定的延时后执行一个Runnable或者Callable任务。ScheduledExecutorService接口还定义了按照指定时间间隔定期执行任务的scheduleAtFixedRate()方法和scheduleWithFixedDelay()方法。</p>
<h2 id="ThreadPoolExecutor分析"><a href="#ThreadPoolExecutor分析" class="headerlink" title="ThreadPoolExecutor分析"></a>ThreadPoolExecutor分析</h2><p>ThreadPoolExecutor继承自AbstractExecutorService，也是实现了ExecutorService接口。</p>
<h3 id="几个重要的字段"><a href="#几个重要的字段" class="headerlink" title="几个重要的字段"></a>几个重要的字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p><code>ctl</code>是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。</p>
<p>下面再介绍下线程池的运行状态. 线程池一共有五种状态, 分别是:</p>
<ol>
<li><p> <strong>RUNNING</strong> ：能接受新提交的任务，并且也能处理阻塞队列中的任务；</p>
</li>
<li><p> <strong>SHUTDOWN</strong>：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；<strong>「注意shutdown可能会出现有线程正在等阻塞队列中的任务过来，但是突然shutdown，不会有任务再来了，那线程就会一直阻塞，导致无法回收，所以 shutdown()方法中有调用interruptIdleWorkers()。」</strong></p>
</li>
<li><p> <strong>STOP</strong>：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；</p>
</li>
<li><p> <strong>TIDYING</strong>：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。</p>
</li>
<li><p>TERMINATED</p>
<p> ：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。</p>
<ul>
<li>  线程池不是RUNNING状态；</li>
<li>  线程池状态不是TIDYING状态或TERMINATED状态；</li>
<li>  如果线程池状态是SHUTDOWN并且workerQueue为空；</li>
<li>  workerCount为0；</li>
<li>  设置TIDYING状态成功。</li>
</ul>
</li>
</ol>
<p>下图为线程池的状态转换过程：</p>
<p><img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdhke8ix8j30qn0ai3zi.jpg" alt="threadpool-status.png"></p>
<h3 id="ctl相关方法"><a href="#ctl相关方法" class="headerlink" title="ctl相关方法"></a>ctl相关方法</h3><p>这里还有几个对ctl进行计算的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>runStateOf</strong>：获取运行状态；</li>
<li>  <strong>workerCountOf</strong>：获取活动线程数；</li>
<li>  <strong>ctlOf</strong>：获取运行状态和活动线程数的值。</li>
</ul>
<h3 id="ThreadPoolExecutor构造方法"><a href="#ThreadPoolExecutor构造方法" class="headerlink" title="ThreadPoolExecutor构造方法"></a>ThreadPoolExecutor构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法中的字段含义如下：</p>
<ul>
<li><p><strong>corePoolSize</strong>：核心线程数量，当有新任务在execute()方法提交时，会执行以下判断：</p>
<ol>
<li> 如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；</li>
<li> 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；</li>
<li> 如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；</li>
<li> 如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；</li>
</ol>
<p>  所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</p>
</li>
<li><p>  <strong>maximumPoolSize</strong>：最大线程数量；</p>
</li>
<li><p><strong>workQueue</strong>：等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，也就是 BlockingQueue 的选择，主要有以下几种处理方式:</p>
<ol>
<li><p> <strong>直接切换</strong>：这种方式常用的队列是SynchronousQueue，但现在还没有研究过该队列，这里暂时还没法介绍；</p>
</li>
<li><p> <strong>使用无界队列</strong>：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了「因为队列永远不会满…」（后面也会说到）。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</p>
</li>
<li><p>使用有界队列</p>
<p> ：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。</p>
<ul>
<li>  如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li>
<li>  如果提交的任务经常发生阻塞，那么可以考虑通过调用 setMaximumPoolSize() 方法来重新设定线程池的容量。</li>
<li>  如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li>
</ul>
</li>
</ol>
</li>
<li><p>  <strong>keepAliveTime</strong>：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</p>
</li>
<li><p>  <strong>threadFactory</strong>：它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</p>
</li>
<li><p><strong>handler</strong>：它是RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：</p>
<ol>
<li> AbortPolicy：直接抛出异常，这是默认策略；</li>
<li> CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li> DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li> DiscardPolicy：直接丢弃任务；</li>
</ol>
</li>
</ul>
<h3 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h3><p>execute()方法用来提交任务，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * clt记录着runState和workerCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * workerCountOf方法取出低29位的值，表示当前活动的线程数；</span></span><br><span class="line"><span class="comment">     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；</span></span><br><span class="line"><span class="comment">     * 并把任务添加到该线程中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果为true，根据corePoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果添加失败，则重新获取ctl值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果当前线程池是运行状态并且任务添加到队列成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 重新获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></span><br><span class="line">        <span class="comment">// 这时需要移除该command</span></span><br><span class="line">        <span class="comment">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line"><span class="comment">         * 这里传入的参数表示：</span></span><br><span class="line"><span class="comment">         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class="line"><span class="comment">         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果执行到这里，有两种情况：</span></span><br><span class="line"><span class="comment">     * 1. 线程池已经不是RUNNING状态；</span></span><br><span class="line"><span class="comment">     * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。</span></span><br><span class="line"><span class="comment">     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span></span><br><span class="line"><span class="comment">     * 如果失败则拒绝该任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说，在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下：</p>
<ol>
<li> 如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</li>
<li> 如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li> 如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li> 如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>这里要注意一下<code>addWorker(null, false);</code>，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中获取任务。所以，在<code>workerCountOf(recheck) == 0</code>时执行<code>addWorker(null, false);</code>也是为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。</p>
<p>execute方法执行流程如下：</p>
<p><img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdhivhphbj30n50le3zj.jpg" alt="executor.png"></p>
<h3 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h3><p>addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数 用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个if判断</span></span><br><span class="line"><span class="comment">         * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class="line"><span class="comment">         * 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class="line"><span class="comment">         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line"><span class="comment">         * 2. firsTask为空</span></span><br><span class="line"><span class="comment">         * 3. 阻塞队列不为空</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 首先考虑rs == SHUTDOWN的情况</span></span><br><span class="line"><span class="comment">         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class="line"><span class="comment">         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</span></span><br><span class="line"><span class="comment">         * 因为队列中已经没有任务了，不需要再添加线程了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></span><br><span class="line">            <span class="comment">// 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，</span></span><br><span class="line">            <span class="comment">// 如果为false则根据maximumPoolSize来比较。</span></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 尝试增加workerCount，如果成功，则跳出第一个for循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据firstTask来创建Worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 每一个Worker对象都会创建一个线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></span><br><span class="line">                <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class="line">                <span class="comment">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// workers是一个HashSet</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一下这里的<code>t.start()</code>这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。</p>
<h3 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h3><p>线程池中的<strong>每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，看一下Worker的定义：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Worker类继承了AQS</strong>，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p>
<p>在调用构造方法时，需要把任务传入，这里通过<code>getThreadFactory().newThread(this);</code>来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。</p>
<p>Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是<strong>不允许重入的</strong>，而ReentrantLock是允许重入的：</p>
<ol>
<li> lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</li>
<li> 如果正在执行任务，则不应该中断线程；</li>
<li> 如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li>
<li> 线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</li>
<li> <strong>之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。</strong></li>
</ol>
<p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。</p>
<p>此外，在构造方法中执行了<code>setState(-1);</code>，把state变量设置为-1，为什么这么做呢？是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquire方法是根据state是否是0来判断的，所以，<code>setState(-1);</code>将state设置为-1是为了禁止在执行任务前对线程进行中断。</p>
<p>正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为0.</p>
<h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 允许中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 是否因为异常退出循环</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果task为空，则通过getTask来获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里说明一下第一个if判断，目的是：</p>
<ul>
<li>  如果线程池正在停止，那么要保证当前线程是中断状态；</li>
<li>  如果不是的话，则要保证当前线程不是中断状态；</li>
</ul>
<p>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：</p>
<blockquote>
<p>  不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。</p>
</blockquote>
<p>STOP状态要中断线程池中的所有线程，而这里使用<code>Thread.interrupted()</code>来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。</p>
<p>总结一下runWorker方法的执行过程：</p>
<ol>
<li> while循环不断地通过getTask()方法获取任务；</li>
<li> getTask()方法从阻塞队列中取任务；</li>
<li> 如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</li>
<li> 调用<code>task.run()</code>执行任务；</li>
<li> 如果task为null则跳出循环，执行processWorkerExit()方法；</li>
<li> runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</li>
</ol>
<p>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。</p>
<p>completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。</p>
<h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><p>getTask方法用来从阻塞队列中取任务，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：</span></span><br><span class="line"><span class="comment">         * 1. rs &gt;= STOP，线程池是否正在stop；</span></span><br><span class="line"><span class="comment">         * 2. 阻塞队列是否为空。</span></span><br><span class="line"><span class="comment">         * 如果以上条件满足，则将workerCount减1并返回null。</span></span><br><span class="line"><span class="comment">         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；</span></span><br><span class="line"><span class="comment">         * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line"><span class="comment">         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；</span></span><br><span class="line"><span class="comment">         * 如果减1失败，则返回重试。</span></span><br><span class="line"><span class="comment">         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span></span><br><span class="line"><span class="comment">             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 如果 r == null，说明已经超时，timedOut设置为true</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。</p>
<p>什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。</p>
<p>getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</p>
<h3 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。  </span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：</p>
<p><img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdhix6r14j30no0ii0t8.jpg" alt="threadpool-lifecycle.png"></p>
<h3 id="tryTerminate方法"><a href="#tryTerminate方法" class="headerlink" title="tryTerminate方法"></a>tryTerminate方法</h3><p>tryTerminate方法根据线程池状态进行判断是否结束线程池，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当前线程池的状态为以下几种情况时，直接返回：</span></span><br><span class="line"><span class="comment">         * 1. RUNNING，因为还在运行中，不能停止；</span></span><br><span class="line"><span class="comment">         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；</span></span><br><span class="line"><span class="comment">         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果线程数量不为0，则中断一个空闲的工作线程，并返回</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// terminated方法默认什么都不做，留给子类实现</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置状态为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>interruptIdleWorkers(ONLY_ONE)</code>的作用是因为在getTask方法中执行<code>workQueue.take()</code>时，如果不执行中断会一直阻塞。在下面介绍的shutdown方法中，会中断所有空闲的工作线程，如果在执行shutdown时工作线程没有空闲，然后又去调用了getTask方法，这时如果workQueue中没有任务了，调用<code>workQueue.take()</code>时就会一直阻塞。所以每次在工作线程结束时调用tryTerminate方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况。</p>
<h3 id="shutdown方法"><a href="#shutdown方法" class="headerlink" title="shutdown方法"></a>shutdown方法</h3><p>shutdown方法要将线程池切换到SHUTDOWN状态，并调用interruptIdleWorkers方法请求中断所有空闲的worker，最后调用tryTerminate尝试结束线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 安全策略判断</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 切换状态为SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里思考一个问题：在runWorker方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？</strong></p>
<p><strong>下面仔细分析一下：</strong></p>
<ul>
<li>  <strong>在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；</strong></li>
<li>  <strong>shutdown方法会调用interruptIdleWorkers来中断空闲的线程，interruptIdleWorkers持有mainLock，会遍历workers来逐个判断工作线程是否空闲。但getTask方法中没有mainLock；</strong></li>
<li>  <strong>在getTask中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用<code>workQueue.take()</code>进行阻塞；</strong></li>
<li>  <strong>如果在判断当前线程池状态是RUNNING后，这时调用了shutdown方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了<code>workQueue.take()</code>后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到workQueue中，这样一来线程池永远都关闭不了了；</strong></li>
<li>  <strong>由上可知，shutdown方法与getTask方法（从队列中获取任务时）存在竞态条件；</strong></li>
<li>  <strong>解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用<code>workQueue.take()</code>时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出InterruptedException，解除阻塞的状态；</strong></li>
<li>  <strong>但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；</strong></li>
<li>  <strong>所以Worker继承自AQS，在工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。</strong></li>
</ul>
<p>下面就来分析一下interruptIdleWorkers方法。</p>
<h3 id="interruptIdleWorkers方法"><a href="#interruptIdleWorkers方法" class="headerlink" title="interruptIdleWorkers方法"></a>interruptIdleWorkers方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interruptIdleWorkers遍历workers中所有的工作线程，若线程没有被中断tryLock成功，就中断该线程。</p>
<p>为什么需要持有mainLock？<strong>因为workers是HashSet类型的，不能保证线程安全。</strong></p>
<h3 id="shutdownNow方法"><a href="#shutdownNow方法" class="headerlink" title="shutdownNow方法"></a>shutdownNow方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有工作线程，无论是否空闲</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 取出队列中没有被执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shutdownNow方法与shutdown方法类似，不同的地方在于：</p>
<ol>
<li> 设置状态为STOP；</li>
<li> 中断所有工作线程，无论是否是空闲的；</li>
<li> 取出阻塞队列中没有被执行的任务并返回。</li>
</ol>
<p>shutdownNow方法执行完之后调用tryTerminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。</p>
<h2 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h2><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>  <strong>getTaskCount</strong>：线程池已经执行的和未执行的任务总数；</li>
<li>  <strong>getCompletedTaskCount</strong>：线程池已完成的任务数量，该值小于等于taskCount；</li>
<li>  <strong>getLargestPoolSize</strong>：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li>
<li>  <strong>getPoolSize</strong>：线程池当前的线程数量；</li>
<li>  <strong>getActiveCount</strong>：当前线程池中正在执行任务的线程数量。</li>
</ul>
<p>通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文比较详细的分析了线程池的工作流程，总体来说有如下几个内容：</p>
<ul>
<li>  分析了线程的创建，任务的提交，状态的转换以及线程池的关闭；</li>
<li>  这里通过execute方法来展开线程池的工作流程，execute方法通过corePoolSize，maximumPoolSize以及阻塞队列的大小来判断决定传入的任务应该被立即执行，还是应该添加到阻塞队列中，还是应该拒绝任务。</li>
<li>  介绍了线程池关闭时的过程，也分析了shutdown方法与getTask方法存在竞态条件；</li>
<li>  在获取任务时，要通过线程池的状态来判断应该结束工作线程还是阻塞线程等待新的任务，也解释了为什么关闭线程池时要中断工作线程以及为什么每一个worker都需要lock。</li>
</ul>
<p>在向线程池提交任务时，除了execute方法，还有一个submit方法，submit方法会返回一个Future对象用于获取返回值，具体可以见 多线程（一）中的 最开始的 demo。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>最近好久没复习了，突然有点对线程池晕头转向，阻塞队列到底是存储什么的呢？里面是怎么一个存储形式呢？阻塞队列又是如何实现的呢？阻塞队列和 AQS 中的 CLH 变体队列又有什么关系和联系呢？线程池中的线程又是如何管理的呢？他们是如何存储的呢？线程池中的线程又是怎么去运作的呢？</p>
<p>来，这些问题一个一个来解决！</p>
<ol>
<li> 阻塞队列到底存储的是什么？</li>
</ol>
<blockquote>
<p>  存储的是 Runnable 对象，也就是我们常说的任务</p>
</blockquote>
<ol>
<li> 里面是如何存储以及如何实现的？</li>
</ol>
<blockquote>
<p>  ArrayBlockingQueue 是利用数组存储的，LinkedBlockingQueue 是利用的链表存储的，这里比普通的队列多了一个使用了 ReentrantLock 保证线程安全并且通过使用 Condition 队列保证消费者/生产者模式。</p>
</blockquote>
<ol>
<li> 阻塞队列和 AQS 的 CLH变体队列有啥关系和联系</li>
</ol>
<blockquote>
<p>  没有任何关系，CLH 变体队列是同步队列，存储的是<strong>线程</strong>包装后的 Node，我们这里的阻塞队列仅仅是<strong>任务</strong>包装后的节点，所以并没有 CLH 变体队列那么复杂，不需要进行一个线程唤醒阻塞的过程「park、unpark」，也无需去考虑共享锁和独占锁之类的，更不用考虑同步队列和条件队列的切换过程。</p>
</blockquote>
<ol>
<li> 线程池中的线程是如何管理的呢？又是如何存储的呢？</li>
</ol>
<blockquote>
<p>  线程池其实管理的并不是线程，而是 Worker，Worker 包括的属性有线程、任务，每一个 Worker 都是用 HashSet 存储的。</p>
</blockquote>
<ol>
<li> 线程池中的线程如何运作的？</li>
</ol>
<blockquote>
<p>  最开始的 Worker 是直接任务来了就直接 new thread 并接受任务，因为此时还没到核心线程数，当到了核心线程数之后，Worker 就会去队列里 take 相应的任务，如果队列也满了的话，就去 new 新的 Worker 接受任务，如果到了最大线程数，就直接默认抛异常「当然还有另外三种措施：1. 丢弃阻塞队列中最前面的 2. 直接不管这个任务 3. 使用调用的这个线程去执行」。</p>
<p>  这里 Worker 去拿任务需要注意一下，由于 阻塞队列是线程安全的，所以不会存在一个任务可能被多个线程取走，这是不可能的，其次，得注意一下，Worker 有去继承 AQS，这是我认为线程池中写的最好的一块，主要是解决了两个问题「支持中断以及标记线程是否空闲」，我下面也有详细说这个。</p>
<p>  这个也讲的还行：<a href="https://www.cnblogs.com/micrari/p/7429364.html">https://www.cnblogs.com/micrari/p/7429364.html</a></p>
</blockquote>
<ol>
<li> 如何保证核心线程不被销毁</li>
</ol>
<blockquote>
<ol>
<li> <strong>timedOut超时标记默认设置为false；</strong></li>
<li> <strong>计算timed的值，该值决定了线程的生死大权，(timed &amp;&amp; timedOut) 即是线程超时回收的条件之一，需要注意的是第一次(timed &amp;&amp; timedOut) 为false，因为timedOut默认值为false，此时还没到poll超时获取的操作；</strong></li>
<li> <strong>根据timed值来决定是用阻塞超时获取任务还是阻塞获取任务，如果用阻塞超时获取任务，超时后timedOut会被设置为true，接着继续循环，若(timed &amp;&amp; timedOut) 为true，满足线程超时回收。</strong></li>
</ol>
</blockquote>
<p>没有组织的一些话，留在这吧，当时想到啥就说啥了</p>
<blockquote>
<p>  「问题的核心是区分开 Runnable 和 Thread的区别，一个是任务，一个是线程」</p>
<p>  「阻塞队列中存储的是Runnable，阻塞队列底层就是链表实现，然后通过 ReentrantLock 达到线程安全，并且通过 Condition 完成生产者/消费者模式，然后线程池中的线程使用 hashSet 存储，核心线程池中的线程由于 timeout等于无穷所以不会被销毁。阻塞队列和 AQS 没有关系，只是用到了 Condition 和 ReentrantLock 」</p>
<p>  「线程池的线程，new 出来后，会被封装成 Worker 对象，然后里面可以运行任务，所有的 Worker 是放在 HashSet 中的。」</p>
<p>  「线程池中我觉得最精妙的地方是让 worker 去继承 AQS，这是非常巧妙的设计，这个设计主要是为了在更改 shutdown 和 stop 的时候做出的设计，</p>
<ul>
<li>  我们知道，shutdown就是不再接受新的任务，但是不能把正在运行的任务停掉，同时要把处于空闲的状态的线程停掉，在这里如何区分线程是否空闲是一个问题，源码的解决方案是让 worker 包装成一个互斥锁，如果在运行就给自己加锁，这样我判断线程是否空闲就可以直接用 tryAcquire() 去判断了；</li>
<li>  原因之二就是 stop 的时候，我们是需要强制停掉正在运行的任务的，而AQS刚好就提供响应中断，所以这又是worker继承AQS的一大原因。」</li>
</ul>
<p>  <a href="http://objcoding.com/2019/04/25/threadpool-running/#worker">http://objcoding.com/2019/04/25/threadpool-running/#worker</a> 这个对 ”如何保证核心线程不被销毁“讲的挺好的</p>
</blockquote>
<h1 id="线程池（二）：ScheduledThreadPoolExecutor"><a href="#线程池（二）：ScheduledThreadPoolExecutor" class="headerlink" title="线程池（二）：ScheduledThreadPoolExecutor"></a>线程池（二）：ScheduledThreadPoolExecutor</h1><blockquote>
<p>  转：<a href="http://www.ideabuffer.cn/2017/04/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AScheduledThreadPoolExecutor/">http://www.ideabuffer.cn/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/</a></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>自JDK1.5开始，JDK提供了ScheduledThreadPoolExecutor类来支持周期性任务的调度。在这之前的实现需要依靠Timer和TimerTask或者其它第三方工具来完成。但Timer有不少的缺陷：</p>
<ul>
<li>  Timer是单线程模式；</li>
<li>  如果在执行任务期间某个TimerTask耗时较久，那么就会影响其它任务的调度；</li>
<li>  Timer的任务调度是基于绝对时间的，对系统时间敏感；</li>
<li>  Timer不会捕获执行TimerTask时所抛出的异常，由于Timer是单线程，所以一旦出现异常，则线程就会终止，其他任务也得不到执行。</li>
</ul>
<p>ScheduledThreadPoolExecutor继承ThreadPoolExecutor来重用线程池的功能，它的实现方式如下：</p>
<ul>
<li>  将任务封装成ScheduledFutureTask对象，ScheduledFutureTask基于相对时间，不受系统时间的改变所影响；</li>
<li>  ScheduledFutureTask实现了<code>java.lang.Comparable</code>接口和<code>java.util.concurrent.Delayed</code>接口，所以有两个重要的方法：compareTo和getDelay。compareTo方法用于比较任务之间的优先级关系，如果距离下次执行的时间间隔较短，则优先级高；getDelay方法用于返回距离下次任务执行时间的时间间隔；</li>
<li>  ScheduledThreadPoolExecutor定义了一个DelayedWorkQueue，它是一个有序队列，会通过每个任务按照距离下次执行时间间隔的大小来排序；</li>
<li>  ScheduledFutureTask继承自FutureTask，可以通过返回Future对象来获取执行的结果。</li>
</ul>
<p>通过如上的介绍，可以对比一下Timer和ScheduledThreadPoolExecutor：</p>
<table>
<thead>
<tr>
<th align="left">Timer</th>
<th align="left">ScheduledThreadPoolExecutor</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单线程</td>
<td align="left">多线程</td>
</tr>
<tr>
<td align="left">单个任务执行时间影响其他任务调度</td>
<td align="left">多线程，不会影响</td>
</tr>
<tr>
<td align="left">基于绝对时间</td>
<td align="left">基于相对时间</td>
</tr>
<tr>
<td align="left">一旦执行任务出现异常不会捕获，其他任务得不到执行</td>
<td align="left">多线程，单个任务的执行不会影响其他线程</td>
</tr>
</tbody></table>
<p>所以，在JDK1.5之后，应该没什么理由继续使用Timer进行任务调度了。</p>
<h2 id="ScheduledThreadPoolExecutor的使用"><a href="#ScheduledThreadPoolExecutor的使用" class="headerlink" title="ScheduledThreadPoolExecutor的使用"></a>ScheduledThreadPoolExecutor的使用</h2><p>下面用一个具体的例子来说明ScheduledThreadPoolExecutor的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建大小为5的线程池</span></span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Task worker = <span class="keyword">new</span> Task(<span class="string">&quot;task-&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 只执行一次</span></span><br><span class="line"><span class="comment">//          scheduledThreadPool.schedule(worker, 5, TimeUnit.SECONDS);</span></span><br><span class="line">            <span class="comment">// 周期性执行，每5秒执行一次</span></span><br><span class="line">            scheduledThreadPool.scheduleAtFixedRate(worker, <span class="number">0</span>,<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Shutting down executor...&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line">        <span class="keyword">boolean</span> isDone;</span><br><span class="line">        <span class="comment">// 等待线程池终止</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            isDone = scheduledThreadPool.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">            System.out.println(<span class="string">&quot;awaitTermination...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!isDone);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, startTime = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, endTime = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就来具体分析一下ScheduledThreadPoolExecutor的实现过程。</p>
<h2 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h2><h3 id="ScheduledThreadPoolExecutor的类结构"><a href="#ScheduledThreadPoolExecutor的类结构" class="headerlink" title="ScheduledThreadPoolExecutor的类结构"></a>ScheduledThreadPoolExecutor的类结构</h3><p>看下ScheduledThreadPoolExecutor内部的类图：</p>
<p><img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjepxhapj30r70d275d.jpg" alt="QQ20170409-013110.png"></p>
<p>不要被这么多类吓到，这里只不过是为了更清楚的了解ScheduledThreadPoolExecutor有关调度和队列的接口。</p>
<p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，实现了ScheduledExecutorService接口，该接口定义了schedule等任务调度的方法。</p>
<p>同时ScheduledThreadPoolExecutor有两个重要的内部类：DelayedWorkQueue和ScheduledFutureTask。可以看到，DelayeddWorkQueue是一个阻塞队列，而ScheduledFutureTask继承自FutureTask，并且实现了Delayed接口。有关FutureTask的介绍请参考另一篇文章：<a href="http://www.ideabuffer.cn/2017/04/06/FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">FutureTask源码解析</a>。</p>
<h3 id="ScheduledThreadPoolExecutor的构造方法"><a href="#ScheduledThreadPoolExecutor的构造方法" class="headerlink" title="ScheduledThreadPoolExecutor的构造方法"></a>ScheduledThreadPoolExecutor的构造方法</h3><p>ScheduledThreadPoolExecutor有3中构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，所以这里都是调用的ThreadPoolExecutor类的构造方法。有关ThreadPoolExecutor可以参考<a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/">深入理解Java线程池：ThreadPoolExecutor</a>。</p>
<p>这里注意传入的阻塞队列是DelayedWorkQueue类型的对象。后面会详细介绍。</p>
<h3 id="schedule方法"><a href="#schedule方法" class="headerlink" title="schedule方法"></a>schedule方法</h3><p>在上文的例子中，使用了schedule方法来进行任务调度，schedule方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay,</span><br><span class="line">                                   TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(delay, unit)));</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">long</span> delay,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(callable,</span><br><span class="line">                                   triggerTime(delay, unit)));</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，这里的两个重载的schedule方法只是传入的第一个参数不同，可以是Runnable对象或者Callable对象。会把传入的任务封装成一个RunnableScheduledFuture对象，其实也就是ScheduledFutureTask对象，decorateTask默认什么功能都没有做，子类可以重写该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改或替换用于执行 runnable 的任务。此方法可重写用于管理内部任务的具体类。默认实现只返回给定任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改或替换用于执行 callable 的任务。此方法可重写用于管理内部任务的具体类。默认实现只返回给定任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，通过调用delayedExecute方法来延时执行任务。<br>最后，返回一个ScheduledFuture对象。</p>
<h3 id="scheduleAtFixedRate方法"><a href="#scheduleAtFixedRate方法" class="headerlink" title="scheduleAtFixedRate方法"></a>scheduleAtFixedRate方法</h3><p>该方法设置了执行周期，下一次执行时间相当于是上一次的执行时间加上period，它是采用已固定的频率来执行任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(period));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scheduleWithFixedDelay方法"><a href="#scheduleWithFixedDelay方法" class="headerlink" title="scheduleWithFixedDelay方法"></a>scheduleWithFixedDelay方法</h3><p>该方法设置了执行周期，与scheduleAtFixedRate方法不同的是，下一次执行时间是上一次任务执行完的系统时间加上period，因而具体执行时间不是固定的，但周期是固定的，是采用相对固定的延迟来执行任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(-delay));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的<code>unit.toNanos(-delay));</code>，这里把周期设置为负数来表示是相对固定的延迟执行。</p>
<p>scheduleAtFixedRate和scheduleWithFixedDelay的区别在setNextRunTime方法中就可以看出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="comment">// 固定频率，上次执行时间加上周期时间</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        time += p;</span><br><span class="line">    <span class="comment">// 相对固定延迟执行，使用当前系统时间加上周期时间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setNextRunTime方法会在run方法中执行完任务后调用。</p>
<h3 id="triggerTime方法"><a href="#triggerTime方法" class="headerlink" title="triggerTime方法"></a>triggerTime方法</h3><p>triggerTime方法用于获取下一次执行的具体时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="number">0</span>) ? <span class="number">0</span> : delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now() +</span><br><span class="line">        ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>delay &lt; (Long.MAX_VALUE &gt;&gt; 1</code>是为了判断是否要防止Long类型溢出，如果delay的值小于Long类型最大值的一半，则直接返回delay，否则需要进行防止溢出处理。</p>
<h3 id="overflowFree方法"><a href="#overflowFree方法" class="headerlink" title="overflowFree方法"></a>overflowFree方法</h3><p>该方法的作用是限制队列中所有节点的延迟时间在Long.MAX_VALUE之内，防止在compareTo方法中溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">overflowFree</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取队列中的第一个节点</span></span><br><span class="line">    Delayed head = (Delayed) <span class="keyword">super</span>.getQueue().peek();</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取延迟时间</span></span><br><span class="line">        <span class="keyword">long</span> headDelay = head.getDelay(NANOSECONDS);</span><br><span class="line">        <span class="comment">// 如果延迟时间小于0，并且 delay - headDelay 超过了Long.MAX_VALUE</span></span><br><span class="line">        <span class="comment">// 将delay设置为 Long.MAX_VALUE + headDelay 保证delay小于Long.MAX_VALUE</span></span><br><span class="line">        <span class="keyword">if</span> (headDelay &lt; <span class="number">0</span> &amp;&amp; (delay - headDelay &lt; <span class="number">0</span>))</span><br><span class="line">            delay = Long.MAX_VALUE + headDelay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个任务已经可以执行出队操作，但还没有执行，可能由于线程池中的工作线程不是空闲的。具体分析一下这种情况：</p>
<ul>
<li>  为了方便说明，假设Long.MAX_VALUE=1023，也就是11位，并且当前的时间是100，调用triggerTime时并没有对delay进行判断，而是直接返回了<code>now() + delay</code>，也就是相当于<code>100 + 1023</code>，这肯定是溢出了，那么返回的时间是-925；</li>
<li>  如果头节点已经可以出队但是还没有执行出队，那么头节点的执行时间应该是小于当前时间的，假设是95；</li>
<li>  这时调用offer方法向队列中添加任务，在offer方法中会调用siftUp方法来排序，在siftUp方法执行时又会调用ScheduledFutureTask中的compareTo方法来比较执行时间；</li>
<li>  这时如果执行到了compareTo方法中的<code>long diff = time - x.time;</code>时，那么计算后的结果就是<code>-925 - 95 = -1020</code>，那么将返回-1，而正常情况应该是返回1，因为新加入的任务的执行时间要比头结点的执行时间要晚，这就不是我们想要的结果了，这会导致队列中的顺序不正确。</li>
<li>  同理也可以算一下在执行compareTo方法中的<code>long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</code>时也会有这种情况；</li>
<li>  所以在triggerTime方法中对delay的大小做了判断，就是为了防止这种情况发生。</li>
</ul>
<p>如果执行了overflowFree方法呢，这时<code>headDelay = 95 - 100 = -5</code>，然后执行<code>delay = 1023 + (-5) = 1018</code>，那么triggerTime会返回<code>100 + 1018 = -930</code>，再执行compareTo方法中的<code>long diff = time - x.time;</code>时，<code>diff = -930 - 95 = -930 - 100 + 5 = 1018 + 5 = 1023</code>，没有溢出，符合正常的预期。</p>
<p>所以，overflowFree方法中把已经超时的部分时间给减去，就是为了避免在compareTo方法中出现溢出情况。</p>
<p>（说实话，这段代码看的很痛苦，一般情况下也不会发生这种情况，谁会传一个Long.MAX_VALUE呢。要知道Long.MAX_VALUE的纳秒数换算成年的话是292年，谁会这么无聊。。。）</p>
<h3 id="ScheduledFutureTask的getDelay方法"><a href="#ScheduledFutureTask的getDelay方法" class="headerlink" title="ScheduledFutureTask的getDelay方法"></a>ScheduledFutureTask的getDelay方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行时间减去当前系统时间</span></span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - now(), NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ScheduledFutureTask的构造方法"><a href="#ScheduledFutureTask的构造方法" class="headerlink" title="ScheduledFutureTask的构造方法"></a>ScheduledFutureTask的构造方法</h3><p>ScheduledFutureTask继承自FutureTask并实现了RunnableScheduledFuture接口，具体可以参考上文的类图，构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a periodic action with given nano time and period.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a one-shot action with given nanoTime-based trigger time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面有几个重要的属性，下面来解释一下：</p>
<ul>
<li>  <strong>time</strong>：下次任务执行时的时间；</li>
<li>  <strong>period</strong>：执行周期；</li>
<li>  <strong>sequenceNumber</strong>：保存任务被添加到ScheduledThreadPoolExecutor中的序号。</li>
</ul>
<p>在schedule方法中，创建完ScheduledFutureTask对象之后，会执行delayedExecute方法来执行任务。</p>
<h3 id="delayedExecute方法"><a href="#delayedExecute方法" class="headerlink" title="delayedExecute方法"></a>delayedExecute方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程池已经关闭，使用拒绝策略拒绝任务</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加到阻塞队列中</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">            remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 确保线程池中至少有一个线程启动，即使corePoolSize为0</span></span><br><span class="line">            <span class="comment">// 该方法在ThreadPoolExecutor中实现</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说一下这里的第二个if判断：</p>
<ol>
<li> 如果不是SHUTDOWN状态，执行else，否则执行步骤2；</li>
<li> 如果在当前线程池运行状态下可以执行任务，执行else，否则执行步骤3；</li>
<li> 从阻塞队列中删除任务，如果失败，执行else，否则执行步骤4；</li>
<li> 取消任务，但不中断执行中的任务。</li>
</ol>
<p>对于步骤2，可以通过setContinueExistingPeriodicTasksAfterShutdownPolicy方法设置在线程池关闭时，周期任务继续执行，默认为false，也就是线程池关闭时，不再执行周期任务。</p>
<p>ensurePrestart方法在ThreadPoolExecutor中定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(ctl.get());</span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了addWorker方法，可以在<a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95">深入理解Java线程池：ThreadPoolExecutor</a>中查看addWorker方法的介绍，线程池中的工作线程是通过该方法来启动并执行任务的。</p>
<h3 id="ScheduledFutureTask的run方法"><a href="#ScheduledFutureTask的run方法" class="headerlink" title="ScheduledFutureTask的run方法"></a>ScheduledFutureTask的run方法</h3><p>回顾一下线程池的执行过程：当线程池中的工作线程启动时，不断地从阻塞队列中取出任务并执行，当然，取出的任务实现了Runnable接口，所以是通过调用任务的run方法来执行任务的。</p>
<p>这里的任务类型是ScheduledFutureTask，所以下面看一下ScheduledFutureTask的run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是周期性任务</span></span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="comment">// 当前线程池运行状态下如果不可以执行任务，取消该任务</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 如果不是周期性任务，调用FutureTask中的run方法执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="comment">// 如果是周期性任务，调用FutureTask中的runAndReset方法执行</span></span><br><span class="line">    <span class="comment">// runAndReset方法不会设置执行结果，所以可以重复执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        <span class="comment">// 计算下次执行该任务的时间</span></span><br><span class="line">        setNextRunTime();</span><br><span class="line">        <span class="comment">// 重复执行任务</span></span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关FutureTask的run方法和runAndReset方法，可以参考<a href="http://www.ideabuffer.cn/2017/04/06/FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">FutureTask源码解析</a>。</p>
<p>分析一下执行过程：</p>
<ol>
<li> 如果当前线程池运行状态不可以执行任务，取消该任务，然后直接返回，否则执行步骤2；</li>
<li> 如果不是周期性任务，调用FutureTask中的run方法执行，会设置执行结果，然后直接返回，否则执行步骤3；</li>
<li> 如果是周期性任务，调用FutureTask中的runAndReset方法执行，不会设置执行结果，然后直接返回，否则执行步骤4和步骤5；</li>
<li> 计算下次执行该任务的具体时间；</li>
<li> 重复执行任务。</li>
</ol>
<h3 id="ScheduledFutureTask的reExecutePeriodic方法"><a href="#ScheduledFutureTask的reExecutePeriodic方法" class="headerlink" title="ScheduledFutureTask的reExecutePeriodic方法"></a>ScheduledFutureTask的reExecutePeriodic方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法和delayedExecute方法类似，不同的是：</p>
<ol>
<li> 由于调用reExecutePeriodic方法时已经执行过一次周期性任务了，所以不会reject当前任务；</li>
<li> 传入的任务一定是周期性任务。</li>
</ol>
<h3 id="onShutdown方法"><a href="#onShutdown方法" class="headerlink" title="onShutdown方法"></a>onShutdown方法</h3><p>onShutdown方法是ThreadPoolExecutor中的钩子方法，在ThreadPoolExecutor中什么都没有做，参考<a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/">深入理解Java线程池：ThreadPoolExecutor</a>，该方法是在执行shutdown方法时被调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = <span class="keyword">super</span>.getQueue();</span><br><span class="line">    <span class="comment">// 获取在线程池已 shutdown 的情况下是否继续执行现有延迟任务</span></span><br><span class="line">    <span class="keyword">boolean</span> keepDelayed =</span><br><span class="line">        getExecuteExistingDelayedTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="comment">// 获取在线程池已 shutdown 的情况下是否继续执行现有定期任务</span></span><br><span class="line">    <span class="keyword">boolean</span> keepPeriodic =</span><br><span class="line">        getContinueExistingPeriodicTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="comment">// 如果在线程池已 shutdown 的情况下不继续执行延迟任务和定期任务</span></span><br><span class="line">    <span class="comment">// 则依次取消任务，否则则根据取消状态来判断</span></span><br><span class="line">    <span class="keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray())</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)</span><br><span class="line">                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="keyword">false</span>);</span><br><span class="line">        q.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Traverse snapshot to avoid iterator exceptions</span></span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; t =</span><br><span class="line">                    (RunnableScheduledFuture&lt;?&gt;)e;</span><br><span class="line">                <span class="comment">// 如果有在 shutdown 后不继续的延迟任务或周期任务，则从队列中删除并取消任务</span></span><br><span class="line">                <span class="keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||</span><br><span class="line">                    t.isCancelled()) &#123; <span class="comment">// also remove if already cancelled</span></span><br><span class="line">                    <span class="keyword">if</span> (q.remove(t))</span><br><span class="line">                        t.cancel(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h2><p>ScheduledThreadPoolExecutor之所以要自己实现阻塞的工作队列，是因为ScheduledThreadPoolExecutor要求的工作队列有些特殊。</p>
<p>DelayedWorkQueue是一个<strong>基于堆</strong>的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面（<strong>注意：这里的顺序并不是绝对的，堆中的排序只保证了子节点的下次执行时间要比父节点的下次执行时间要大，而叶子节点之间并不一定是顺序的，下文中会说明</strong>）。</p>
<p>堆结构如下图所示：</p>
<img src="00831rSTgy1gcdjerk49tj30vw0n2myh.jpg" alt="QQ20170411-223120.png" style="zoom:50%;" />

<p>可见，DelayedWorkQueue是一个基于最小堆结构的队列。堆结构可以使用数组表示，可以转换成如下的数组：</p>
<p><img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjetb3kyj313q056wej.jpg" alt="QQ20170411-224025@2x.png"></p>
<p>在这种结构中，可以发现有如下特性：</p>
<p>假设，索引值从0开始，子节点的索引值为k，父节点的索引值为p，则：</p>
<ol>
<li> 一个节点的左子节点的索引为：k = p * 2 + 1；</li>
<li> 一个节点的右子节点的索引为：k = (p + 1) * 2；</li>
<li> 一个节点的父节点的索引为：p = (k - 1) / 2。</li>
</ol>
<p><strong>为什么要使用DelayedWorkQueue呢？</strong></p>
<p>定时任务执行时需要取出最近要执行的任务，所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的，所以自然要使用优先级队列。</p>
<p>DelayedWorkQueue是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 *O(logN)*。</p>
<h3 id="DelayedWorkQueue的属性"><a href="#DelayedWorkQueue的属性" class="headerlink" title="DelayedWorkQueue的属性"></a>DelayedWorkQueue的属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 根据初始容量创建RunnableScheduledFuture类型的数组</span></span><br><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =</span><br><span class="line">    <span class="keyword">new</span> RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leader线程</span></span><br><span class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 当较新的任务在队列的头部可用时，或者新线程可能需要成为leader，则通过该条件发出信号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure>

<p>注意这里的leader，它是Leader-Follower模式的变体，用于减少不必要的定时等待。什么意思呢？对于多线程的网络模型来说：</p>
<blockquote>
<p>  所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</p>
</blockquote>
<p><em>参考自：<a href="http://blog.csdn.net/goldlevi/article/details/7705180">http://blog.csdn.net/goldlevi/article/details/7705180</a></em></p>
<p>具体leader的作用在分析take方法时再详细介绍。</p>
<h3 id="offer方法"><a href="#offer方法" class="headerlink" title="offer方法"></a>offer方法</h3><p>既然是阻塞队列，入队的操作如add和put方法都调用了offer方法，下面查看一下offer方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="comment">// queue是一个RunnableScheduledFuture类型的数组，如果容量不够需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow();</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// i == 0 说明堆中还没有数据</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">            setIndex(e, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// i != 0 时，需要对堆进行重新排序</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果传入的任务已经是队列的第一个节点了，这时available需要发出信号</span></span><br><span class="line">        <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">            <span class="comment">// leader设置为null为了使在take方法中的线程在通过available.signal();后会执行available.awaitNanos(delay);</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关Condition的介绍请参考<a href="http://www.ideabuffer.cn/2017/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer%EF%BC%88%E4%B8%89%EF%BC%89/">深入理解AbstractQueuedSynchronizer（三）</a></p>
<p>这里的重点是siftUp方法。</p>
<h3 id="siftUp方法"><a href="#siftUp方法" class="headerlink" title="siftUp方法"></a>siftUp方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到父节点的索引</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取父节点</span></span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; e = queue[parent];</span><br><span class="line">        <span class="comment">// 如果key节点的执行时间大于父节点的执行时间，不需要再排序了</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果key.compareTo(e) &lt; 0，说明key节点的执行时间小于父节点的执行时间，需要把父节点移到后面</span></span><br><span class="line">        queue[k] = e;</span><br><span class="line">        <span class="comment">// 设置索引为k</span></span><br><span class="line">        setIndex(e, k);</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key设置为排序后的位置中</span></span><br><span class="line">    queue[k] = key;</span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很好理解，就是循环的根据key节点与它的父节点来判断，如果key节点的执行时间小于父节点，则将两个节点交换，使执行时间靠前的节点排列在队列的前面。</p>
<p>假设新入队的节点的延迟时间（调用getDelay()方法获得）是5，执行过程如下：</p>
<ol>
<li><p>先将新的节点添加到数组的尾部，这时新节点的索引k为7：</p>
<p> <img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjeyg2epj30vu0ogjt3.jpg" alt="siftup-1.png"></p>
</li>
<li><p>计算新父节点的索引：parent = (k - 1) &gt;&gt;&gt; 1，parent = 3，那么queue[3]的时间间隔值为8，因为 5 &lt; 8 ，将执行queue[7] = queue[3]：</p>
<p> <img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjeuwv86j30vu0ogwg7.jpg" alt="siftup-2.png"></p>
</li>
<li><p>这时将k设置为3，继续循环，再次计算parent为1，queue[1]的时间间隔为3，因为 5 &gt; 3 ，这时退出循环，最终k为3：</p>
<p> <img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjewov0sj30vu0og408.jpg" alt="siftup-3.png"></p>
</li>
</ol>
<p>可见，每次新增节点时，只是根据父节点来判断，而不会影响兄弟节点。</p>
<p>另外，setIndex方法只是设置了ScheduledFutureTask中的heapIndex属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(RunnableScheduledFuture&lt;?&gt; f, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ScheduledFutureTask)</span><br><span class="line">        ((ScheduledFutureTask)f).heapIndex = idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 计算当前时间到执行时间的时间间隔</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">                <span class="comment">// leader不为空，阻塞线程</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// leader为空，则把leader设置为当前线程，</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 阻塞到执行时间</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 设置leader = null，让其他线程执行available.awaitNanos(delay);</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果leader不为空，则说明leader的线程正在执行available.awaitNanos(delay);</span></span><br><span class="line">        <span class="comment">// 如果queue[0] == null，说明队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>take方法是什么时候调用的呢？在<a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/">深入理解Java线程池：ThreadPoolExecutor</a>中，介绍了getTask方法，工作线程会循环地从workQueue中取任务。但定时任务却不同，因为如果一旦getTask方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在take方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。</p>
<p>再来说一下leader的作用，这里的leader是为了减少不必要的定时等待，当一个线程成为leader时，它只等待下一个节点的时间间隔，但其它线程无限期等待。 leader线程必须在从take（）或poll（）返回之前signal其它线程，除非其他线程成为了leader。</p>
<p>举例来说，如果没有leader，那么在执行take时，都要执行<code>available.awaitNanos(delay)</code>，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。多个这时执行该段代码是没有作用的，因为只能有一个线程会从take中返回queue[0]（因为有lock），其他线程这时再返回for循环执行时取的queue[0]，已经不是之前的queue[0]了，然后又要继续阻塞。</p>
<p>所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在finally中调用了signal()来唤醒一个线程，而不是signalAll()）。</p>
<h3 id="poll方法"><a href="#poll方法" class="headerlink" title="poll方法"></a>poll方法</h3><p>下面看下poll方法，与take类似，但这里要提供超时功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="comment">// 如果delay &lt;= 0，说明已经到了任务执行的时间，返回。</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                <span class="comment">// 如果nanos &lt;= 0，说明已经超时，返回null</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">                <span class="comment">// nanos &lt; delay 说明需要等待的时间小于任务要执行的延迟时间</span></span><br><span class="line">                <span class="comment">// leader != null 说明有其它线程正在对任务进行阻塞</span></span><br><span class="line">                <span class="comment">// 这时阻塞当前线程nanos纳秒</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这里的timeLeft表示delay减去实际的等待时间</span></span><br><span class="line">                        <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                        <span class="comment">// 计算剩余的等待时间</span></span><br><span class="line">                        nanos -= delay - timeLeft;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finishPoll方法"><a href="#finishPoll方法" class="headerlink" title="finishPoll方法"></a>finishPoll方法</h3><p>当调用了take或者poll方法能够获取到任务时，会调用该方法进行返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;</span><br><span class="line">    <span class="comment">// 数组长度-1</span></span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="comment">// 取出最后一个节点</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; x = queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 长度不为0，则从第一个元素开始排序，目的是要把最后一个节点放到合适的位置上</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    setIndex(f, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="siftDown方法"><a href="#siftDown方法" class="headerlink" title="siftDown方法"></a>siftDown方法</h3><p>siftDown方法使堆从k开始向下调整：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据二叉树的特性，数组长度除以2，表示取有子节点的索引</span></span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断索引为k的节点是否有子节点</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 左子节点的索引</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; c = queue[child];</span><br><span class="line">        <span class="comment">// 右子节点的索引</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果有右子节点并且左子节点的时间间隔大于右子节点，取时间间隔最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="comment">// 如果key的时间间隔小于等于c的时间间隔，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 设置要移除索引的节点为其子节点</span></span><br><span class="line">        queue[k] = c;</span><br><span class="line">        setIndex(c, k);</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将key放入索引为k的位置</span></span><br><span class="line">    queue[k] = key;</span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>siftDown方法执行时包含两种情况，一种是没有子节点，一种是有子节点（根据half判断）。例如：</p>
<p><strong>没有子节点的情况：</strong></p>
<p>假设初始的堆如下：</p>
<p><img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/QQ20170411-223120.png" alt="QQ20170411-223120.png"></p>
<p>假设 k = 3 ，那么 k = half ，没有子节点，在执行siftDown方法时直接把索引为3的节点设置为数组的最后一个节点：</p>
<p><img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjf3s0iij30vw0n2gn1.jpg" alt="siftdown-1.png"></p>
<p><strong>有子节点的情况：</strong></p>
<p>假设 k = 0 ，那么执行以下步骤：</p>
<ol>
<li><p>获取左子节点，child = 1 ，获取右子节点， right = 2 ：</p>
<p> <img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjex25udj30vu0n20ua.jpg" alt="siftdown-2.png"></p>
</li>
<li><p> 由于 <code>right &lt; size</code> ，这时比较左子节点和右子节点时间间隔的大小，这里 3 &lt; 7 ，所以 c = queue[child] ；</p>
</li>
<li><p>比较key的时间间隔是否小于c的时间间隔，这里不满足，继续执行，把索引为k的节点设置为c，然后将k设置为child，；</p>
<p> <img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjf21fiij30vu0n2jsy.jpg" alt="siftdown-3.png"></p>
</li>
<li><p>因为 half = 3 ，k = 1 ，继续执行循环，这时的索引变为：</p>
<p> <img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjf0cc0nj30vu0n2q4f.jpg" alt="siftdown-4.png"></p>
</li>
<li><p>这时再经过如上判断后，将k的值为3，最终的结果如下：</p>
<p> <img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjexkpa2j30vu0n23zr.jpg" alt="siftdown-6.png"></p>
</li>
<li><p>最后，如果在finishPoll方法中调用的话，会把索引为0的节点的索引设置为-1，表示已经删除了该节点，并且size也减了1，最后的结果如下：</p>
<p> <img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/siftdown-6.png" alt="siftdown-6.png"></p>
</li>
</ol>
<p>可见，siftdown方法在执行完并不是有序的，但可以发现，子节点的下次执行时间一定比父节点的下次执行时间要大，由于每次都会取左子节点和右子节点中下次执行时间最小的节点，所以还是可以保证在take和poll时出队是有序的。</p>
<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = indexOf(x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        setIndex(queue[i], -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            <span class="comment">// 从i开始向下调整</span></span><br><span class="line">            siftDown(i, replacement);</span><br><span class="line">            <span class="comment">// 如果queue[i] == replacement，说明i是叶子节点</span></span><br><span class="line">            <span class="comment">// 如果是这种情况，不能保证子节点的下次执行时间比父节点的大</span></span><br><span class="line">            <span class="comment">// 这时需要进行一次向上调整</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] == replacement)</span><br><span class="line">                siftUp(i, replacement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设初始的堆结构如下：</p>
<p><img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjezfdooj30vu0n2dh3.jpg" alt="remove-1.png"></p>
<p>这时要删除8的节点，那么这时 k = 1，key为最后一个节点：</p>
<p><img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjezzgn3j30vu0n23zu.jpg" alt="remove-2.png"></p>
<p>这时通过上文对siftDown方法的分析，siftDown方法执行后的结果如下：</p>
<p><img src="/2022/08/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/00831rSTgy1gcdjf4ldfej30vu0n0jsk.jpg" alt="remove-3.png"></p>
<p>这时会发现，最后一个节点的值比父节点还要小，所以这里要执行一次siftUp方法来保证子节点的下次执行时间要比父节点的大，所以最终结果如下：</p>
<img src="00831rSTgy1gcdjeyy64qj30vu0n2dh0.jpg" alt="remove-4.png" style="zoom:50%;" />

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本文详细分析了ScheduedThreadPoolExecutor的实现，主要介绍了以下方面：</p>
<ul>
<li>  与Timer执行定时任务的比较，相比Timer，ScheduedThreadPoolExecutor有什么优点；</li>
<li>  ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，所以它也是一个线程池，也有coorPoolSize和workQueue，ScheduledThreadPoolExecutor特殊的地方在于，自己实现了优先工作队列DelayedWorkQueue；</li>
<li>  ScheduedThreadPoolExecutor实现了ScheduledExecutorService，所以就有了任务调度的方法，如schedule，scheduleAtFixedRate和scheduleWithFixedDelay，同时注意他们之间的区别；</li>
<li>  内部类ScheduledFutureTask继承自FutureTask，实现了任务的异步执行并且可以获取返回结果。同时也实现了Delayed接口，可以通过getDelay方法获取将要执行的时间间隔；</li>
<li>  周期任务的执行其实是调用了FutureTask类中的runAndReset方法，每次执行完不设置结果和状态。参考<a href="http://www.ideabuffer.cn/2017/04/06/FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">FutureTask源码解析</a>；</li>
<li>  详细分析了DelayedWorkQueue的数据结构，它是一个基于最小堆结构的优先队列，并且每次出队时能够保证取出的任务是当前队列中下次执行时间最小的任务。同时注意一下优先队列中堆的顺序，堆中的顺序并不是绝对的，但要保证子节点的值要比父节点的值要大，这样就不会影响出队的顺序。</li>
</ul>
<p>总体来说，ScheduedThreadPoolExecutor的重点是要理解下次执行时间的计算，以及优先队列的出队、入队和删除的过程，这两个是理解ScheduedThreadPoolExecutor的关键。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal原理分析 --- 多线程（二）</title>
    <url>/2022/08/07/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>  本文带大家分析下ThreadLocal的原理及常见的问题</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>  <a href="http://www.jasongj.com/java/threadlocal/">主要参考了ThreadLocal的原理部分，就是这篇文章终于让我明白我想错了</a></p>
<p>  <a href="https://my.oschina.net/clopopo/blog/149368">初始化的时候，注意不要保存对象的引用，这样的话拷贝的副本也必然是对象的引用，最终都会改变对象，这样就不对了</a></p>
<p>  <a href="https://www.jianshu.com/p/30ee77732843">ThreadLocal 简述</a></p>
<p>  <a href="https://www.jianshu.com/p/dde92ec37bd1">ThreadLocal 内存泄漏问题</a></p>
<p>  <a href="https://juejin.im/post/5a0e985df265da430e4ebb92">ThreadLocal相关问题！非常有深度！面试之前一定要再看看！！！！！强烈推荐！！！</a></p>
</blockquote>
<h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a>ThreadLocal 简介</h2><ul>
<li><p>ThreadLocal 与线程同步无关。</p>
<p>  ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。对于多线程资源共享的问题，同步机制采用了<strong>“以时间换空间”</strong>的方式，而ThreadLocal采用了“<strong>以空间换时间</strong>”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
</li>
<li><p>  正如上面所言，每个线程都会复制一份 ThreadLocal 的副本，然后线程内部进行使用，所谓的 ThreadLocal就是指 “线程局部变量”。</p>
</li>
</ul>
<h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h2><p>看源码的时候，被 ThreadLocal、ThreadLocalMap、threadLocals 绕晕了，最后终于绕明白了…其实还是自己先入为主的去思考了 ThreadLocal 的实现，最重要的是，<strong>每一个线程都是拥有一个 ThreadLocalMap</strong> 的，为什么要用 Map 而不使用 Pair 呢？因为每个线程可能拥有非常多个 ThreadLocal 变量。再重复一遍，ThreadLocalMap 是从属于每个线程的，每个线程自己管理自己的 map，既然说到这，我就再详细的说一下。</p>
<h3 id="我的想法—-ThreadLocal-维护线程与实例的映射"><a href="#我的想法—-ThreadLocal-维护线程与实例的映射" class="headerlink" title="我的想法—-ThreadLocal 维护线程与实例的映射"></a>我的想法—-ThreadLocal 维护线程与实例的映射</h3><p>因为我看 ThreadLocalMap 是 ThreadLocal 的 内部类，所以以为从属关系是 Map 从属于该变量，那一个可能的方案就是每一个 ThreadLocal 变量都维护一个 ThreadLocalMap，我们都知道，每个访问 ThreadLocal 变量的线程都有自己的一个“本地”实例副本。线程通过该 ThreadLocal 的 get() 方案获取实例时，只需要以线程为键，从 Map 中找出对应的实例即可。该方案如下图所示：</p>
<p><img src="/2022/08/07/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/00831rSTgy1gcc5uxgu0yj31740jmjua.jpg" alt="ThreadLocal side Map"></p>
<p>该方案可满足上文提到的每个线程内一个独立备份的要求。每个新线程访问该 ThreadLocal 时，需要向 Map 中添加一个映射，而<strong>每个线程结束时，应该清除该映射</strong>。这里就有两个问题：</p>
<ul>
<li>  增加线程与减少线程均需要写 Map，故需保证该 Map 线程安全。虽然有几种实现线程安全 Map 的方式，但它或多或少都需要锁来保证线程的安全性。</li>
<li>  <strong>线程结束时，需要保证它所访问的所有 ThreadLocal 中对应的映射均删除，否则可能会引起内存泄漏</strong>。（后文会介绍避免内存泄漏的方法）</li>
</ul>
<p>其中锁的问题，应该是 JDK 未采用该方案的一个原因。</p>
<h3 id="真正的实现—-Thread-维护ThreadLocal与实例的映射"><a href="#真正的实现—-Thread-维护ThreadLocal与实例的映射" class="headerlink" title="真正的实现—-Thread 维护ThreadLocal与实例的映射"></a>真正的实现—-Thread 维护ThreadLocal与实例的映射</h3><p>上述方案中，出现锁的问题，原因在于多线程访问同一个 Map。如果该 Map 由 Thread 维护，从而使得每个 Thread 只访问自己的 Map，那就不存在多线程写的问题，也就不需要锁。该方案如下图所示。</p>
<p><img src="/2022/08/07/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/00831rSTgy1gcc5yy8ppuj312a0n8gov.jpg" alt="ThreadLocal side Map"></p>
<p>该方案虽然没有锁的问题，但是由于每个线程访问某 ThreadLocal 变量后，都会在自己的 Map 内维护该 ThreadLocal 变量与具体实例的映射，如果不删除这些引用（映射），则这些 ThreadLocal 不能被回收，可能会造成内存泄漏。后文会介绍 JDK 如何解决该问题。</p>
<h2 id="ThreadLocal-使用-Demo"><a href="#ThreadLocal-使用-Demo" class="headerlink" title="ThreadLocal 使用 Demo"></a>ThreadLocal 使用 Demo</h2><p>在这里，我们先来使用一下 ThreadLocal，再来分析其源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; sdf = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> DateUtil(<span class="string">&quot;2019-11-25 09:00:&quot;</span> + i % <span class="number">60</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DateUtil</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.date = date;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (sdf.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sdf.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Date date = sdf.get().parse(<span class="keyword">this</span>.date);</span><br><span class="line">                    System.out.println(date);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  注意我们在这里，用的是 private static 修饰的 ThreadLocal，下文有说为何官方推荐这样修饰。</li>
<li>  注意到我们这里使用的方法是 sdf.get()，sdf.set(obj)。</li>
</ul>
<h2 id="ThreadLocal-源码分析"><a href="#ThreadLocal-源码分析" class="headerlink" title="ThreadLocal 源码分析"></a>ThreadLocal 源码分析</h2><p>分析之前，我说一下重点，最核心的当然是 ThreadLocal 中的内部类 ThreadLocalMap，整个底层的实现基本全部依托于该内部类，同时别忘了为了 Thread 和 ThreadLocalMap 一一对应，Thread 了类中有一个成员变量—-threadLocals。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>接下来正式进入源码分析接阶段：</p>
<h3 id="ThreadLocal-部分方法"><a href="#ThreadLocal-部分方法" class="headerlink" title="ThreadLocal 部分方法"></a>ThreadLocal 部分方法</h3><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">     <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">         map.set(<span class="keyword">this</span>, value);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         createMap(t, value);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">     t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>逻辑如下：</p>
<ol>
<li> 通过 getMap() 拿到当前线程对应的 ThreadLocals，注意这里可能有多个 ThreadLocal，所以返回的是一个map；</li>
<li> 如果 map 为空，说明该线程还没有使用过 ThreadLocal 变量，此时就调用 createMap() 新建一个 ThreadLocalMap，这里 map 又出现了，相信大家已经感受到了重要性了。</li>
<li> 如果 map 不为空，我们就把 key = 当前的 ThreadLocal，value 即为当前线程的 ThreadLocal 副本 对应的值。</li>
</ol>
<h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   ThreadLocalMap map = getMap(t);</span><br><span class="line">   <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">       ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">           T result = (T)e.value;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       T value = initialValue();</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>逻辑如下：</p>
<ol>
<li> 通过当前线程拿到 map，然后拿到对应的 key 的 entry，然后返回对应的 value 值。</li>
<li> 如果 map 为空，则 调用 setInitialValue()，调用初始化 ThreadLocal 时的值。</li>
</ol>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒得解释了…还是调用的 ThreadLocalMap 中的 remove() 函数。</p>
<h3 id="ThreadLocalMap（一）"><a href="#ThreadLocalMap（一）" class="headerlink" title="ThreadLocalMap（一）"></a>ThreadLocalMap（一）</h3><p>前面的方法已经铺垫很久了，所有的方法基本都是基于这个类实现的。ThreadLocal 700多行源代码，有500多行都是内部类 ThreadLocalMap。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>必须要说明的是，这里的 map 不同于我们之前介绍的 HashMap、TreeMap等，这里的 map 底层采用的就是只有数组，没有用到红黑树和链表，因为这里解决冲突的方法并不是链地址法，而是开放地址法中的<strong>线性探测</strong>。所以这里数组的基本单元是 Entry。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  Tip: 这里有一个比较特殊的类 WeakReference，也就是弱引用，我们后面会详细介绍这个，因为这个跟内存泄漏有很大的关系。</p>
</blockquote>
<p>然后初始值跟 HashMap 一样，都是 16，但是其装载因子变成了 2/3，装载因子越大，越容易出现冲突的现象，但是装载因子越小，就越浪费空间，我们可以看到，这里的装载因子是比 HashMap 要小的，所以这里更不容易产生冲突，这也是采用开放地址法的原因吧。</p>
<p>现在来分析一下主要的函数：</p>
<h4 id="set-1"><a href="#set-1" class="headerlink" title="set()"></a>set()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//这里有一段英文注释，意思是不会像 get() 一样，直接去找，成功了就返回，没成功就再调用另外一个函数</span></span><br><span class="line">  	<span class="comment">// 因为 set()大概率是失败的多，所以就直接写在一个函数内了。</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">//根据threadLocal的hashCode确定Entry应该存放的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//采用开放地址法，hash冲突的时候使用线性探测</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">//覆盖旧Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当key为null时，说明threadLocal强引用已经被释放掉，那么就无法</span></span><br><span class="line">        <span class="comment">//再通过这个key获取threadLocalMap中对应的entry，这里就存在内存泄漏的可能性</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//用当前插入的值替换掉这个key为null的“脏”entry</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建entry并插入table中i处</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">//插入后再次清除一些key为null的“脏”entry,如果大于阈值就需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑如下：</p>
<ol>
<li> 先确定 ThreadLocal 所在的位置；</li>
<li> 然后采用线性探测法，确定位置；</li>
<li> 如果存在该 ThreadLocal，那么直接覆盖就好了；如果为 null，说明该 ThreadLocal的强引用已经消失，此时直接在该位置插入即可；如果不存在，那么就新建一个 Entry，插入，最后再次清楚 脏entry，并判断是否需要扩容。「后面会详细讲专门处理脏 entry 的这几个方法」</li>
</ol>
<h4 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry()"></a>getEntry()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 确定在散列数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//2. 根据索引i获取entry</span></span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">//3. 满足条件则返回该entry</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//4. 未查找到满足条件的entry，额外在做的处理</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">copyprivate Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="comment">//找到和查询的key相同的entry则返回</span></span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//解决脏entry的问题</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//继续向后环形查找</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Double the capacity of the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="comment">//新数组为原数组的2倍</span></span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">//遍历过程中如果遇到脏entry的话直接另value为null,有助于value能够被回收</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//重新确定entry在新数组的位置，然后进行插入</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新哈希表的threshHold和size属性</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容还是非常简单的，因为不涉及多线程，而且只用到数组，整体逻辑如下：</p>
<ol>
<li> new 一个原来容量两倍的数组；</li>
<li> 遇到了脏 entry，就将其 value 置为 null，方便 GC，如果 key != null，就重新计算 entry 在新数组的位置；</li>
<li> 然后插入，如果有冲突就线性探测就好了；</li>
<li> 最后更新 threshold、size、table就好啦。</li>
</ol>
<h4 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">//将entry的key置为null</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">//将该entry的value也置为null</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也很简单，就不说了，就跟上面的一样，在这疯狂用 expungeStaleEntry()！！！</p>
<h3 id="ThreadLocalMap（二）"><a href="#ThreadLocalMap（二）" class="headerlink" title="ThreadLocalMap（二）"></a>ThreadLocalMap（二）</h3><p>这里单独开一小节，讲 ThreadLocalMap中是如何处理脏 entry 的，也就是 key == null 的键值对，这样会导致内存泄漏，所以必须处理。</p>
<h4 id="cleanSomeSlots"><a href="#cleanSomeSlots" class="headerlink" title="cleanSomeSlots()"></a>cleanSomeSlots()</h4><p>可以看到，核心依旧是 expungeStaleEntry()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清除部分 脏entry</span></span><br><span class="line"><span class="comment">// 启发式的扫描过期数据并擦除，启发式是这样的：</span></span><br><span class="line"><span class="comment">// 如果实在没有过期数据，那么这个算法的时间复杂度就是O(log s)</span></span><br><span class="line"><span class="comment">// 如果有过期数据，那么这个算法的时间复杂度就是O(log n)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">      	<span class="comment">// 如果 entry 不为空，且entry中的key指向的是 null</span></span><br><span class="line">      	<span class="comment">// 说明产生了 脏entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);	</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体逻辑如下：</p>
<ol>
<li> 从插入的entry索引的后一位开始检测是否有 脏entry；</li>
<li> 先n == size，log n 去检测，如果发现有脏entry，立即加大n = length，然后从下一个哈希桶为 null 的索引位置 i 继续 log n 检测；</li>
<li> 最后返回是否有修改。</li>
</ol>
<h4 id="expungeStaleEntry"><a href="#expungeStaleEntry" class="headerlink" title="expungeStaleEntry()"></a>expungeStaleEntry()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class="line"><span class="comment"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class="line"><span class="comment"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class="line"><span class="comment"> * Knuth, Section 6.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span></span><br><span class="line"><span class="comment"> * (all between staleSlot and this slot will have been checked</span></span><br><span class="line"><span class="comment"> * for expunging).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除当前脏entry</span></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//2.往后环形继续查找,直到遇到table[i]==null时结束</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">//3. 如果在向后搜索过程中再次遇到脏entry，同样将其清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//处理rehash的情况</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法逻辑请看注释（第1,2,3步），主要做了这么几件事情：</p>
<ol>
<li> 清理当前脏entry，即将其value引用置为null，并且将table[staleSlot]也置为null。value置为null后该value域变为不可达，在下一次gc的时候就会被回收掉，同时table[staleSlot]为null后以便于存放新的entry;</li>
<li> 从当前staleSlot位置向后环形（nextIndex）继续搜索，直到遇到哈希桶（tab[i]）为null的时候退出；</li>
<li> 若在搜索过程再次遇到脏entry，继续将其清除。</li>
</ol>
<p>也就是说该方法，<strong>清理掉当前脏entry后，并没有闲下来继续向后搜索，若再次遇到脏entry继续将其清理，直到哈希桶（table[i]）为null时退出</strong>。因此方法执行完的结果为 <strong>从当前脏entry（staleSlot）位到返回的i位，这中间所有的entry不是脏entry</strong>。为什么是遇到null退出呢？原因是存在脏entry的前提条件是 <strong>当前哈希桶（table[i]）不为null</strong>,只是该entry的key域为null。如果遇到哈希桶为null,很显然它连成为脏entry的前提条件都不具备。</p>
<p>cleanSomeSlot方法主要有这样几点：</p>
<ol>
<li> 从当前位置i处（位于i处的entry一定不是脏entry）为起点在初始小范围（log2(n)，n为哈希表已插入entry的个数size）开始向后搜索脏entry，若在整个搜索过程没有脏entry，方法结束退出</li>
<li> 如果在搜索过程中遇到脏entryt通过expungeStaleEntry方法清理掉当前脏entry，并且该方法会返回下一个哈希桶(table[i])为null的索引位置为i。这时重新令搜索起点为索引位置i，n为哈希表的长度len，再次扩大搜索范围为log2(n)继续搜索。</li>
</ol>
<p>下面，以一个例子更清晰的来说一下，假设当前table数组的情况如下图。</p>
<p><img src="/2022/08/07/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/00831rSTgy1gcd21mceyyj30kh08cq34.jpg" alt="img"></p>
<ol>
<li> 如图当前n等于hash表的size即n=10，i=1,在第一趟搜索过程中通过nextIndex,i指向了索引为2的位置，此时table[2]为null，说明第一趟未发现脏entry,则第一趟结束进行第二趟的搜索。</li>
<li> 第二趟所搜先通过nextIndex方法，索引由2的位置变成了i=3,当前table[3]!=null但是该entry的key为null，说明找到了一个脏entry，<strong>先将n置为哈希表的长度len,然后继续调用expungeStaleEntry方法</strong>，该方法会将当前索引为3的脏entry给清除掉（令value为null，并且table[3]也为null）,但是<strong>该方法可不想偷懒，它会继续往后环形搜索</strong>，往后会发现索引为4,5的位置的entry同样为脏entry，索引为6的位置的entry不是脏entry保持不变，直至i=7的时候此处table[7]位null，该方法就以i=7返回。至此，第二趟搜索结束；</li>
<li> 由于在第二趟搜索中发现脏entry，n增大为数组的长度len，因此扩大搜索范围（增大循环次数）继续向后环形搜索；</li>
<li> 直到在整个搜索范围里都未发现脏entry，cleanSomeSlot方法执行结束退出。</li>
</ol>
<h4 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry()"></a>replaceStaleEntry()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param  key the key</span></span><br><span class="line"><span class="comment"> * @param  value the value to be associated with key</span></span><br><span class="line"><span class="comment"> * @param  staleSlot index of the first stale entry encountered while</span></span><br><span class="line"><span class="comment"> *         searching for key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向前找到第一个脏entry</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">1.</span>          slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果在向后环形查找过程中发现key相同的entry就覆盖并且和脏entry进行交换</span></span><br><span class="line"><span class="number">2.</span>            e.value = value;</span><br><span class="line"><span class="number">3.</span>            tab[i] = tab[staleSlot];</span><br><span class="line"><span class="number">4.</span>            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="comment">//如果在查找过程中还未发现脏entry，那么就以当前位置作为cleanSomeSlots</span></span><br><span class="line">            <span class="comment">//的起点</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line"><span class="number">5.</span>                slotToExpunge = i;</span><br><span class="line">            <span class="comment">//搜索脏entry并进行清理</span></span><br><span class="line"><span class="number">6.</span>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">        <span class="comment">//如果向前未搜索到脏entry，则在查找过程遇到脏entry的话，后面就以此时这个位置</span></span><br><span class="line">        <span class="comment">//作为起点执行cleanSomeSlots</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line"><span class="number">7.</span>            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    <span class="comment">//如果在查找过程中没有找到可以覆盖的entry，则将新的entry插入在脏entry</span></span><br><span class="line"><span class="number">8.</span>    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">9.</span>    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line"><span class="number">10.</span>    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        <span class="comment">//执行cleanSomeSlots</span></span><br><span class="line"><span class="number">11.</span>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个有点复杂，暂时就不去掌握了…只需要知道这个函数用当前插入的值替换掉这个key为null的“脏”entry，并且并不局限于如此，还把附近所有可能是脏entry都清理了，应该算是整个 ThreadLocal中最为复杂的函数了。</p>
<h3 id="ThreadLocalMap-与-HashMap-的部分区别"><a href="#ThreadLocalMap-与-HashMap-的部分区别" class="headerlink" title="ThreadLocalMap 与 HashMap 的部分区别"></a>ThreadLocalMap 与 HashMap 的部分区别</h3><ul>
<li>  解决冲突的方式不一样。一个使用的是开放地址法，一个是链地址法；</li>
<li>  默认装载因子不同。ThreadLocalMap 2/3，HashMap 0.75；</li>
<li>  ThreadLocalMap 没有扰动函数，直接就是相与(也就是取模的过程)，而 HashMap 有高16位与低16位相与进行扰动；</li>
</ul>
<p>扩容和初始容量都是一样的，初始16，然后扩容都是两倍。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><blockquote>
<p>  <a href="https://blog.csdn.net/luoyeyeyu/article/details/85621663">四大引用的概念</a></p>
</blockquote>
<p>Q：弱引用的概念</p>
<p>A：四大引用。强引用、弱引用、软引用、幻想引用。弱引用通过WeakReference类实现。 <strong>弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</strong>由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>Q：这里的key对ThreadLocal为弱引用的作用，如果使用强引用呢？</p>
<p>A：这里的 key 对 ThreadLocal 采用弱引用，是为了减少内存泄漏的发生。当 ThreadLocal 强引用全部消失时，Entry 中的 key 会变为 null，但此时 value 还是被 map 持有强引用，此时 entry 就是可能会造成内存泄漏，不可用但是可达，无法 gc，针对这个问题，THreadLocalMap中可以调用 set()、get()、remove()等方法都会触发 expungeStaleEntry机制，将脏 entry清除掉防止内存泄漏。如果像以前使用了强引用，那么当对象使用完 ThreadLocal 变量，ThreadLocal由于一直被 key 持有强引用，无法回收，并且该 Entry 也过期了，导致更大的内存泄漏，并且此时无法通过 expungeStaleEntry机制解决该问题。<strong>至于造成内存泄漏的原因，根本在于 ThreadLocalMap 和 Thread 拥有同样长的生命周期。</strong></p>
<p>重要的事情说三遍！用完ThreadLocal最后一定要 remove()、remove()、remove()。</p>
<p>Q：Entry、value 使用弱引用，是什么效果？</p>
<p>A：Entry定义为弱引用：<strong>当GC回收后，无法区分是原本就没有写入还是被回收了，后续线性探测的修补也无法完成。</strong></p>
<p>value定义为弱引用：似乎也是个不错的方法，为啥没这么做？<strong>因为这么做和将key定义为弱引用基本没区别，仍然可以依赖弱引用机制清理，但通常在我们的使用中不会持有value的强引用，只会持有key即ThreadLocal对象的强引用，而value没有强引用的情况下会被GC回收，与我们期望的功能不符。</strong></p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><blockquote>
<p>  主要参考网址：<a href="https://juejin.im/post/5d75ebf451882576c478a102">https://juejin.im/post/5d75ebf451882576c478a102</a></p>
</blockquote>
<p>这应该是 ThreadLocal 最难的部分了，网上查阅了几百篇文章，基本上把所有有关的 ThreadLocal 内存泄漏的文章都看了一遍…只有这一篇比较欣赏，剩下的基本上全部是在互相抄…好多地方解释的也不通…接下来希望自己能把这个讲通吧…</p>
<h4 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h4><p>对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。<br>在Java中，<strong>内存泄漏</strong>就是存在一些被分配的对象，这些对象有下面两个特点，<strong>首先</strong>，这些对象是可达的，即<strong>在有向图中，存在通路可以与其相连</strong>；<strong>其次</strong>，<strong>这些对象是无用的，即程序以后不会再使用这些对象</strong>。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>
<h4 id="ThreadLocal-什么时候会发生内存泄漏"><a href="#ThreadLocal-什么时候会发生内存泄漏" class="headerlink" title="ThreadLocal 什么时候会发生内存泄漏"></a>ThreadLocal 什么时候会发生内存泄漏</h4><p>我个人倾向于将其分为两类：</p>
<h5 id="当-ThreadLocal-变量不使用-static-修饰"><a href="#当-ThreadLocal-变量不使用-static-修饰" class="headerlink" title="当 ThreadLocal 变量不使用 static 修饰"></a>当 ThreadLocal 变量不使用 static 修饰</h5><p>当 ThreadLocal 变量不使用 static 修饰，那么 ThreadLocal 的强引用就很有可能全部消失「什么时候会消失？？ 这个翻了整个互联网都没见到…」，而 ThreadLocalMap 中的 key 对 ThreadLocal 的引用是弱引用，根据 GC 规则，ThreadLocal 变量会被回收，此时 ThreadLocaMap 对应的 key 会自动变为 null，而 此时的 Entry 和 value 又被 ThreadLocalMap 强引用，即不可能会被GC，所以此时就造成了内存泄漏，解决的方法就是显示的调用 set()、get()、remove()「当然调用 set()、get() 也不一定能解决内存泄漏问题，因为这两个方法可能在没碰到脏 entry就结束循环了」等方法，因为其可以调用 expungeStaleEntry() 将这些 key 为 null 的键值对回收。当然了，如果线程会结束，那最终也不会发生内存泄漏啦，线程死了那肯定就自动清理 map 了。</p>
<p>Q：回到上面那个问题，什么时候强引用会消失？</p>
<p>A：我参考的网址终于有了一个例子。强引用是<strong>对应的子线程或主线程中某个对象</strong>持有的，<strong>对象生命周期结束</strong>或<strong>对象替换指向这个key的引用</strong>后，key的强引用也就断了。对，就是对象生命周期结束，强引用就消失了。</p>
<p>eg：假如我现在有一个主线程，然后我调用了 A，创建了 A 的实例对象 a1，a1 调用了 ThreadLocal 变量，此时对象 a1 是有对 ThreadLocal 的强引用的，此时 ThreadLocalMap 中的 key还不会为 null ，当主线程调用了 a = null，该对象生命周期结束，此时强引用消失了，但是 ThreadLocalMap 中的 value 还是强引用，无法 GC，也就是上面的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Context&gt; local = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Context ctx = ...</span></span><br><span class="line">        local.set(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  	A a = <span class="keyword">new</span> A();</span><br><span class="line">  	a.doSth();</span><br><span class="line">  	a = <span class="keyword">null</span>; <span class="comment">// 或者直接 finalize();</span></span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">  	doSometing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="当-ThreadLocal-变量使用了-static-修饰"><a href="#当-ThreadLocal-变量使用了-static-修饰" class="headerlink" title="当 ThreadLocal 变量使用了 static 修饰"></a>当 ThreadLocal 变量使用了 static 修饰</h5><p>当 ThreadLocal 变量使用了 static 修饰，说明该变量的生命周期和类一样的，只要引用不改变，那么该变量会一直持有强引用（强引用上面已经讲了），那么此时 key 对 ThreadLocal 持有弱引用我个人觉得就没有任何意义了，因为是不可能触发 expungeStaleEntry() 的，因为 key 不会变为 null。那么此时是不是就不会出现内存泄漏了呢？<strong>不，依旧会出现。</strong>其实此时如果我们正常使用，是不会产生内存泄漏的，但是一旦我们使用的是线程池，线程使用完之后不会回收，而我们之前使用的 ThreadLocalMap 又存在很多过期的 value 需要清理，此时就算 key 是弱引用，也没有办法，因为 ThreadLocal 一直持有强引用根本不会触发 GC，此时就产生了内存泄漏。</p>
<p>举个例子：</p>
<ol>
<li> 线程1和线程2都用了threadLocal1和threadLocal2，且设置了value</li>
<li> 线程1使用完毕归还线程池，但没有调用threadLocal1.remove()</li>
<li> 之后线程1不再使用threadLocal1了，仅使用threadLocal2</li>
<li> 线程1的threadLocalMap中仍然保存了obj1</li>
<li> 由于静态变量threadLocal1引用仍然可达，不会被回收，线程1无法触发expungeStaleEntry机制，threadLocal1对应的entry和value无法回收，造成了内存泄漏</li>
</ol>
<blockquote>
<p>  所以用private static修饰之后，好处就是仅使用有限的ThreadLocal对象以节约创建对象和后续自动回收的开销，坏处是需要我们手动调用remove方法清理使用完的slot，否则会有内存泄漏问题。</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>  <a href="https://juejin.im/post/5a0e985df265da430e4ebb92#heading-2">https://juejin.im/post/5a0e985df265da430e4ebb92#heading-2</a></p>
<p>  <a href="https://zhuanlan.zhihu.com/p/91756169">https://zhuanlan.zhihu.com/p/91756169</a></p>
</blockquote>
<p>Q1：ThreadLocal 跟普通局部变量有何区别，在其内部使用局部变量不是一样的吗？</p>
<p>A1：网上有两种说法。</p>
<ol>
<li><p> 该实例需要在多个方法中共享，但不希望被多线程共享，此时可以使用 ThreadLocal，这样使得代码耦合度更低，无需在每个方法中都去声明一个局部变量，简而言之，就是做到线程间隔离，线程内共享。我个人觉得这种说法有些过于牵强，但是貌似网上基本都是这种说法…</p>
</li>
<li><p>我觉得 ThreadLocal 相比局部变量而言，其实也就是 全局变量 和 局部变量 的区别。虽然每个线程的 ThreadLocal 副本互不影响，但是我可以通过 ThreadLocal 进行通信，这是局部变量所不具备的能力。举个例子，假设要设计这么一个程序：三个线程同时从0数到10，一旦有一个线程数到了10，三个线程都从0重新开始数，一直这么循环。用run创建局部变量的方式就没法做，因为每一个线程之间是完全独立的。</p>
<p> ThreadLocal保存共享变量的副本，用于特定的使用场景。看源码就知道ThreadLocal类是基于Thread类来实现的，如果直接用继承Thread来实现上面的功能也是可以的，只不过JDK都已经给封装好了，自己能想到的思路估计跟ThreadLocal的实现思路差不多。如果场景适合使用ThreadLocal，为何不直接用呢。</p>
<p> 所以，线程间可通信且可以做到互不影响，我觉得这才是 ThreadLocal 真正存在的意义吧。</p>
</li>
</ol>
<p>Q2：既然 ThreadMap 从属于每个线程，那为何不把 ThreadLocalMap 放到 Thread 类中，反而是成为了 ThreadLocal 的内部类？</p>
<p>A2：其实我觉得都是可以的，不管放到 Thread 类中，还是放到 ThreadLocal 中，都是可以解决问题的，但是我觉得作者这样设计，主要是因为在之前 ThreadLocalMap 是从属于 ThreadLocal 的，可能后来考虑到我上文提到的需要加锁还有线程结束带来的 ThreadLocal 的内存泄漏问题，改成了 ThreadLocalMap 从属于 Thread，为了最大限度的不改动代码，只在 Thread 中添加了一个成员变量 <code>ThreadLocal.ThreadLocalMap threadLocals</code>，并且这样设计的话，用户层面去调用 api 的时候根本不会发现 ThreadLocalMap 的存在，设计的还是非常优美的！</p>
<p>Q3：为何官方建议定义 ThreadLocal 时 采用 private static 修饰？</p>
<p>A3：可以避免重复创建TSO(Thread Specific Object，即与线程相关的变量)，如果把 ThreadLocal 声明为某个类的实例变量（而不是静态变量），那么每创建一个该类的实例就会导致一个新的TSO实例被创建。显然，这些被创建的TSO实例是没有任何意义的。既然所有的线程用到的 ThreadLocal 都是一样的，那么很明显设计成 static 是很正常的，不以对象为出发点，而以整个类为出发点就好了。</p>
<blockquote>
<p>  所以用private static修饰之后，好处就是仅使用有限的ThreadLocal对象以节约创建对象和后续自动回收的开销，坏处是需要我们手动调用remove方法清理使用完的slot，否则会有内存泄漏问题。</p>
</blockquote>
<p>Q4：ThreadLocal 的用途？</p>
<p>A4：</p>
<ol>
<li>线程间隔离，线程内通信，解决相同变量在多线程环境下的冲突问题，例如：<ul>
<li>hibernate中的session使用；<ul>
<li>  <strong>spring中单例bean的多线程访问</strong>。我们知道在一般情况下，只有无状态的<code>Bean</code>才可以在多线程环境下共享，在<code>Spring</code>中，绝大部分<code>Bean</code>都可以声明为<code>singleton</code>作用域。就是因为<code>Spring</code>对一些<code>Bean</code>（如<code>RequestContextHolder</code>、<code>TransactionSynchronizationManager</code>、<code>LocaleContextHolder</code>等）中非线程安全状态采用<code>ThreadLocal</code>进行处理，让它们也成为线程安全的状态，有状态的<code>Bean</code>就可以在多线程中共享了；</li>
<li>  <strong>以及 spring 如何保证数据库事务在同一个连接下执行的</strong>。DataSourceTransactionManager 是spring的数据源事务管理器， 它会在你调用getConnection()的时候从数据库连接池中获取一个connection， 然后将其与ThreadLocal绑定， 事务完成后解除绑定。这样就保证了事务在同一连接下完成。</li>
</ul>
</li>
</ul>
</li>
<li> 可以用于线程间通信，比如三个线程都用到了 ThreadLocal，只要有一个达到了目标值，我就全部设为初值，这是可以通过 ThreadLocal直接完成的。</li>
</ol>
<p>Q5：ThreadLocal 和 Synchronized 区别？</p>
<p>A5：<code>ThreadLocal</code>和<code>synchronized</code>关键字都用于处理多线程并发访问变量的问题，只是二者处理问题的角度和思路不同。</p>
<ol>
<li> <code>ThreadLocal</code>是一个Java类,通过<strong>对当前线程中的局部变量的操作来解决不同线程的变量访问的冲突问题</strong>。所以，<code>ThreadLocal</code>提供了线程安全的共享对象机制，每个线程都拥有其副本。</li>
<li> Java中的<code>synchronized</code>是一个保留字，它依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性。在<strong>同步机制</strong>中，通过对象的锁机制保证同一时间只有一个线程访问变量。此时，被用作“锁机制”的变量时多个线程共享的。</li>
<li> 同步机制(<code>synchronized</code>关键字)采用了以“<strong>时间换空间</strong>”的方式，提供一份变量，让不同的线程排队访问。而<code>ThreadLocal</code>采用了“<strong>以空间换时间</strong>”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。</li>
</ol>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Threadlocal原理</tag>
      </tags>
  </entry>
  <entry>
    <title>锁&amp;关键字 --- 多线程（一）</title>
    <url>/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>  本文详细的介绍了Java中的各种锁概念以及其原理</p>
</blockquote>
<span id="more"></span>

<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul>
<li>  NEW（刚刚创建线程）</li>
<li>  RUNNABLE（Ready + Running ，调用start方法为ready，获取到cpu时间片开始执行为running）</li>
<li>  BLOCKED（Synchronized获取锁失败）</li>
<li>  WAITING（wait、join、await、park）</li>
<li>  TIMED_WAITING（带超时时间的方法）</li>
<li>  TERMINATED（线程执行完毕）</li>
</ul>
<h2 id="创建线程的三种方式"><a href="#创建线程的三种方式" class="headerlink" title="创建线程的三种方式"></a>创建线程的三种方式</h2><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><ul>
<li>  继承 Thread 类并重写 run 方法</li>
<li>  创建线程对象</li>
<li>  调用该线程对象的 start() 方法来启动线程</li>
</ul>
<p>*<strong>demo*</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadTest().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><ul>
<li>  当然也可以直接实现内部类，然后重写 run() 方法，然后适当的可以用 lamda 表达式</li>
</ul>
<p>*<strong>demo*</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// new ThreadTest().start();</span></span><br><span class="line">    <span class="comment">// 2. 直接继承 Thread 类</span></span><br><span class="line">    Thread threadC = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;3.1 get resource c&quot;</span>);</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    threadC.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><h4 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h4><ul>
<li>  定义一个类实现 Runnable 接口，并重写该接口的 run() 方法</li>
<li>  创建 Runnable 实现类的对象，作为创建 Thread 对象的 target 参数，***此 Thread 对象才是真正的线程对象***，这个跟继承 Thread 不一样，第一种方式是直接 Thread 的实现类就是真正的线程对象，而实现 Runnable 接口得对象在这里并不是真正的线程对象。</li>
<li>  调用线程对象的 start() 方法来启动线程</li>
</ul>
<p>*<strong>demo*</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableTest runnableTest = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnableTest, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnableTest, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h4><ul>
<li>  直接实现匿名内部类就行了，跟方式一中的方法二一样</li>
</ul>
<p>*<strong>demo*</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        RunnableTest runnableTest = new RunnableTest();</span></span><br><span class="line"><span class="comment">//        new Thread(runnableTest, &quot;线程1&quot;).start();</span></span><br><span class="line"><span class="comment">//        new Thread(runnableTest, &quot;线程2&quot;).start();</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这里是实现 Runnable 接口的线程&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><p>上述两种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。于是java后面又增加了 Callable 和 Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p>
<h4 id="Runnable-和-Callable"><a href="#Runnable-和-Callable" class="headerlink" title="Runnable 和 Callable"></a>Runnable 和 Callable</h4><ul>
<li>  Runnable 只是一个接口，里面只是声明了一个run方法，可以看到方法的返回值是void，所以线程执行完了没有任何的返回值。</li>
<li>  Callable 也是一个接口，它里面声明了一个call方法，可以看到它是一个泛型接口，call()函数返回的类型就是传递进来的V类型。线程的执行是异步的，一个线程和另外一个线程的执行是互不干扰的，所以你不可能从别的线程中获得返回值，所以要想获得Callable的返回值就需要用到Future这个接口，Futrue可以监视目标线程调用call的情况，当你*<strong>调用Future的get()方法以获得结果时，当前线程就开始阻塞，直到call方法结束返回结果。*</strong></li>
<li>总而言之，就是三点：<ul>
<li>  Runnable 调用 run方法，Callable 调用 call 方法；</li>
<li>  Runnable不能有返回值，但是 Callable可以返回一个Future对象；</li>
<li>  Runnable不可以抛出异常，但是 Callable 可以抛出异常。</li>
</ul>
</li>
</ul>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a><strong>Future</strong></h4><p>Future 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们讲解下这五个方法的作用：</p>
<p><strong>cancel方法</strong>：用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</p>
<p><strong>isCancelled方法</strong>：表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true</p>
<p><strong>isDone方法</strong>：表示任务是否已经完成，若任务完成，则返回true</p>
<p><strong>get()方法</strong>：用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回。这里的阻塞需要解释一下，阻塞的是当前调用get方法的线程，直到get方法返回结果才能继续向下执行，如果get方法一直没有返回值，那么当前线程会一直阻塞下去</p>
<p><strong>get(long timeout, TimeUnit unit)方法</strong>：获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null，这个就避免了一直获取不到结果使得当前线程一直阻塞的情况发生</p>
<p>也就是说Future提供了三种功能：</p>
<p>　　<strong>1）判断任务是否完成；</strong></p>
<p>　　<strong>2）能够中断任务；</strong></p>
<p>　　<strong>3）能够获取任务执行结果。</strong></p>
<p>因为Future只是一个接口，所以是<strong>无法直接用来创建对象使用</strong>的，因此就有了下面的 FutureTask。</p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a><strong>FutureTask</strong></h4><p>我们先来看一下 FutureTask 的类图：</p>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/007S8ZIlly1gi22313toqj30hu0jkmxo.jpg" alt="image-20200206183630930"></p>
<p>可以看出 RunnableFuture 继承了 Runnable 接口和 Future 接口，而 FutureTask 实现了 RunnableFuture 接口。所以它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>  <strong>ExecutorService &amp; Future &amp; Callable</strong></li>
</ul>
<p>第一种方式是使用继承了<code>ExecutorService</code>的线程池<code>ThreadPoolExecutor</code>中的<code>submit</code>方法，将<code>Callable</code>直接提交创建<code>Future</code>。</p>
<p><strong>demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ExecutorService &amp; Callable</span></span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">// 或者用这个</span></span><br><span class="line"><span class="comment">//        ExecutorService service = Executors.newCachedThreadPool();</span></span><br><span class="line">        Future&lt;String&gt; future = service.submit((Callable) () -&gt; <span class="string">&quot;通过实现Callable接口&quot;</span>);</span><br><span class="line">        System.out.println(future.isDone());</span><br><span class="line">        service.shutdown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = future.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            System.out.println(future.isDone());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>ExecutorService &amp; futureTask &amp; Callable</strong></li>
</ul>
<p>第二种方式就是使用 futureTask，具体看 demo 吧</p>
<p><strong>demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// FutureTask &amp; Callable</span></span><br><span class="line">        CallableTest callableTest = <span class="keyword">new</span> CallableTest();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callableTest);</span><br><span class="line">        <span class="comment">// futureTask 可以采用两种方式运行线程</span></span><br><span class="line">        <span class="comment">// 1. 直接new Thread</span></span><br><span class="line"><span class="comment">//        new Thread(futureTask).start();</span></span><br><span class="line">        <span class="comment">// 2. 将FutureTask 对象放入 executorService 中</span></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        service.submit(futureTask);</span><br><span class="line">        service.shutdown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程的返回值: &quot;</span> + futureTask.get(<span class="number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running: &quot;</span> + sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>futureTask &amp; Callable</strong></li>
</ul>
<p>因为 futureTask 实现了 run() 方法，所以可以直接 new Thread 启动。</p>
<p><strong>demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// FutureTask &amp; Callable</span></span><br><span class="line">        CallableTest callableTest = <span class="keyword">new</span> CallableTest();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callableTest);</span><br><span class="line">        <span class="comment">// futureTask 可以采用两种方式运行线程</span></span><br><span class="line">        <span class="comment">// 1. 直接new Thread</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="comment">// 2. 将FutureTask 对象放入 executorService 中</span></span><br><span class="line"><span class="comment">//        ExecutorService service = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">//        service.submit(futureTask);</span></span><br><span class="line"><span class="comment">//        service.shutdown();</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程的返回值: &quot;</span> + futureTask.get(<span class="number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running: &quot;</span> + sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三种方式的比较"><a href="#三种方式的比较" class="headerlink" title="三种方式的比较"></a>三种方式的比较</h3><p><strong>1.实现Runnable/Callable接口相比继承Thread类的优势</strong></p>
<p>（1）适合多个线程进行资源共享</p>
<p>（2）可以避免java中单继承的限制</p>
<p>（3）增加程序的健壮性，代码和数据独立</p>
<p>（4）线程池只能放入 Runable 或 Callable 接口实现类，不能直接放入继承 Thread 的类</p>
<p><strong>2.Callable和Runnable的区别</strong></p>
<p> (1) Callable 重写的是 call() 方法， Runnable 重写的方法是 run() 方法</p>
<p> (2) call() 方法执行后可以有返回值，run() 方法没有返回值</p>
<p> (3) call() 方法可以抛出异常，run() 方法不可以</p>
<p> (4) 运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果 。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果</p>
<blockquote>
<p>  <a href="https://zhuanlan.zhihu.com/p/88933756">https://zhuanlan.zhihu.com/p/88933756</a></p>
<p>  <a href="https://juejin.im/post/5ae6cf7a518825670960fcc2">https://juejin.im/post/5ae6cf7a518825670960fcc2</a></p>
</blockquote>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><blockquote>
<p>  <a href="https://juejin.im/post/594a24defe88c2006aa01f1c#comment">超详细例子讲述 Synchronized</a></p>
<p>  <a href="https://blog.csdn.net/pengweid/article/details/85711970">形象讲述对象锁和类锁区别</a></p>
<p>  <a href="https://juejin.im/post/5ae6dc04f265da0ba351d3ff#heading-6">Synchronized</a></p>
</blockquote>
<ul>
<li><p>  主要是类锁和对象锁的区别</p>
</li>
<li><p>  <strong>synchronized特点：</strong>保证内存可见性、操作原子性</p>
</li>
<li><p>  <strong>synchronized影响性能的原因</strong>：</p>
</li>
<li><ul>
<li>  1、加锁解锁操作需要额外操作；</li>
<li>  2、互斥同步对性能最大的影响是阻塞的实现，因为阻塞涉及到的挂起线程和恢复线程的操作都需要转入内核态中完成（用户态与内核态的切换的性能代价是比较大的）</li>
</ul>
</li>
<li><p>  <strong>synchronized锁</strong>：对象头中的Mark Word根据锁标志位的不同而被复用</p>
</li>
<li><ul>
<li>  偏向锁：在只有一个线程执行同步块时提高性能。Mark Word存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单比较ThreadID。特点：只有等到线程竞争出现才释放偏向锁，持有偏向锁的线程不会主动释放偏向锁。之后的线程竞争偏向锁，会先检查持有偏向锁的线程是否存活，如果不存货，则对象变为无锁状态，重新偏向；如果仍存活，则偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁</li>
<li>  轻量级锁：在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象目前的Mark Word到栈帧的Lock Record，若拷贝成功：虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向对象的Mark Word。若拷贝失败：若当前只有一个等待线程，则可通过自旋稍微等待一下，可能持有轻量级锁的线程很快就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁</li>
<li>  重量级锁：指向互斥量（mutex），底层通过操作系统的mutex lock实现。等待锁的线程会被阻塞，由于Linux下Java线程与操作系统内核态线程一一映射，所以涉及到用户态和内核态的切换、操作系统内核态中的线程的阻塞和恢复。</li>
</ul>
</li>
</ul>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><blockquote>
<p>  <a href="https://www.bilibili.com/video/av74879168?from=search&seid=17412342529771517829">volatile可见性原理底层分析（视频）</a></p>
</blockquote>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gbuysx2ssgj31jq0u0zyj.jpg" alt="image-20200213184715267"></p>
<blockquote>
<p>  <a href="https://juejin.im/post/5ae9b41b518825670b33e6c4">https://juejin.im/post/5ae9b41b518825670b33e6c4</a></p>
<p>  <a href="https://www.infoq.cn/article/java-memory-model-4/">https://www.infoq.cn/article/java-memory-model-4/</a></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">是否能重排序</th>
<th align="left">第二个操作</th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">第一个操作</td>
<td align="left">普通读 / 写</td>
<td align="left">volatile 读</td>
<td align="left">volatile 写</td>
</tr>
<tr>
<td align="left">普通读 / 写</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">NO</td>
</tr>
<tr>
<td align="left">volatile 读</td>
<td align="left">NO</td>
<td align="left">NO</td>
<td align="left">NO</td>
</tr>
<tr>
<td align="left">volatile 写</td>
<td align="left"></td>
<td align="left">NO</td>
<td align="left">NO(</td>
</tr>
</tbody></table>
<p>从上表我们可以看出：</p>
<ul>
<li>  当第二个操作是 volatile 写时，不管第一个操作是什么，都不能重排序。这个规则确保 volatile 写之前的操作不会被编译器重排序到 volatile 写之后。</li>
<li>  当第一个操作是 volatile 读时，不管第二个操作是什么，都不能重排序。这个规则确保 volatile 读之后的操作不会被编译器重排序到 volatile 读之前。</li>
<li>  当第一个操作是 volatile 写，第二个操作是 volatile 读时，不能重排序。</li>
</ul>
<p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM 采取保守策略。下面是基于保守策略的 JMM 内存屏障插入策略：</p>
<ul>
<li>  在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>
<li>  在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。(可以允许普通)</li>
<li>  在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li>
<li>  在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>
</ul>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的 volatile 内存语义。</p>
<p>下面是保守策略下，volatile 写插入内存屏障后生成的指令序列示意图：</p>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gbw09wrzk0j30dh08paa2.jpg" alt="img"></p>
<p>上图中的 StoreStore 屏障可以保证在 volatile 写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为 StoreStore 屏障将保障上面所有的普通写在 volatile 写之前刷新到主内存。</p>
<p>这里比较有意思的是 volatile 写后面的 StoreLoad 屏障。这个屏障的作用是避免 volatile 写与后面可能有的 volatile 读 / 写操作重排序。因为编译器常常无法准确判断在一个 volatile 写的后面，是否需要插入一个 StoreLoad 屏障（比如，一个 volatile 写之后方法立即 return）。为了保证能正确实现 volatile 的内存语义，JMM 在这里采取了保守策略：在每个 volatile 写的后面或在每个 volatile 读的前面插入一个 StoreLoad 屏障。从整体执行效率的角度考虑，JMM 选择了在每个 volatile 写的后面插入一个 StoreLoad 屏障。因为 volatile 写 - 读内存语义的常见使用模式是：一个写线程写 volatile 变量，多个读线程读同一个 volatile 变量。当读线程的数量大大超过写线程时，选择在 volatile 写之后插入 StoreLoad 屏障将带来可观的执行效率的提升。从这里我们可以看到 JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<p>下面是在保守策略下，volatile 读插入内存屏障后生成的指令序列示意图：</p>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gbw0b7tsxdj30dw08iq2y.jpg" alt="img"></p>
<p>上图中的 LoadLoad 屏障用来禁止处理器把上面的 volatile 读与下面的普通读重排序。LoadStore 屏障用来禁止处理器把上面的 volatile 读与下面的普通写重排序。</p>
<p>上述 volatile 写和 volatile 读的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile 写 - 读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面我们通过具体的示例代码来说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = v1;           <span class="comment">// 第一个 volatile 读 </span></span><br><span class="line">        <span class="keyword">int</span> j = v2;           <span class="comment">// 第二个 volatile 读 </span></span><br><span class="line">        a = i + j;            <span class="comment">// 普通写 </span></span><br><span class="line">        v1 = i + <span class="number">1</span>;          <span class="comment">// 第一个 volatile 写 </span></span><br><span class="line">        v2 = j * <span class="number">2</span>;          <span class="comment">// 第二个 volatile 写 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …                    <span class="comment">// 其他方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对 readAndWrite() 方法，编译器在生成字节码时可以做如下的优化：</p>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gbw0rbwumej30dn0cxgm6.jpg" alt="img"></p>
<p>注意，最后的 StoreLoad 屏障不能省略。因为第二个 volatile 写之后，方法立即 return。此时编译器可能无法准确断定后面是否会有 volatile 读或写，为了安全起见，编译器常常会在这里插入一个 StoreLoad 屏障。</p>
<p>上面的优化是针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以 x86 处理器为例，上图中除最后的 StoreLoad 屏障外，其它的屏障都会被省略。</p>
<p>前面保守策略下的 volatile 读和写，在 x86 处理器平台可以优化成：</p>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gbw0rskwrcj30dh07s0so.jpg" alt="img"></p>
<p>前文提到过，x86 处理器仅***会对写 - 读操作做重排序***。X86 不会对读 - 读，读 - 写和写 - 写操作做重排序，因此在 x86 处理器中会省略掉这三种操作类型对应的内存屏障。在 x86 中，JMM 仅需在 volatile 写后面插入一个 StoreLoad 屏障即可正确实现 volatile 写 - 读的内存语义。这意味着在 x86 处理器中，volatile 写的开销比 volatile 读的开销会大很多（因为执行 StoreLoad 屏障开销会比较大）。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><blockquote>
<p>  <a href="https://juejin.im/post/5bd4507c5188254c0d0150a5#heading-7">AQS源码分析—独占模式&amp;共享模式</a></p>
<p>  <a href="https://juejin.im/post/5cce69a0f265da03ba0e3d5b">AQS分析一</a>、<a href="https://juejin.im/post/5cd2b58f6fb9a032332b45aa">AQS分析二</a></p>
<p>  <a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">美团团队：从ReentrantLock的实现看AQS的原理及应用</a></p>
</blockquote>
<p>全称是 AbstractQueuedSynchronizer（抽象队列同步器），是通过一个先进先出的队列（存储等待的线程）来实现同步器的一个框架，Lock、ReentrantLock、Semaphore 等等都是基于 AQS 实现的。</p>
<h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gc5dsdj4jej30vh0scdlz.jpg" alt="img"></p>
<ul>
<li>  上图中有颜色的为Method，无颜色的为Attribution。</li>
<li>  总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li>
<li>  当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li>
</ul>
<p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：</p>
<p><a href="https://tva1.sinaimg.cn/large/0082zybpgy1gc5edolv0sj31u108lmyx.jpg"><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gc5edolv0sj31u108lmyx.jpg" alt="AQS 原理概述"></a></p>
<p><a href="https://tva1.sinaimg.cn/large/0082zybpgy1gc5edolv0sj31u108lmyx.jpg">AQS 原理概述</a></p>
<h3 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h3><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，***就需要一定的阻塞等待唤醒机制来保证锁分配***。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gc5el1qcbej30ix051aa8.jpg" alt="img"></p>
<p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
<p>AQS 的结构大概可总结为以下 3 部分：</p>
<ol>
<li> <strong>用 volatile 修饰的整数类型的 state 状态，用于表示同步状态，提供 getState 和 setState 来操作同步状态；</strong></li>
<li> <strong>提供了一个 FIFO 等待队列，实现线程间的竞争和等待，这是 AQS 的核心；</strong></li>
<li> <strong>AQS 内部提供了各种基于 CAS 原子操作方法，如 compareAndSetState 方法，并且提供了锁操作的acquire和release方法。</strong></li>
</ol>
<h3 id="数据结构-amp-重要变量和类"><a href="#数据结构-amp-重要变量和类" class="headerlink" title="数据结构 &amp; 重要变量和类"></a>数据结构 &amp; 重要变量和类</h3><p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gc5enu4f0xj31aj05djry.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AQS等待队列的头结点，AQS的等待队列是基于一个双向链表来实现的，这个头结点并不包含具体的线程是一个空结点（注意不是null）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">//AQS等待队列的尾部结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="comment">//AQS同步器状态，也可以说是锁的状态，注意volatile修饰证明这个变量状态要对多线程可见</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">copystatic <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="comment">//下面两个属性都是说明这个结点是共享模式还是独占模式</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//下面这四个属性就是说明结点的状态</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;<span class="comment">//由于超时或中断，节点已被取消</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;<span class="comment">//表示下一个节点是通过park阻塞的，需要通过unpark唤醒</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;<span class="comment">//表示线程在等待条件变量（先获取锁，加入到条件等待队列，然后释放锁，等待条件变量满足条件；只有重新获取锁之 后才能返回）</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;<span class="comment">//表示后续结点会传播唤醒的操作，共享模式下起作用</span></span><br><span class="line">     <span class="comment">//当前节点在队列中的状态，就是上述几个数值</span></span><br><span class="line">     <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">     <span class="comment">//前驱结点（双链表）</span></span><br><span class="line">     <span class="keyword">volatile</span> Node prev;</span><br><span class="line">     <span class="comment">//后继结点（双链表）</span></span><br><span class="line">     <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//  结点所包装的线程</span></span><br><span class="line">     <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">   <span class="comment">// 对于Condtion表示下一个等待条件变量的节点</span></span><br><span class="line">   <span class="comment">// 其它情况下用于是区分共享模式和独占模式</span></span><br><span class="line">     Node nextWaiter;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//取得前驱结点</span></span><br><span class="line">     <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">         Node p = prev;</span><br><span class="line">         <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">             <span class="comment">//null的时候抛出异常</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Node() &#123;  </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Node(Thread thread, Node mode) &#123;  </span><br><span class="line">         <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">         <span class="keyword">this</span>.thread = thread;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">         <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">         <span class="keyword">this</span>.thread = thread;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="两种锁模式"><a href="#两种锁模式" class="headerlink" title="两种锁模式"></a>两种锁模式</h4><p>AQS支持两种锁一种是独占锁（独占模式），一种是共享锁（共享模式）</p>
<ul>
<li>  独占锁：比如像ReentrantLock就是一种独占锁模式，多个线程去同时抢一个锁，只有一个线程能抢到这个锁，其他线程就只能阻塞等待锁被释放后重新竞争锁。</li>
<li>  共享锁：比如像读写锁里面的读锁，一个锁可以同时被多个线程拥有（多个线程可以同时拥有读锁），再比如Semaphore 设置一个资源数目（可以理解为一个锁能同时被多少个线程拥有）。</li>
</ul>
<p>共享锁跟独占锁可以同时存在，比如读写锁，读锁、写锁分别对应共享锁和独占锁</p>
<h4 id="队列节点状态"><a href="#队列节点状态" class="headerlink" title="队列节点状态"></a>队列节点状态</h4><p>队列中的 Node，有一个 waitStatus，用来表示该节点对应的线程状态。</p>
<ul>
<li>  CANCELLED = 1；取消状态，如果当前线程的 *<strong>前置节点*</strong> 状态为 CANCELLED，则表明前置节点已经等待超时或者已经被中断了，这时需要将其从等待队列中删除。</li>
<li>  SIGNAL = -1；等待触发状态，如果当前线程的 *<strong>前置节点*</strong> 状态为 SIGNAL，则表明当前线程需要阻塞。</li>
<li>  CONDITION = -2；用于 condition，也就是线程间通信，类似于 Synchronized 中的 wait/notify 机制，在 Lock 中是用 condition 来完成的， waitStatus = -2 表示该线程在进队列之前就已经获取到了锁，然后再加入到条件等待队列中，然后释放锁资源，等到条件满足了，就再次获取锁，然后进行线程相应的操作。</li>
<li>  PROPAGATE = -3；状态需要向后传播，表示 releaseShared 需要被传播给后续节点，仅在共享锁模式下使用。</li>
</ul>
<p>可以这么理解：head 节点可以表示成当前持有锁的线程的节点，其余线程竞争锁失败后，会加入到队尾，tail 始终指向队列的最后一个节点。</p>
<h3 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h3><p><strong>独占锁的原理是如果有线程获取到锁，那么其它线程只能是获取锁失败，然后进入等待队列中等待被唤醒。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放锁方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 AQS 中并没有提供获取锁和释放锁的方法，需要实现类自己去实现这两个方法，在这里只是抛出了异常而已。</p>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码解读：</p>
<ol>
<li> <strong>通过 tryAcquire(arg) 方法尝试获取锁，这个方法需要实现类自己实现获取锁的逻辑，获取锁成功后则不执行后面加入等待队列的逻辑了；</strong></li>
<li> <strong>如果尝试获取锁失败后，则执行 addWaiter(Node.EXCLUSIVE) 方法将当前线程封装成一个 Node 节点对象，并加入队列尾部；</strong></li>
<li> <strong>把当前线程执行封装成 Node 节点后，继续执行 acquireQueued 的逻辑，该逻辑主要是判断当前节点的前置节点是否是头节点，来尝试获取锁，如果获取锁成功，则当前节点就会成为新的头节点，这也是获取锁的核心逻辑。</strong></li>
</ol>
<p>继续看 addWaiter(Node.EXCLUSIVE)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个基于当前线程的节点，该节点是 Node.EXCLUSIVE 独占式类型</span></span><br><span class="line">  <span class="comment">// 注意这里的构造函数，第二个参数就是 NextWaiter，用来区分是共享模式还是独占模式</span></span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">  <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">  Node pred = tail;</span><br><span class="line">  <span class="comment">// 这里先判断队尾是否为空，如果不为空则直接将节点加入队尾</span></span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node.prev = pred;</span><br><span class="line">    <span class="comment">// 这里必须采用 CAS，因为可能有多个线程加入同时加入到队尾</span></span><br><span class="line">    <span class="comment">// 采取 CAS 操作，将当前节点设置为队尾节点，由于采用了 CAS 原子操作，无论并发怎么修改，都有且只有一条线程可以修改成功，其余都将执行后面的enq方法</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">      pred.next = node;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  enq(node);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说 addWaiter(Node mode) 方法做了以下事情：</p>
<ol>
<li> 创建基于当前线程的独占式类型的节点；</li>
<li> 利用 CAS 原子操作，将节点加入队尾。</li>
</ol>
<p>我们继续看 enq(Node node) 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 自旋操作</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="comment">// 如果队尾节点为空，那么进行CAS操作初始化队列</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里很关键，即如果队列为空，那么此时必须初始化队列，初始化一个空的节点表示队列头，用于表示当前正在执行的节点，头节点即表示当前正在运行的节点</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">        tail = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.prev = t;</span><br><span class="line">      <span class="comment">// 这一步也是采取CAS操作，将当前节点加入队尾，如果失败的话，自旋继续修改直到成功为止</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">        t.next = node;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enq(Node node)主要做了三件事：</p>
<ol>
<li> 采用了自旋机制，没成功就一直循环进行</li>
<li> 若队尾节点为空，就先初始化队列，然后因为自旋，再在 head 节点后将当前节点加入队尾</li>
<li> 若对尾结点不为空，则采取 CAS ，将当前节点加入队尾</li>
<li> <strong>注意返回值是当前节点的 pred 节点</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 线程中断标记字段</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 获取当前节点的 pred 节点</span></span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="comment">// 如果 pred 节点为 head 节点，那么再次尝试获取锁</span></span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        <span class="comment">// 获取锁之后，那么当前节点也就成为了 head 节点</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 不需要挂起，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取锁失败，则进入挂起逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquireQueued 主要做了两件事：</p>
<ol>
<li> 判断当前节点的 pred 节点是否是 head 节点，如果是，说明下一个执行的线程就是该线程，所以就可以去尝试获取锁（自旋的过程），如果获取了锁，就将当前节点置为 head；</li>
<li> 获取锁如果失败了，就得进入挂起逻辑，即进入 shouldParkAfterFailedAcquire(p, node)。</li>
</ol>
<p>接下来我们继续看挂起逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">// 如果 pred 节点为 SIGNAL 状态，返回true，说明当前节点需要挂起</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 如果ws &gt; 0,说明节点状态为CANCELLED，需要从队列中删除</span></span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是其它状态，则操作CAS统一改成SIGNAL状态</span></span><br><span class="line">    <span class="comment">// 由于这里waitStatus的值只能是0或者PROPAGATE，所以我们将节点设置为SIGNAL，重新循环一次判断</span></span><br><span class="line">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shouldParkAfterFailedAcquire(Node pred, Node node) 主要做了三件事：</p>
<ol>
<li> 判断当前节点的 pred 的 waitStatus 是否为 SIGNAL，如果是，则说明当前节点可以挂起；</li>
<li> 如果不是 SIGNAL 状态，若是 CANCELLED 状态，则需要将该节点从队列中删除；</li>
<li> 否则，需要将该节点的前置节点置为 SIGNAL，再从 acquireQueued 方法自旋操作循环一次判断。</li>
</ol>
<p><strong>通俗来说就是：根据 pred 节点状态来判断当前节点是否可以挂起，如果该方法返回 false，那么挂起条件还没准备好，就会重新进入 acquireQueued(final Node node, int arg) 的自旋体，重新进行判断。如果返回 true，那就说明当前线程可以进行挂起操作了，那么就会继续执行挂起。</strong></p>
<p>继续看挂起逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LockSupport 是用来创建锁和其他同步类的基本<strong>线程阻塞</strong>原语。LockSupport 提供 park() 和 unpark() 方法实现阻塞线程和解除线程阻塞。release 释放锁方法逻辑会调用 LockSupport.unPark 方法来唤醒后继节点。</p>
<p>最后看一下 cancelAcquire()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将无效节点过滤</span></span><br><span class="line">	<span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 设置该节点不关联任何线程，也就是虚节点</span></span><br><span class="line">	node.thread = <span class="keyword">null</span>;</span><br><span class="line">	Node pred = node.prev;</span><br><span class="line">  <span class="comment">// 通过前驱节点，跳过取消状态的node</span></span><br><span class="line">	<span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">		node.prev = pred = pred.prev;</span><br><span class="line">  <span class="comment">// 获取过滤后的前驱节点的后继节点</span></span><br><span class="line">	Node predNext = pred.next;</span><br><span class="line">  <span class="comment">// 把当前node的状态设置为CANCELLED</span></span><br><span class="line">	node.waitStatus = Node.CANCELLED;</span><br><span class="line">  <span class="comment">// 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span></span><br><span class="line">  <span class="comment">// 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span></span><br><span class="line">	<span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">		compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> ws;</span><br><span class="line">    <span class="comment">// 如果当前节点不是head的后继节点</span></span><br><span class="line">    <span class="comment">//1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span></span><br><span class="line">    <span class="comment">// 如果1和2中有一个为true，再判断当前节点的线程是否为null</span></span><br><span class="line">    <span class="comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span></span><br><span class="line">		<span class="keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Node next = node.next;</span><br><span class="line">			<span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">				compareAndSetNext(pred, predNext, next);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span></span><br><span class="line">			unparkSuccessor(node);</span><br><span class="line">		&#125;</span><br><span class="line">		node.next = node; <span class="comment">// help GC</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  具体可参考： <a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p>
</blockquote>
<p>***整体逻辑图如下***：</p>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gc7ldw14z1j30u010o74z.jpg" alt="img"></p>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">      unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路还是很好理解的，先尝试释放锁，这个 tryRelease() 需要自己实现，如果头结点不为空，且 waitStatus != 0 （因为 addWaiter 方法默认的节点状态为 0，为 0 说明此时节点还没有进入就绪状态），就可以执行唤醒下个节点的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 将头节点的状态设置为0</span></span><br><span class="line">    <span class="comment">// 这里会尝试清除头节点的状态，改为初始状态</span></span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 后继节点</span></span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="comment">// 如果后继节点为null，或者已经被取消了</span></span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// for循环从队列尾部一直往前找可以唤醒的节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">      <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 唤醒后继节点</span></span><br><span class="line">    LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unparkSuccessor(Node node) 主要做了二件事：</p>
<ol>
<li> 将头结点的 waitStatus 置为初始状态 0 ；</li>
<li> 找后继节点，如果后继节点是 null 或者 waitStatus = Node.Cancelled，就直接从队尾开始向前遍历，找到最靠近头结点的下一个符合条件的节点，并将其唤醒。</li>
</ol>
<h3 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h3><h4 id="获取锁-1"><a href="#获取锁-1" class="headerlink" title="获取锁"></a>获取锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试获取共享锁，小于0表示获取失败</span></span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 执行获取锁失败的逻辑</span></span><br><span class="line">    doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟独占模式差不多， tryAcquireShared() 需要实现类自己去实现，这里只要 &gt;=0 说明共享锁的资源还有，就说明获取锁成功，否则就执行获取锁失败的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 添加共享锁类型节点到队列中</span></span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        <span class="comment">// 再次尝试获取共享锁</span></span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">        <span class="comment">// 如果在这里成功获取共享锁，会进入共享锁唤醒逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 共享锁唤醒逻辑</span></span><br><span class="line">          setHeadAndPropagate(node, r);</span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 与独占锁相同的挂起逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟独占锁基本一样的逻辑，也是先将该线程包装成 Node，加入队尾，然后不断自旋，判断当前节点的前置节点是否为 head，如果是 head，就尝试获取锁，当然这里有一个不同的地方，那就是原来的 <code>setHead()</code> 变成了 <code>setHeadAndPropagate()</code>，因为这里不仅要将获取到锁的节点置为头结点，同时只要共享锁还拥有资源，就需要去唤醒后续共享锁节点。下面我们具体看看 <code>setHeadAndPropagate(node, r)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 头节点</span></span><br><span class="line">  Node h = head; </span><br><span class="line">  <span class="comment">// 设置当前节点为新的头节点</span></span><br><span class="line">  <span class="comment">// 这里不需要加锁操作，因为获取共享锁后，会从FIFO队列中依次唤醒队列，并不会产生并发安全问题</span></span><br><span class="line">  setHead(node);</span><br><span class="line">  <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">      (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果后继节点为空或者后继节点为共享类型，则进行唤醒后继节点</span></span><br><span class="line">    <span class="comment">// 这里后继节点为空意思是只剩下当前头节点了</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">      doReleaseShared();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了两件事：</p>
<ol>
<li> 将当前节点置为 head，这个跟独占锁是一样的；</li>
<li> 寻找后续的共享锁线程，然后将其唤醒。</li>
</ol>
<p>我们注意到，这里唤醒调用的是 doReleaseShared()，也就是说释放共享锁也是调用的这个方法，那么是怎么做到唤醒多个拥有共享锁线程呢？我们注意到首先是将当前获取到锁的线程置为 head，然后只要还有资源，就唤醒该线程，</p>
<h4 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 由用户自行实现释放锁条件</span></span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    <span class="comment">// 执行释放锁</span></span><br><span class="line">    doReleaseShared();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">copyprivate <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 从头节点开始执行唤醒操作</span></span><br><span class="line">    <span class="comment">// 这里需要注意，如果从setHeadAndPropagate方法调用该方法，那么这里的head是新的头节点</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">      <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">      <span class="comment">//表示后继节点需要被唤醒</span></span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">        <span class="comment">// 初始化节点状态</span></span><br><span class="line">        <span class="comment">//这里需要CAS原子操作，因为setHeadAndPropagate和releaseShared这两个方法都会顶用doReleaseShared，避免两次unpark唤醒操作</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">          <span class="comment">// 如果初始化节点状态失败，继续循环执行</span></span><br><span class="line">          <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">        <span class="comment">// 执行唤醒操作</span></span><br><span class="line">        <span class="comment">// 注意这里是唤醒头结点的下一个节点</span></span><br><span class="line">        <span class="comment">// 唤醒了下一个节点之后，下一个节点就会去尝试获取锁，形成一个循环</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里个人认为是为 setHeadAndPropagate()中 s == null准备的，当只有头结点的时候</span></span><br><span class="line">      <span class="comment">// 后继节点没有所以不需要唤醒，但是我们必须把这种可传递的状态显示表现出来</span></span><br><span class="line">      <span class="comment">// 确保后续可以传递给后继节点</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">        <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果在唤醒的过程中头节点没有更改，退出循环</span></span><br><span class="line">    <span class="comment">// 这里防止其它线程又设置了头节点，说明其它线程获取了共享锁，会继续循环操作</span></span><br><span class="line">    <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：上面的setHeadAndPropagate()方法表示等待队列中的线程成功获取到共享锁，这时候它需要调用doReleaseShared() 唤醒它后面的共享节点（如果有），但是当通过 releaseShared() 方法去调用doReleaseShared() 释放一个共享锁的时候，接下来等待独占锁跟共享锁的线程都可以被唤醒进行尝试获取。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gc7r1vr15ij30u018odi5.jpg" alt="img"></p>
<p>获取锁的过程：</p>
<ol>
<li> 当线程调用acquireShared()申请获取锁资源时，如果成功，则进入临界区。</li>
<li> 当获取锁失败时，则创建一个共享类型的节点并进入一个FIFO等待队列，然后被挂起等待唤醒。</li>
<li> 当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则<strong>唤醒后面还在等待的共享节点并把该唤醒事件传递下去，即会依次唤醒在该节点后面的所有共享节点</strong>，然后进入临界区，否则继续挂起等待。</li>
</ol>
<p>释放锁过程：</p>
<ol>
<li> 当线程调用releaseShared()进行锁资源释放时，如果释放成功，则唤醒队列中等待的节点，如果有的话。</li>
</ol>
<h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a><strong>比较</strong></h5><p>跟独占锁相比，共享锁的主要特征在于当一个在等待队列中的共享节点成功获取到锁以后（它获取到的是共享锁），既然是共享，那它必须要依次唤醒后面所有可以跟它一起共享当前锁资源的节点，毫无疑问，这些节点必须也是在等待共享锁（这是大前提，如果等待的是独占锁，那前面已经有一个共享节点获取锁了，它肯定是获取不到的）。当共享锁被释放的时候，可以用读写锁为例进行思考，当一个读锁被释放，此时不论是读锁还是写锁都是可以竞争资源的。</p>
<blockquote>
<p>  <a href="https://juejin.im/post/5cd2b58f6fb9a032332b45aa">https://juejin.im/post/5cd2b58f6fb9a032332b45aa</a></p>
<p>  <a href="https://www.cnblogs.com/lfls/p/7599863.html">https://www.cnblogs.com/lfls/p/7599863.html</a></p>
</blockquote>
<h3 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h3><p>Q：某个线程获取锁失败的后续流程是什么呢？</p>
<p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>
<p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>
<p>A：是CLH变体的FIFO双端队列。</p>
<p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>
<p>A：当前节点的前置节点为 head，可以尝试获取锁。</p>
<p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p>
<p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放。</p>
<p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p>
<p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p>
<p>Tip: 自我实现一个锁，利用 AQS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.Concurrent包理解;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AQS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutexDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Mutex mutex = <span class="keyword">new</span> Mutex();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                mutex.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Current Thread:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our internal helper class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Reports whether in locked state</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Provides a Condition</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deserializes properly 反序列化</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><blockquote>
<p>  <a href="https://juejin.im/post/5aeb0a8b518825673a2066f0">可重入性、公平与非公平</a></p>
<p>  <a href="https://blog.csdn.net/qq838642798/article/details/65441415">ReentranLock的特点</a></p>
</blockquote>
<p>重点还是：</p>
<ol>
<li> 可重入性的实现</li>
<li> 公平锁和非公平锁的区别</li>
</ol>
<p>其他的基本上就是 AQS 的独占锁实现而已</p>
<h3 id="可重入性的实现"><a href="#可重入性的实现" class="headerlink" title="可重入性的实现"></a>可重入性的实现</h3><p>在可重入性方面，个人觉得还是针对于同一把锁而言的，不同锁去谈重入性没有意义，但是有个特例，就是 ReentrantReadWriteLock，因为其 ReadLock 和 WriteLock 是属于同一把大锁下的两把小锁，它们之间的重入性有些特殊，也就是同一把写锁肯定是可以重入的，同一把读锁肯定也是可以重入的，但是注意的是读锁下不可重入写锁，因为读-写互斥，但是有个锁降级，也就是 写锁可以重入读锁，将写锁降级为读锁（先获取写锁，然后获取读锁，然后释放写锁，然后再释放读锁）。</p>
<p>言归正传，不同锁的 ReentrantLock，之间不会有影响， 类似于下面的 demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.Concurrent包理解;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                lock1.lock();</span><br><span class="line">                lock2.lock();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;current:&quot;</span> + Thread.currentThread().getName() );</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock2.unlock();</span><br><span class="line">                    lock1.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以非公平锁为例，看看可重入的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//1. 如果该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//2.若被占有，检查占有线程是否是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">		<span class="comment">// 3. 再次获取，计数加一</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">copyprotected <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 同步状态减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//2. 只有当同步状态为0时，锁成功被释放，返回true</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 3. 锁未被完全释放，返回false</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>ReentrantLock支持两种锁：<strong>公平锁</strong>和<strong>非公平锁</strong>。<strong>何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO</strong>。ReentrantLock的构造方法无参时是构造非公平锁，源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外还提供了另外一种方式，可传入一个boolean值，true时为公平锁，false时为非公平锁，源码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面非公平锁获取时（nonfairTryAcquire方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看公平锁的处理逻辑是怎样的，核心方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是多了一个方法 hasQueuedPredecessors()，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。<strong>公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁</strong>。</p>
<blockquote>
<p>  <strong>公平锁 VS 非公平锁</strong></p>
</blockquote>
<ol>
<li> 公平锁每次获取到锁为同步队列中的第一个节点，<strong>保证请求资源时间上的绝对顺序</strong>，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，<strong>造成“饥饿”现象</strong>。</li>
<li> 公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，<strong>保证了系统更大的吞吐量</strong>。</li>
</ol>
<h3 id="与-Synchronized-的区别"><a href="#与-Synchronized-的区别" class="headerlink" title="与 Synchronized 的区别"></a>与 Synchronized 的区别</h3><h4 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h4><p>从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<h4 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h4><p>Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</p>
<h4 id="性能的区别"><a href="#性能的区别" class="headerlink" title="性能的区别"></a>性能的区别</h4><p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>
<h4 id="功能区别"><a href="#功能区别" class="headerlink" title="功能区别"></a>功能区别</h4><p>便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p>
<p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p>
<h4 id="ReenTrantLock独有的能力"><a href="#ReenTrantLock独有的能力" class="headerlink" title="ReenTrantLock独有的能力"></a>ReenTrantLock独有的能力</h4><ol>
<li> ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li>
<li> ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</li>
<li> ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</li>
</ol>
<h4 id="ReenTrantLock实现的原理"><a href="#ReenTrantLock实现的原理" class="headerlink" title="ReenTrantLock实现的原理"></a>ReenTrantLock实现的原理</h4><p>简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>
<h4 id="什么情况下使用ReenTrantLock"><a href="#什么情况下使用ReenTrantLock" class="headerlink" title="什么情况下使用ReenTrantLock"></a>什么情况下使用ReenTrantLock</h4><p>答案是，如果你需要实现ReenTrantLock的三个独有功能时。</p>
<blockquote>
<p>  ————————————————<br>  版权声明：本文为CSDN博主「qq838642798」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>  原文链接：<a href="https://blog.csdn.net/qq838642798/article/details/65441415">https://blog.csdn.net/qq838642798/article/details/65441415</a></p>
</blockquote>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><blockquote>
<p>  <a href="https://www.jianshu.com/p/6221746fc777">写锁—-真的是写的超棒！</a></p>
<p>  <a href="https://www.jianshu.com/p/cd485e16456e">读锁—-不说了太赞了！！关注这个作者</a></p>
<p>  <a href="https://segmentfault.com/q/1010000009659039">锁降级问题</a></p>
</blockquote>
<p>这个才是完整继承了 AQS 基本所有方法的实现类，因为它不像 ReentrantLock 只有独占锁，它可以同时拥有独占锁和共享锁，并且这两个锁还有一些额外的限制，也就是 写-读互斥(当然锁降级除外)，写-写互斥，读-读共享。所以这个很有必要详细说一下。</p>
<p>主要还是三个特点：</p>
<ol>
<li> <strong>公平性选择</strong>：支持非公平性（默认）和公平的锁获取方式，吞吐量还是非公平优于公平；</li>
<li> <strong>重入性</strong>：支持重入，读锁获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁；</li>
<li> <strong>锁降级</strong>：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁</li>
</ol>
<p>要弄清楚上述三个特点，就得解决以下几个问题：</p>
<ol>
<li> 写锁和读锁是如何记录读写状态的；</li>
<li> 写锁是如何获取和释放的；</li>
<li> 读锁是如何获取和释放的；</li>
<li> 锁降级的规则是什么。</li>
</ol>
<h3 id="读写锁如何记录状态"><a href="#读写锁如何记录状态" class="headerlink" title="读写锁如何记录状态"></a>读写锁如何记录状态</h3><p>之前都是用 state 这个变量来记录锁的获取情况，这里也是一样，但是这里比较特殊，使用了(Integer 32位)低 16 位来存储写锁的获取情况，高 16 位用来存储读锁的获取情况。</p>
<h3 id="写锁的获取和释放"><a href="#写锁的获取和释放" class="headerlink" title="写锁的获取和释放"></a>写锁的获取和释放</h3><p>写锁由于是独占锁，并且不能锁升级（也就是不允许读锁内嵌套写锁），所以也就比较简单了。</p>
<h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire()"></a>tryAcquire()</h4><p>写锁独占锁，所以需要实现的就是 AQS 中的 tryAcquire()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy// 如果有读锁，此时是获取不到写锁的。当有写锁时，判断重入次数。</span><br><span class="line">// 当写锁空闲，读锁空闲，公平模式下，如果队列中有等待的，不会抢锁。非公平模式下，必抢锁。</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    // 写</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 用 state &amp; 65535 得到低 16 位的值。</span><br><span class="line">    int w = exclusiveCount(c);</span><br><span class="line">    if (c != 0) &#123;</span><br><span class="line">        // (Note: if c != 0 and w == 0 then shared count != 0)</span><br><span class="line">        // 如果 state 不是0，且低16位是0，说明了什么？说明写锁是空闲的，读锁被霸占了。那么也不能拿锁，返回 fasle。</span><br><span class="line">        // 如果低 16 位不是0，说明写锁被霸占了，并且，如果持有锁的不是当前线程，那么这次拿锁是失败的。返回 fasle。</span><br><span class="line">        // 总之，当只有读锁时，就不能获取写锁。当有写锁，可能是写锁降级，也可能是正常的拥有写锁，此时就					// 必须是重入锁。</span><br><span class="line">        if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">            return false;</span><br><span class="line">        // 到这一步了，只会是写重入锁。如果写重入次数超过最大值 65535，就会溢出。</span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        // Reentrant acquire</span><br><span class="line">        // 将 state  + 1</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当 state 是 0 的时候，那么就可以获取锁了。</span><br><span class="line">    // writerShouldBlock 判断是否需要锁。非公平情况下，返回 false。公平情况下，根据 hasQueuedPredecessors 结果判断。</span><br><span class="line">    // 当队列中有锁等待了，就返回 false 了。</span><br><span class="line">    // 当是非公平锁的时候，或者队列中没有等待节点的时候，尝试用 CAS 修改 state。</span><br><span class="line">    if (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        return false;</span><br><span class="line">    // 修改成功 state 后，修改锁的持有线程。</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br></pre></td></tr></table></figure>

<p>最难理解的就是<code>if (w == 0 || current != getExclusiveOwnerThread())</code> 这一步，具体的流程分析如下图：</p>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gc9rl59jmxj31400u0gnu.jpg" alt="ReentrantReadWriteLock_tryAcquired"></p>
<h4 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease()"></a>tryRelease()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否持有当前锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 计算 state 值</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="comment">// 计算写锁的状态，如果是0，说明是否成功。</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 释放成功，设置持有锁的线程为 null。</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 设置 state</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还是很简单的，只是有一个地方需要注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算写锁的状态，如果是0，说明是否成功。</span></span><br><span class="line"><span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这里计算的只是 state 变量的低 16 的值，而不是整个 state 的值。虽然写的时候，必然是串行的，但这里计算的仍然是低 16 位的。</p>
<h3 id="读锁的获取和释放"><a href="#读锁的获取和释放" class="headerlink" title="读锁的获取和释放"></a>读锁的获取和释放</h3><p>获取读锁的过程是获取共享锁的过程。</p>
<h4 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared()"></a>tryAcquireShared()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> int11 <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// exclusiveCount(c) != 0 ---》 用 state &amp; 65535 得到低 16 位的值。如果不是0，说明写锁别持有了。</span></span><br><span class="line">    <span class="comment">// getExclusiveOwnerThread() != current----&gt; 不是当前线程</span></span><br><span class="line">    <span class="comment">// 如果写锁被霸占了，且持有线程不是当前线程，返回 false，加入队列。获取写锁失败。</span></span><br><span class="line">    <span class="comment">// 反之，如果持有写锁的是当前线程，就可以继续获取读锁了。</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="comment">// 获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果写锁没有被霸占，则将高16位移到低16位。</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);<span class="comment">// c &gt;&gt;&gt; 16</span></span><br><span class="line">    <span class="comment">// !readerShouldBlock() 和写锁的逻辑一样（根据公平与否策略和队列是否含有等待节点）</span></span><br><span class="line">    <span class="comment">// 不能大于 65535，且 CAS 修改成功</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; r &lt; <span class="number">65535</span> &amp;&amp; compareAndSetState(c, c + <span class="number">65536</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果读锁是空闲的， 获取锁成功。</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前线程设置为第一个读锁线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">// 计数器为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">// 如果读锁不是空闲的，且第一个读线程是当前线程。获取锁成功。</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;<span class="comment">// </span></span><br><span class="line">            <span class="comment">// 将计数器加一</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不是第一个线程，获取锁成功。</span></span><br><span class="line">            <span class="comment">// cachedHoldCounter 代表的是最后一个获取读锁的线程的计数器。</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="comment">// 如果最后一个线程计数器是 null 或者不是当前线程，那么就新建一个 HoldCounter 对象</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 给当前线程新建一个 HoldCounter</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="comment">// 如果不是 null，且 count 是 0，就将上个线程的 HoldCounter 覆盖本地的。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 对 count 加一</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死循环获取读锁。包含锁降级策略。</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下上面代码的逻辑吧！</p>
<ol>
<li> 判断写锁是否空闲。</li>
<li> 如果不是空闲，且当前线程不是持有写锁的线程，则返回 -1 ，表示抢锁失败。如果是空闲的，进入第三步。如果是当前线程，进入第三步。</li>
<li> 判断持有读锁的数量是否超过 65535，然后使用 CAS 设置 int 高 16 位的值，也就是加一。</li>
<li> 如果设置成功，且是第一次获取读锁，就设置 firstReader 相关的属性（为了性能提升）。</li>
<li> 如果不是第一次，当当前线程就是第一次获取读锁的线程，对 “第一次获取读锁线程计数器” 加 1.</li>
<li> 如果都不是，则获取最后一个读锁的线程计数器，判断这个计数器是不是当前线程的。如果是，加一，如果不是，自己创建一个新计数器，并更新 “最后读取的线程计数器”（也是为了性能考虑）。最后加一。返回成功。</li>
<li> 如果上面的判断失败了（CAS 设置失败，或者队列有等待的线程（公平情况下））。就调用 fullTryAcquireShared 方法死循环执行上面的步骤。</li>
</ol>
<p>步骤还是有点多哈，画个图吧，更清晰一点。</p>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gc9rxxbngxj30u00ugwnb.jpg" alt="img"></p>
<p>可以看到读锁对 AQS 的共享锁做了两个优化：</p>
<ol>
<li> 引进了 firstReaderHoldCount 和 cachedHoldCounter ，可以加快计数的性能；</li>
<li> 引入锁降级机制，对读多写少且读更重要的场景很适用。</li>
</ol>
<p>继续看 fullTryAcquireShared()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这段代码与tryAcquireShared中的代码有部分重复，但整体更简单。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果存在写锁</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 并且不是当前线程，获取锁失败，反之，如果持有写锁的是当前线程，那么就会进入下面的逻辑。</span></span><br><span class="line">            <span class="comment">// 反之，如果存在写锁，但持有写锁的是当前线程。那么就继续尝试获取读锁。</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果写锁空闲，且可以获取读锁。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// 第一个读线程是当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果不是当前线程</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        <span class="comment">// 从 ThreadLocal 中取出计数器</span></span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果读锁次数达到 65535 ，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 尝试对 state 加 65536, 也就是设置读锁，实际就是对高16位加一。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">// 如果读锁是空闲的</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置第一个读锁</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                <span class="comment">// 计数器为 1</span></span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果不是空闲的，查看第一个线程是否是当前线程。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;<span class="comment">// 更新计数器</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不是当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))<span class="comment">// 如果最后一个读计数器所属线程不是当前线程。</span></span><br><span class="line">                    <span class="comment">// 自己创建一个。</span></span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                <span class="comment">// 对计数器 ++</span></span><br><span class="line">                rh.count++;</span><br><span class="line">                <span class="comment">// 更新缓存计数器。</span></span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上和 tryAcquireShared() 差不多，只不过这里有一个自旋的过程。</p>
<ul>
<li>  <code>firstReader</code> 是获取读锁的第一个线程。如果只有一个线程获取读锁，很明显，使用这样一个变量速度更快。</li>
<li>  <code>firstReaderHoldCount</code>是 <code>firstReader</code>的计数器。同上。</li>
<li>  <code>cachedHoldCounter</code>是最后一个获取到读锁的线程计数器，每当有新的线程获取到读锁，这个变量都会更新。这个变量的目的是：当最后一个获取读锁的线程重复获取读锁，或者释放读锁，就会直接使用这个变量，速度更快，相当于缓存。</li>
</ul>
<h4 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared()"></a>tryReleaseShared()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 如果是第一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// 如果是 1，将第一个线程设置成 null。结束。</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果不是 1，减一操作</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是当前线程</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="comment">// 如果缓存是 null 或者缓存所属线程不是当前线程，则当前线程不是最后一个读锁。</span></span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            <span class="comment">// 获取当前线程的计数器</span></span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="comment">// 如果计数器小于等于一，就直接删除计数器</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="comment">// 如果计数器的值小于等于0，说明有问题了，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对计数器减一</span></span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">// 死循环使用 CAS 修改状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// c - 65536, 其实就是减去一个读锁。对高16位减一。</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="comment">// 修改 state 状态。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// 修改成功后，如果是 0，表示读锁和写锁都空闲，则可以唤醒后面的等待线程</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放还是很简单的，步骤如下：</p>
<ol>
<li> 如果当前线程是第一个持有读锁的线程，则只需要操作 firstReaderHoldCount 减一。如果不是，进入第二步。</li>
<li> 获取到缓存计数器（最后一个线程的计数器），如果匹配到当前线程，就减一。如果不匹配，进入第三步。</li>
<li> 获取当前线程自己的计数器（由于每个线程都会多次获取到锁，所以，每个线程必须保存自己的计数器。）。</li>
<li> 做减一操作。</li>
<li> 死循环修改 state 变量。</li>
</ol>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>重入还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。</p>
<p>锁降级的必要性主要有两个观点： *<strong>「个人还是倾向于第一种观点」*</strong></p>
<ol>
<li> 是为了保证数据的可见性，类似于volatile，只有写锁降级才能保证我读到的数据是我这次写数据后的数据，否则就可能发生其他线程先抢写锁，导致读到的数据并不是我这个线程写后的数据，当前线程无法感知数据更新。</li>
</ol>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gc9v5oynh5j318g0aaq56.jpg" alt="img"></p>
<ol>
<li> 特殊的写锁重入机制，JDK 使用 <code>先获取写入锁，然后获取读取锁，最后释放写入锁</code> 这个步骤，是为了提高获取锁的效率。尤其是读锁的效率，不需要等到写锁释放，也无需跟写锁竞争共享资源。</li>
</ol>
<p><img src="/2022/08/07/%E9%94%81-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/0082zybpgy1gc9uq685ftj31jg0ru44a.jpg" alt="img"></p>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><blockquote>
<p>  <a href="https://blog.csdn.net/v123411739/article/details/79321408">源码部分讲的很好，分析的很透彻</a></p>
<p>  <a href="https://juejin.im/post/5aeea5e951882506a36c67f0#heading-5">简介部分写的还行，但是源码分析的非常糟糕</a></p>
</blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</p>
<blockquote>
<p>  Q：为什么 wait/notify 等方法定义在 Object 方法内？</p>
<p>  A：Java中所有的类和对象逻辑上都对应有一个锁和监视器，也就是说在Java中一切对象都可以用来线程的同步、所以这些管程（监视器）的“过程”方法定义在Object中一点也不奇怪。</p>
</blockquote>
<p>一句话归纳，就是 Lock 搭配 Condition(await/signal)，Synchronized(监视器) 搭配 wait/notify。</p>
<p>从整体上来看<strong>Object的wait和notify/notify是与对象监视器配合完成线程间的等待/通知机制，而Condition与Lock配合完成等待通知机制，前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性</strong>。两者除了在使用方式上不同外，在<strong>功能特性</strong>上还是有很多的不同：</p>
<ol>
<li> 前置条件不同，Objec方式的对象监视器需要获得锁，而 Condition 的前提是要拿到 Lock；</li>
<li> Condition能够支持不响应中断，而通过使用Object方式不支持；</li>
<li> <strong>Condition能够支持多个等待队列（new 多个Condition对象），而Object方式只能支持一个；</strong></li>
<li> Condition能够支持超时时间的设置，而Object不支持。</li>
</ol>
<p>参照Object的wait和notify/notifyAll方法，Condition也提供了同样的方法：</p>
<blockquote>
<p>  <strong>针对Object的wait方法</strong></p>
</blockquote>
<ol>
<li> void await() throws InterruptedException:当前线程进入等待状态，如果其他线程调用condition的signal或者signalAll方法并且当前线程获取Lock从await方法返回，如果在等待状态中被中断会抛出被中断异常；</li>
<li> long awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者<strong>超时</strong>；</li>
<li> boolean await(long time, TimeUnit unit)throws InterruptedException：同第二种，支持自定义时间单位</li>
<li> boolean awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者<strong>到了某个时间</strong></li>
</ol>
<blockquote>
<p>  <strong>针对Object的notify/notifyAll方法</strong></p>
</blockquote>
<ol>
<li> void signal()：唤醒一个等待在condition上的线程，将该线程从<strong>等待队列</strong>中转移到<strong>同步队列</strong>中，如果在同步队列中能够竞争到Lock则可以从等待方法中返回。</li>
<li> void signalAll()：与1的区别在于能够唤醒所有等待在condition上的线程</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>创建一个 Condition 对象，是通过 lock.newCondition()，new出来一个 ConditionObject 对象，而这个恰好又是 AQS 的内部类，前面我们说过，condition是要和lock配合使用的，也就是condition和lock是绑定在一起的，而lock的实现原理又依赖于AQS，自然而然 ConditionObject 作为AQS的一个内部类无可厚非。</p>
<p>我们在 AQS 讲过，nextWaiter 既可以用来标志 Condition 队列中的下一个，又可以标志是独占锁/共享锁，很明显从这里就可以看出等待队列是一个单向队列，不同于同步队列是一个双向队列，并且等待队列并没有头结点，不像同步队列是有一个头结点的。还有一点需要再强调一次，<strong>对象Object对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列</strong>。</p>
<img src="0082zybpgy1gca8lji3r6j310x0k7juk.jpg" alt="img" style="zoom:200%;" />



<p>注： 图中的条件队列即等待队列。条件队列(等待队列)的属性如下，用头尾指针控制整个队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter; <span class="comment">// 条件队列的头节点</span></span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span>    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;  <span class="comment">// 条件队列的尾节点</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>Condition的实现主要包括：条件队列、等待和通知。其中条件队列放的是AQS里的Node数据结构，使用nextWaiter来维护条件队列。等待和通知共有7个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">signal() <span class="comment">//唤醒该条件队列的头节点。</span></span><br><span class="line">signalAll()	<span class="comment">//唤醒该条件队列的所有节点。</span></span><br><span class="line">awaitUninterruptibly()	<span class="comment">//等待，此方法无法被中断，必须通过唤醒才能解除阻塞。</span></span><br><span class="line">await()	<span class="comment">//当前线程进入等待。</span></span><br><span class="line">awaitNanos(<span class="keyword">long</span>)	<span class="comment">//当前线程进入等待，有超时时间，入参的单位为纳秒。</span></span><br><span class="line">awaitUntil(Date)	<span class="comment">//当先线程进入等待，直到当前时间超过入参的时间。</span></span><br><span class="line">await(<span class="keyword">long</span>, TimeUnit)	<span class="comment">//当前线程进入等待，有超时时间，入参可以自己设置时间单位。</span></span><br></pre></td></tr></table></figure>

<p>这些方法其实大同小异，因此本文只对常用的signal()、signalAll()和await()方法展开详解。搞懂了这3个方法，搞懂其他几个方法也基本没什么阻碍。</p>
<h4 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; <span class="comment">// 阻塞当前线程，直接被唤醒或被中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 如果当前线程被中断过，则抛出中断异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();   <span class="comment">// 添加一个waitStatus为CONDITION的节点到条件队列尾部</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);    <span class="comment">// 释放操作。我们知道只有在拥有锁（acquire成功）的时候才能调用await()方法，因此，调用await()方法的线程的节点必然是同步队列的头节点。所以，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的条件队列中。</span></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;  <span class="comment">// 0为正常，被中断值为THROW_IE或REINTERRUPT</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;  <span class="comment">// isOnSyncQueue：判断node是否在同步队列（注意和条件队列区分。调用signal方法会将节点从条件队列移动到同步队列，因此这边就可以跳出while循环）</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// node如果不在同步队列则进行park（阻塞当前线程）</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)    <span class="comment">// 检查线程被唤醒是否是因为被中断，如果是则跳出循环，否则会进行下一次循环，因为被唤醒前提是进入同步队列，所以下一次循环也必然会跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)   <span class="comment">// acquireQueued返回true代表被中断过，如果中断模式不是THROW_IE，则必然为REINTERRUPT（见上面的checkInterruptWhileWaiting方法）</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();   <span class="comment">// 移除waitStatus为CANCELLED的节点</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>) <span class="comment">// 如果跳出while循环是因为被中断</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);    <span class="comment">// 则根据interruptMode，选择抛出InterruptedException 或 重新中断当前线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下整体的流程：</p>
<ol>
<li> 判断线程是否被中断，是的话就抛出异常；</li>
<li> 然后将给线程包装成节点，且 WaitStatus == Condition，这个由 addConditionWaiter() 完成，下面会讲；</li>
<li> 然后将同步队列中的节点删除，其实就相当于是将同步队列的头结点加入到条件队列中的尾结点，这个是由fullRelease() 完成的；</li>
<li> 然后判断线程是否在同步队列中，这个使用的是 isOnSyncQueue()，第一次肯定是已经不在了，因为调用了 fullRelease() 已经将其从同步队列中删除了，进入循环后，就会阻塞该线程，如何退出呢，那就需要 signal了；</li>
<li> 当调用了 signal 后，程序会跳出循环，此时 signal 函数已经将该节点从条件队列加回至同步队列中了，我们只需要调用 acquireQueued() 尝试获取锁就可以了。</li>
</ol>
<p>接下来，讲一下刚才用到的几个方法：</p>
<h5 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter()"></a>addConditionWaiter()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123; <span class="comment">// 添加一个waitStatus为CONDITION的节点到条件队列尾部</span></span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();   <span class="comment">// 移除waitStatus不为CONDITION的节点（条件队列里的节点waitStatus都为CONDITION）</span></span><br><span class="line">        t = lastWaiter; <span class="comment">// 将t赋值为移除了waitStatus不为CONDITION后的尾节点（上面进行了移除操作，因此尾节点可能会发生变化）</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);   <span class="comment">// 以当前线程新建一个waitStatus为CONDITION的节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)  <span class="comment">// t为空，代表条件队列为空</span></span><br><span class="line">        firstWaiter = node; <span class="comment">// 将头节点赋值为node</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;    <span class="comment">// 否则，队列不为空。将t（原尾节点）的后继节点赋值为node</span></span><br><span class="line">    lastWaiter = node;  <span class="comment">// 将node赋值给尾节点，即将node放到条件队列的尾部。这里没有用CAS来保证原子性，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的主体功能就是添加一个waitStatus为CONDITION的节点到条件队列尾部，具体实现步骤是：</p>
<ol>
<li> 如果条件队列的尾节点不为null并且waitStatus不为CONDITION，则调用unlinkCancelledWaiters方法（详解见下文unlinkCancelledWaiters方法）移除waitStatus不为CONDITION的节点（条件队列里的节点waitStatus都为CONDITION），并将t赋值为移除了waitStatus不为CONDITION后的尾节点（上面进行了移除操作，因此尾节点可能会发生变化）；</li>
<li> 新建一个节点，存储当前线程；</li>
<li> 添加到队尾，注意这里不需要使用 CAS。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123; <span class="comment">//　从条件队列移除所有waitStatus不为CONDITION的节点</span></span><br><span class="line">    Node t = firstWaiter; <span class="comment">// t赋值为条件队列的尾节点  </span></span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;   <span class="comment">// 向下遍历</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;   <span class="comment">// 如果t的waitStatus不为CONDITION</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;    <span class="comment">// 断开t与t后继节点的关联</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)  <span class="comment">// 如果trail为null，则将firstWaiter赋值为next节点，此时还没有遍历到waitStatus为CONDITION的节点，因此直接移动firstWaiter的指针即可移除前面的节点</span></span><br><span class="line">                firstWaiter = next; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;    <span class="comment">// 否则将trail的后继节点设为next节点。此时，trail节点到next节点中的所有节点被移除（包括t节点，但可能不止t节点。因为，trail始终指向遍历过的最后一个waitStatus为CONDITION，因此只需要将trail的后继节点设置为next，即可将trail之后到next之前的所有节点移除）</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;  <span class="comment">// 如果t的waitStatus为CONDITION，则将trail赋值为t，trail始终指向遍历过的最后一个waitStatus为CONDITION</span></span><br><span class="line">        t = next;   <span class="comment">// t指向下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fullRelease"><a href="#fullRelease" class="headerlink" title="fullRelease()"></a>fullRelease()</h5><p>主体也就是 AQS 的 release 方法，将其从同步队列中删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123; <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();    <span class="comment">// 当前的同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;  <span class="comment">// 独占模式下release（一般指释放锁）</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;   <span class="comment">// 如果release失败则将该节点的waitStatus设置为CANCELLED</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue()"></a>isOnSyncQueue()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;    <span class="comment">// 判断node是否再同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>) <span class="comment">// 如果waitStatus为CONDITION 或 node没有前驱节点，则必然不在同步队列，直接返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// 如果有后继节点，必然是在同步队列中，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);  <span class="comment">// 返回node是否为同步队列节点，如果是返回true，否则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从同步队列的尾节点开始向前遍历，如果node为同步队列节点则返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;   </span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())   <span class="comment">// 检查当前线程是否为独占模式同步器的所有者</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;   </span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);    <span class="comment">// 唤醒条件队列的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为条件队列，即等待队列也是 FIFO，头结点必然是等的最久的一个，所以每次唤醒都是唤醒头结点。</p>
<p>具体步骤：</p>
<ol>
<li> 检查当前线程是否为独占模式同步器的所有者，在ReentrantLock中即检查当前线程是否为拥有锁的线程。如果不是，则抛IllegalMonitorStateException。</li>
<li> 拿到条件队列的头节点，如果不为null，则调用doSignal方法（详解见下文doSignal方法）唤醒头节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123; <span class="comment">// 将条件队列的头节点移到同步队列</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)  <span class="comment">// 将first节点赋值为first节点的后继节点（相当于移除first节点），如果first节点的后继节点为空，则将lastWaiter赋值为null</span></span><br><span class="line">            lastWaiter = <span class="keyword">null</span>; </span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;    <span class="comment">// 断开first节点对first节点后继节点的关联</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;   <span class="comment">// transferForSignal：将first节点从条件队列移动到同步队列</span></span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);    <span class="comment">// 如果transferForSignal失败，并且first节点不为null，则向下遍历条件队列的节点，直到节点成功移动到同步队列 或者 firstWaiter为null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//　将node节点从条件队列移动到同步队列，如果成功则返回true。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))  </span><br><span class="line">      <span class="comment">// 如果不能更改节点的waitStatus，则表示该节点已被取消，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> 		<span class="comment">// 否则，调用enq方法将node添加到同步队列，注意：enq方法返回的节点是node的前驱节点</span></span><br><span class="line">    Node p = enq(node); </span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;  <span class="comment">// 将ws赋值为node前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) </span><br><span class="line">      <span class="comment">// 如果node前驱节点的状态为CANCELLED（ws&gt;0） </span></span><br><span class="line">      <span class="comment">//或 使用CAS将waitStatus修改成SIGNAL失败，则代表node的前驱节点无法来唤醒node节点，因此直接调用LockSupport.unpark方法唤醒node节点</span></span><br><span class="line">      <span class="comment">// 注意，unparkSuccessor(node)是唤醒该节点的下一个节点，而LockSupport.lock则是直接唤醒该节点</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll()"></a>signalAll()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())   <span class="comment">// 检查当前线程是否为独占模式同步器的所有者</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignalAll(first); <span class="comment">// 唤醒条件队列的所有节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">copyprivate <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;  <span class="comment">// 将条件队列的所有节点移到同步队列</span></span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;    <span class="comment">// 因为要移除条件队列的所有节点到同步队列，因此这边直接将firstWaiter和lastWaiter赋值为null</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;   <span class="comment">// next赋值为first节点的后继节点      </span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;    <span class="comment">// 断开first节点对first节点后继节点的关联</span></span><br><span class="line">        transferForSignal(first);   <span class="comment">// transferForSignal：将first节点从条件队列移动到同步队列</span></span><br><span class="line">        first = next;   <span class="comment">// first赋值为next节点</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);    <span class="comment">// 循环遍历，将条件队列的所有节点移动到同步队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Condition 就分析完了，我们可以用 Condition 写一个 生产者-消费者的demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.global.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> :  zhufeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> :  2022/8/6 10:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">await_signal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition empty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition full = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] data = <span class="keyword">new</span> Object[MAX_SIZE];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count == MAX_SIZE) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;data满了，producer方法进入等待&quot;</span>);</span><br><span class="line">                full.await();</span><br><span class="line">            &#125;</span><br><span class="line">            data[count++] = <span class="keyword">new</span> Object();</span><br><span class="line">            empty.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;producer &quot;</span> + count);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;data空了，consumer方法进入等待&quot;</span>);</span><br><span class="line">                empty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            data[--count] = <span class="keyword">null</span>;</span><br><span class="line">            full.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;consumer &quot;</span> + count);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        await_signal as = <span class="keyword">new</span> await_signal();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                as.producer();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                as.consumer();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">producer <span class="number">1</span></span><br><span class="line">producer <span class="number">2</span></span><br><span class="line">producer <span class="number">3</span></span><br><span class="line">producer <span class="number">4</span></span><br><span class="line">producer <span class="number">5</span></span><br><span class="line">data满了，producer方法进入等待</span><br><span class="line">consumer <span class="number">4</span></span><br><span class="line">producer <span class="number">5</span></span><br><span class="line">consumer <span class="number">4</span></span><br><span class="line">consumer <span class="number">3</span></span><br><span class="line">consumer <span class="number">2</span></span><br><span class="line">producer <span class="number">3</span></span><br><span class="line">consumer <span class="number">2</span></span><br><span class="line">consumer <span class="number">1</span></span><br><span class="line">consumer <span class="number">0</span></span><br><span class="line">producer <span class="number">1</span></span><br><span class="line">consumer <span class="number">0</span></span><br><span class="line">data空了，consumer方法进入等待</span><br><span class="line">producer <span class="number">1</span></span><br><span class="line">consumer <span class="number">0</span></span><br><span class="line">data空了，consumer方法进入等待</span><br><span class="line">producer <span class="number">1</span></span><br><span class="line">consumer <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="各种锁复习"><a href="#各种锁复习" class="headerlink" title="各种锁复习"></a>各种锁复习</h2><blockquote>
<p>  <a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect">各种锁的对比</a></p>
<p>  <a href="http://www.ideabuffer.cn/2017/04/21/java-%E4%B8%AD%E7%9A%84%E9%94%81-%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/">偏向锁、轻量级锁、自旋锁、重量级锁</a></p>
<p>  <a href="https://www.jianshu.com/p/6f0bba673d5c">并发编程之锁优化</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java中锁和关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>Map源码分析</title>
    <url>/2022/07/31/Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>  除了List集合外，HashMap也是我们日常开发中经常使用的key-value容器，并且也是面试过程中经常会问到的知识点，本文也将对HashMap、TreeMap、LinkedHashMap、ConcurrentHashMap等进行深入分析。</p>
</blockquote>
<span id="more"></span>

<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p><img src="/2022/07/31/Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/006tNbRwgy1gbb7ylpm6yj30qo0dvwfd-16591490285105.jpg" alt="img"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>  <a href="https://www.zybuluo.com/kiraSally/note/819843">集合番@HashMap一文通（1.7版）</a></li>
<li>  <a href="https://www.zybuluo.com/kiraSally/note/836217">集合番@HashMap一文通（1.8版）</a></li>
<li>  <a href="https://juejin.im/post/5ac83fa35188255c5668afd0#heading-8">HashMap源码分析—掘金博主</a></li>
<li>  <a href="https://zhuanlan.zhihu.com/p/21673805">美团技术讲解HashMap</a></li>
<li>  <a href="https://note.youdao.com/ynoteshare1/index.html?id=f50290f090db045c36036a2a4b57ba24&type=note">相关面试问题</a></li>
</ul>
<h2 id="问题引导"><a href="#问题引导" class="headerlink" title="问题引导"></a>问题引导</h2><p>由于知识点太多，我就以自己搜集到的面试常问的有关于HashMap的问题进行解决，然后再进一步深挖！</p>
<ul>
<li>  <strong>HashMap的底层数据结构？</strong></li>
<li>  <strong>HashMap的主要方法？</strong></li>
<li>  <strong>HashMap 是如何确定元素存储位置的以及如何处理哈希冲突的？</strong></li>
<li>  <strong>HashMap 扩容机制是怎样的？</strong></li>
<li>  <strong>JDK 1.8 在扩容和解决哈希冲突上对 HashMap 源码做了哪些改动？有什么好处?</strong></li>
<li>  <strong>什么时候会使用HashMap？他有什么特点？</strong></li>
<li>  <strong>你知道HashMap的工作原理吗？</strong></li>
<li>  <strong>你知道get和put的原理吗？equals()和hashCode()都有什么作用？</strong></li>
<li>  <strong>你知道hash的实现吗？为什么要这样实现？</strong></li>
<li>  <strong>如果HashMap的大小超过了负载因子（load factor）定义的容量，怎么办？</strong></li>
<li>  <strong>你了解重新调整HashMap大小存在什么问题吗？</strong></li>
<li>  <strong>为什么使用String，Interger这样的wrapper类适合作为键？</strong></li>
<li>  <strong>我们可以使用自定义的对象作为键吗？</strong></li>
<li>  <strong>如何对HashMap进行排序？</strong></li>
<li>  <strong>HashMap的删除陷阱？</strong></li>
<li>  <strong>为什么只允许通过iterator进行删除操作？</strong></li>
<li>  <strong>如果是遍历过程中增加或修改数据呢？</strong></li>
<li>  <strong>hashmap为什么初始长度为16？</strong></li>
<li>  <strong>HashMap中的扰动函数是什么，有什么作用，TreeMap中有吗？</strong></li>
<li>  <strong>HashMap为何可以插入空值？为什么它是线程不安全的？</strong></li>
</ul>
<p>这20个问题的参考想法会在文章末尾给出！先一起来学习一哈HashMap的源码！</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>  HashMap的特性</li>
<li>  HashMap的存储结构</li>
<li>  HashMap的重要方法—增删改查</li>
<li>  HashMap的扩容机制</li>
<li>  HashMap的迭代器</li>
<li>  HashMap的Fail-Fast机制</li>
<li>  HashMap与大家庭中其他Map的区别</li>
</ul>
<p>接下来从这些方面拿下HashMap！！！</p>
<h2 id="HashMap的特性"><a href="#HashMap的特性" class="headerlink" title="HashMap的特性"></a>HashMap的特性</h2><ul>
<li>  它根据键的 <strong>hashCode值</strong> 存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。[只是说跟hashCode的值有关系哦！并不是直接按照hashCode()返回值存取的]</li>
<li>  HashMap最多只允许<strong>一条</strong>记录的键为null，允许<strong>多条</strong>记录的值为null。</li>
<li>  HashMap <strong>非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 <strong>Collections</strong> 的 <strong>synchronizedMap</strong> 方法使 <strong>HashMap</strong> 具有线程安全的能力，或者使用<strong>ConcurrentHashMap</strong>。</li>
<li>  键唯一，如果键相同，则值会被覆盖。同时若键为自定义的数据类型，则需要保证已经重写了equals() 和 hashCode()。 ——&gt; <a href="https://juejin.im/post/5ac4d8abf265da23a4050ae3">equals() 和 hashCode()详解</a></li>
</ul>
<h2 id="HashMap的存储结构"><a href="#HashMap的存储结构" class="headerlink" title="HashMap的存储结构"></a>HashMap的存储结构</h2><p><strong>JDK 1.7</strong> 版本的HashMap是以 <strong>数组 + 链表</strong> 存储的，也就是我们常说的按 <strong>链地址法</strong> 存储</p>
<blockquote>
<p>  常见的处理哈希冲突的方法就两种：</p>
<ul>
<li><p>开放地址法</p>
<p>  开放地址法又可以分为线性探测法、平方探测法、再散列法</p>
</li>
<li><p>  拉链法</p>
</li>
</ul>
</blockquote>
<p><strong>JDK 1.8</strong> 版本的HashMap是以 <strong>数组 + 链表 + 红黑树</strong> 实现的，<strong>红黑树</strong> 可能大家接触的不是很多，所以我赶紧学习了一波 <a href="https://jeromememory.github.io/2020/01/15/[https://jeromememory.github.io/2020/01/16/%E7%BA%A2%E9%BB%91%E6%A0%91.html](https://jeromememory.github.io/2020/01/16/%E7%BA%A2%E9%BB%91%E6%A0%91.html)">传送门</a>，具体的实现如下图所示：</p>
<p><img src="/2022/07/31/Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/006tNbRwly1gb0r1wg38tj30k00f5q4k.jpg" alt="img"></p>
<h2 id="源码中的相关概念"><a href="#源码中的相关概念" class="headerlink" title="源码中的相关概念"></a>源码中的相关概念</h2><h3 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h3><ol>
<li> <strong>哈希桶（buckets）</strong>：在 HashMap 的注释里使用哈希桶来形象的表示数组中每个地址位置。注意这里并不是数组本身，数组是装哈希桶的，他可以被称为<strong>哈希表</strong>。</li>
<li> <strong>初始容量(initial capacity)</strong> : 这个很容易理解，就是哈希表中哈希桶初始的数量。如果我们没有通过构造方法修改这个容量值默认为<code>DEFAULT_INITIAL_CAPACITY = 1&lt;&lt;4</code> 即16。值得注意的是为了保证 HashMap 添加和查找的高效性，<code>HashMap</code> 的容量总是 2^n 的形式，下文会讲为什么 HashMap 的容量总是 2^n次方。</li>
<li> <strong>加载因子(load factor)<strong>：加载因子是哈希表（散列表）在其容量自动增加之前被允许获得的最大数量的度量。当哈希表中的条目数量超过负载因子和当前容量的乘积时，散列表就会被重新映射（即重建内部数据结构），重新创建的散列表容量大约是之前散列表哈系统桶数量的两倍。默认加载因子（0.75）在时间和空间成本之间提供了良好的折衷。加载因子过大会导致很容易链表过长，</strong>加载因子很小又容易导致频繁的扩容。所以不要轻易试着去改变这个默认值</strong>。</li>
<li> <strong>扩容阈值（threshold）</strong>：其实在说加载因子的时候已经提到了扩容阈值了，<strong>扩容阈值 = 哈希表容量 * 加载因子</strong>。哈希表的键值对总数 = 所有哈希桶中所有链表节点数的加和，扩容阈值比较的是是键值对的个数而不是哈希表的数组中有多少个位置被占了。</li>
<li> <strong>树化阀值(TREEIFY_THRESHOLD)</strong> ：这个参数概念是在 <strong>JDK1.8后加入的</strong>，它的含义代表一个哈希桶中的节点个数大于该值（默认为8）的时候将会被转为红黑树行存储结构。</li>
<li> **非树化阀值(UNTREEIFY_THRESHOLD)**： 与树化阈值相对应，表示当一个已经转化为数形存储结构的哈希桶中节点数量小于该值（默认为 6）的时候将再次改为单链表的格式存储。导致这种操作的原因可能有删除节点或者扩容。</li>
<li> <strong>最小树化容量(MIN_TREEIFY_CAPACITY)</strong>: 经过上边的介绍我们只知道，当链表的节点数超过8的时候就会转化为树化存储，其实对于转化还有一个要求就是哈希表的数量超过最小树化容量的要求（默认要求是 64）,且为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD);在达到该要求之前优先选择扩容。扩容因为因为容量的变化可能会使单链表的长度改变。</li>
</ol>
<p>与这个几个概念对应的在 HashMap 中几个常亮量，由于上边的介绍比较详细了，下边仅列出几个变量的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*默认初始容量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*最大存储容量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*默认加载因子*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*默认树化阈值*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*默认非树化阈值*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*默认最小树化容量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<p>对应的还有几个全局变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容阈值 = 容量 x 加载因子</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储哈希桶的数组，哈希桶中装的是一个单链表或一颗红黑树，长度一定是 2^n</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// HashMap中存储的键值对的数量注意这里是键值对的个数而不是数组的长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">  		</span><br><span class="line"><span class="comment">//所有键值对的Set集合 区分于 table 可以调用 entrySet(）得到该集合</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//操作数记录 为了多线程操作时 Fast-fail 机制</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  作者：像一只狗<br>  链接：<a href="https://juejin.im/post/5ac83fa35188255c5668afd0">https://juejin.im/post/5ac83fa35188255c5668afd0</a><br>  来源：掘金</p>
</blockquote>
<h3 id="基本存储单元"><a href="#基本存储单元" class="headerlink" title="基本存储单元"></a>基本存储单元</h3><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	* Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">	* TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">	* 1.8中将Entry改成Node（内部结构不变）</span></span><br><span class="line"><span class="comment">	* 虽然只是改了名字，但名字的变更体现出HashMap对于节点概念的重视</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//哈希值,新增final属性，表明hash值也不可变了，更加严谨</span></span><br><span class="line">      <span class="keyword">final</span> K key;<span class="comment">//key</span></span><br><span class="line">      V value;<span class="comment">//value</span></span><br><span class="line">      Node&lt;K,V&gt; next;<span class="comment">//链表后置节点</span></span><br><span class="line"></span><br><span class="line">      Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          <span class="keyword">this</span>.hash = hash;</span><br><span class="line">          <span class="keyword">this</span>.key = key;</span><br><span class="line">          <span class="keyword">this</span>.value = value;</span><br><span class="line">          <span class="keyword">this</span>.next = next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//每一个节点的hash值，是将 key 的 hashCode 和 value 的 hashCode 异或得到的。</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置新的value 同时返回旧value</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">          V oldValue = value;</span><br><span class="line">          value = newValue;</span><br><span class="line">          <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">              Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">              <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                  Objects.equals(value, e.getValue()))</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn extends Node) </span></span><br><span class="line"><span class="comment">  * so can be used as extension of either regular or linked node.</span></span><br><span class="line"><span class="comment">  * 红黑树节点 相比于TreeMap，</span></span><br><span class="line"><span class="comment">  *    1.增加pre来记录前一个节点</span></span><br><span class="line"><span class="comment">  *    2.继承LinkedHashMap.Entry&lt;K,V&gt;，而LinkedHashMap.Entry&lt;K,V&gt;又继承HashMap.Node：</span></span><br><span class="line"><span class="comment">  *     1.拥有了Node和链表Node的所有功能</span></span><br><span class="line"><span class="comment">  *     2.具有额外6个属性Entry&lt;K,V&gt; before, after;final int hash;final K key;V value;Node&lt;K,V&gt; next;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;<span class="comment">//左子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;<span class="comment">//右子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// 前一个元素的节点</span></span><br><span class="line">    <span class="keyword">boolean</span> red;<span class="comment">//是否是红节点</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * LinkedHashMap.Entry的实现</span></span><br><span class="line"><span class="comment">  * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">  * 可以发现，最终TreeNode还是继承了HashMap.Node的所有功能，底层实现还是Node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><h4 id="确定哈希桶数组索引位置"><a href="#确定哈希桶数组索引位置" class="headerlink" title="确定哈希桶数组索引位置"></a>确定哈希桶数组索引位置</h4><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：称为扰动函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算，高16位和低16位进行异或</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而<strong>HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</strong></p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的<strong>高16位异或低16位</strong>实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。</p>
<p><img src="/2022/07/31/Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/006tNbRwly1gb0sizeqjnj30k00bfwgw.jpg" alt="img"></p>
<h4 id="Put方法-新增"><a href="#Put方法-新增" class="headerlink" title="Put方法(新增)"></a>Put方法(新增)</h4><img src="006tNbRwly1gb0sqfgwffj311v0u0gu9.jpg" alt="img" style="zoom: 50%;" />

<ul>
<li>  ① 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li>
<li>  ② 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</li>
<li>  ③ 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</li>
<li>  ④ 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</li>
<li>  ⑤ 遍历table[i]，判断链表长度是否大于8，大于8的话，进入到 treeifyBin()，会先去判断当前哈希桶大小是不是到了 MIN_TREEIFY_CAPACITY （默认是 64），如果没有就直接扩容，如果到了64（≥64），就把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li>
<li>  ⑥ 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">  * 新增键值对</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//注意 不可以被继承重载 如果使用hashMap的方式的话</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//当数组为空时</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">        n = (tab = resize()).length;<span class="comment">//当初始化或者当前数组长度为0时，需要重新resize并返回新的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//相当于通过 h &amp; (length-1) 计算下标并获取元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//若当前下标位置空置（即该key不存在），就新建一个普通(non-tree)节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当该key存在或者发生hash冲突时</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//若在数组中通过hash和equals比较能够直接找到该值，就覆盖旧值</span></span><br><span class="line">        <span class="comment">//即当前桶即非链表也非红黑树</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">            e = p;<span class="comment">//覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则需要先判断节点是否是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;<span class="comment">//若是红黑树类型，执行树节点putTreeVal操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//此时发生了冲突</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//如果此时的桶还不是链表，需要转变为链表 或者 如果在链表中没有，那就新增一个节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//注意链表插入时1.7与1.8是不同的</span></span><br><span class="line">                    <span class="comment">//1.7:是头插入法，后来的留在数组上，先来的链在尾上（遍历时是先进后出）</span></span><br><span class="line">                    <span class="comment">//1.8:是尾插入法，先来的留在数组上，后来的链在尾上（遍历时是先进先出）</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>); </span><br><span class="line">                    <span class="comment">//如果桶的链表长度&gt;=桶的树化阈值，需要将链表转变为红黑树</span></span><br><span class="line">                    <span class="comment">//这里需要注意：是先新增元素之后再判断树化条件，而不是先树化再新增</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">//当前桶树化</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果在链表中已经存在该值，就覆盖旧值</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原则：用新值覆盖旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key </span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">//onlyIfAbsent 若是true，不允许覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);<span class="comment">//相当于1.7的afterNodeAccess，LinkedHashMap专用，用于有序控制</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//超过阈值就扩容</span></span><br><span class="line">            resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">//LinkedHashMap专用，用于删除最旧元素 (remove eldest)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Create a regular (non-tree) node 创建一个普通的非树节点</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="resize方法-扩容"><a href="#resize方法-扩容" class="headerlink" title="resize方法(扩容)"></a>resize方法(扩容)</h4><p>整体分为两部分：<strong>1. 寻找扩容后数组的大小以及新的扩容阈值，2. 将原有哈希表拷贝到新的哈希表中</strong>。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="/2022/07/31/Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/006tNbRwly1gb0u5zlg5wj30k00dwmyv.jpg" alt="img"></p>
<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="/2022/07/31/Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/006tNbRwly1gb0u6075wyj30k005hgmh.jpg" alt="img"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="/2022/07/31/Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/006tNbRwly1gb0u615io8j30k003taao.jpg" alt="img"></p>
<p>因此，<strong>我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong>。</p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Initializes or doubles table size.  If null, allocates in accord with initial capacity</span></span><br><span class="line"><span class="comment">  * target held in field threshold. Otherwise, because we are using power-of-two expansion,</span></span><br><span class="line"><span class="comment">  * the elements from each bin must either stay at same index, or move with a power of two</span></span><br><span class="line"><span class="comment">  * offset in the new table.</span></span><br><span class="line"><span class="comment">  * 初始化Map或2倍扩容，且会均匀的把之前的冲突的节点分散到新的桶中</span></span><br><span class="line"><span class="comment">  *     当Map为空时，将分配与阈值一样大小的容量</span></span><br><span class="line"><span class="comment">  *     当Map不为空时，由于2次幂扩容，元素位置会产生两种情况</span></span><br><span class="line"><span class="comment">  *        1.要么元素所在位置不变</span></span><br><span class="line"><span class="comment">  *        2.要么元素所在位置变动：向右位移2次幂位置</span></span><br><span class="line"><span class="comment">  * 注意：由于1.8中容量是根据阈值得来的，因此读者会在1.8中看到很多对阈值的判断和处理，这点一定要清楚</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//由于新数组会覆盖旧数组，所以要临时先备份一份，用于对新数组重新赋值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//当Map不为空时</span></span><br><span class="line">        <span class="comment">//临界处理：最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;<span class="comment">//最大值其实是Integer的最大值</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若2倍容量 &lt; MAXIMUM_CAPACITY 同时 原容量&gt;=默认容量(即16)，那么就扩容2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  阈值直接两倍（容量都是根据阈值来的）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)&#123;<span class="comment">//当Map为空时，需要判断阈值是否&gt;0</span></span><br><span class="line">        newCap = oldThr;<span class="comment">//阈值即新容量（注意：初始化时候就是执行该操作完成容量赋值）</span></span><br><span class="line">        <span class="comment">// initial capacity was placed in threshold（容量都是根据阈值来的）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当Map为空，且阈值不是大于0（即无效阈值），那么就使用默认值</span></span><br><span class="line">        <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//1 &lt;&lt; 4 = 16 </span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//0.75 * 16 = 12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当新阈值没有被重置时，需要根据 新容量和负载因子 重新计算出新的阈值</span></span><br><span class="line">    <span class="comment">//注意：初始化的时候，阈值会被重置，即此时 阈值！=容量 ，容量已经在(oldThr &gt; 0)时重置过了</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//等同于1.7版本：threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;<span class="comment">//重置给真实阈值</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">//新建一个新容量的Node数组</span></span><br><span class="line">    table = newTab;<span class="comment">//覆盖原数组（第一行已经备份了）</span></span><br><span class="line">    <span class="comment">//当原数组非空，需要对新数组重新填充</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;<span class="comment">//用于备份当前节点</span></span><br><span class="line">            <span class="comment">//若该数组下标位置非空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;<span class="comment">//先把原数组的当前位置清空，因为已经备份了  help gc</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//当前桶既非链表也非红黑树</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//位置可能不变或移动2次幂，跟newCap-1有关</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//若当前桶是树节点，需要对树进行切分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order 当前桶是链表，要保持顺序 1.7的会倒置</span></span><br><span class="line">                    <span class="comment">//扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致!!!</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;<span class="comment">//lo=low，表示低位（即数组前半部分的链表）</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;<span class="comment">//hi=high，表示高位（即数组后半部分的链表）</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//遍历当前桶的链表</span></span><br><span class="line">                    <span class="comment">//1.8:是尾插入法，先来的留在数组上，后来的链在尾上（遍历时是先进先出）</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//根据e.hash &amp; oldCap是否为零将原链表拆分成2个链表</span></span><br><span class="line">                        <span class="comment">//判断当前位置是否发生变动 0则没变 即保留在原链表中不需要移动</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">//原索引 在数组前半部分处理</span></span><br><span class="line">                           <span class="comment">//若队尾为空，当前元素即是队首元素（也就是第一个插入的元素），保证先进先出</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) </span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            <span class="comment">//若队尾不为空，当前元素链接到原队尾元素后面，保证先进先出</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;<span class="comment">//为了保证插入顺序不变，当前元素都需先设置为队尾元素</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//原索引+oldCap 否则移动到&quot;原索引+oldCap&quot;的新链表中</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//在数组后半部分处理</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;<span class="comment">//为了保证插入顺序不变，当前元素都需先设置为队尾元素</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//原索引放到原桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">//如果队尾元素非空</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;<span class="comment">//loTail此时就是队尾元素</span></span><br><span class="line">                        newTab[j] = loHead;<span class="comment">//队首是放在数组里面的</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//原索引+oldCap放到新桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;<span class="comment">//如果队尾元素非空</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;<span class="comment">//hiTail此时就是队尾元素</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;<span class="comment">//队首是放在数组里面的</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，JDK 1.8之后扩容的改进有：</p>
<ul>
<li>  链表上的节点是尾插法，先来的放到数组中，后来的放到链表中，先到先出，类似于栈。</li>
<li>  JDK 1.8 不像 JDK1.7中会重新计算每个节点在新哈希表中的位置，而是通过 <code>(e.hash &amp; oldCap) == 0</code>是否等于0 就可以得出原来链表中的节点在新哈希表的位置。<strong>无需重新计算Hash，节省了时间，新索引=原索引+原容量</strong></li>
<li>  HashMap 在 1.7的时候扩容后，链表的节点顺序会倒置，1.8则不会出现这种情况。因为1.7是后进先出，1.8是先进先出。</li>
</ul>
<h4 id="treeifyBin方法-树化方法"><a href="#treeifyBin方法-树化方法" class="headerlink" title="treeifyBin方法(树化方法)"></a>treeifyBin方法(树化方法)</h4><h4 id="get方法-查询"><a href="#get方法-查询" class="headerlink" title="get方法(查询)"></a>get方法(查询)</h4><h4 id="remove方法-删除"><a href="#remove方法-删除" class="headerlink" title="remove方法(删除)"></a>remove方法(删除)</h4><p><code>HashMap</code> 没有 <code>set</code> 方法，如果想要修改对应 key 映射的 Value ，只需要再次调用 <code>put</code> 方法就可以了。我们来看下如何移除 <code>HashMap</code> 中对应的节点的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">       <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个参数需要我们提起注意：</p>
<ul>
<li>  matchValue 如果这个值为 true 则表示只有当 Value 与第三个参数 Value 相同的时候才删除节点</li>
<li>  movable 这个参数在红黑树中先删除节点时候使用 true 表示删除并其他数中的节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                               boolean matchValue, boolean movable) &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">   //判断哈希表是否为空，长度是否大于0 对应的位置上是否有元素</span><br><span class="line">   if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">       (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">       </span><br><span class="line">       // node 用来存放要移除的节点， e 表示下个节点 k ，v 每个节点的键值</span><br><span class="line">       Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">       //如果第一个节点就是我们要找的直接赋值给 node</span><br><span class="line">       if (p.hash == hash &amp;&amp;</span><br><span class="line">           ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">           node = p;</span><br><span class="line">       else if ((e = p.next) != null) &#123;</span><br><span class="line">            // 遍历红黑树找到对应的节点</span><br><span class="line">           if (p instanceof TreeNode)</span><br><span class="line">               node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">           else &#123;</span><br><span class="line">                //遍历对应的链表找到对应的节点</span><br><span class="line">               do &#123;</span><br><span class="line">                   if (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key ||</span><br><span class="line">                        (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                       node = e;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125; while ((e = e.next) != null);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 如果找到了节点</span><br><span class="line">       // !matchValue 是否不删除节点</span><br><span class="line">       // (v = node.value) == value ||</span><br><span class="line">       // (value != null &amp;&amp; value.equals(v))) 节点值是否相同，</span><br><span class="line">       if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                            (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">           //删除节点                 </span><br><span class="line">           if (node instanceof TreeNode)</span><br><span class="line">               ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">           else if (node == p)</span><br><span class="line">               tab[index] = node.next;</span><br><span class="line">           else</span><br><span class="line">               p.next = node.next;</span><br><span class="line">           ++modCount;</span><br><span class="line">           --size;</span><br><span class="line">           afterNodeRemoval(node);</span><br><span class="line">           return node;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br><span class="line">copypublic void remove() &#123;</span><br><span class="line">    if (current == null)</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    Object k = current.key;</span><br><span class="line">    current = null;</span><br><span class="line">    HashMap.this.removeEntryForKey(k);</span><br><span class="line">    //重要操作：迭代器中删除时同步了expectedModCount值与modCount相同</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>Map 是没有迭代器的，需要转成 Set 操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">Iterator iter = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">　Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">　Object key = entry.getKey();</span><br><span class="line">　Object val = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要强调的是，无论哪种迭代器都是通过遍历 table 表来获取下个节点，来遍历的，遍历过程可以理解为一种深度优先遍历，即优先遍历链表节点（或者红黑树），然后在遍历其他数组位置。</p>
<h4 id="Fail-Fast"><a href="#Fail-Fast" class="headerlink" title="Fail-Fast"></a>Fail-Fast</h4><p><strong>当使用迭代器的过程中有其他线程修改了map，并且不是使用迭代器修改的，将引发<code>ConcurrentModificationException</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改计数 put、remove或clear时mount++ clear时清空</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Entry[] t = table;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//期望变更数量不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与HashTable的区别"><a href="#与HashTable的区别" class="headerlink" title="与HashTable的区别"></a>与HashTable的区别</h2><ul>
<li>  <code>HashMap</code> 是线程不安全的，HashTable是线程安全的。</li>
<li>  <code>HashMap</code> 允许 key 和 Vale 是 null，但是只允许一个 key 为 null,且这个元素存放在哈希表 0 角标位置。 <code>HashTable</code> 不允许key、value 是 null。</li>
<li>  <code>HashMap</code> 内部使用<code>hash(Object key)</code>扰动函数对 key 的 <code>hashCode</code> 进行扰动后作为 <code>hash</code> 值。<code>HashTable</code> 是直接使用 key 的 <code>hashCode()</code> 返回值作为 hash 值。</li>
<li>  <code>HashMap</code>默认容量为 2^4 且容量一定是 2^n ; <code>HashTable</code> 默认容量是11,不一定是 2^n。</li>
<li>  <code>HashTable</code> 取哈希桶下标是直接用模运算,扩容时新容量是原来的2倍+1。<code>HashMap</code> 在扩容的时候是原来的两倍，且哈希桶的下标使用 &amp;运算代替了取模。</li>
<li>  <code>Hashtable</code>是<code>Dictionary</code>的子类同时也实现了<code>Map</code>接口，<code>HashMap</code>是<code>Map</code>接口的一个实现类。</li>
</ul>
<h2 id="面试题答案"><a href="#面试题答案" class="headerlink" title="面试题答案"></a>面试题答案</h2><ul>
<li>  <strong>HashMap的底层数据结构？</strong></li>
</ul>
<blockquote>
<p>  ​    数组 + 链表 + 红黑树</p>
</blockquote>
<ul>
<li>  <strong>HashMap的主要方法？</strong></li>
</ul>
<blockquote>
<p>  ​    put()、resize()、treeifyBin()、get()、remove()等等</p>
</blockquote>
<ul>
<li>  <strong>HashMap 是如何确定元素存储位置的以及如何处理哈希冲突的？</strong></li>
</ul>
<blockquote>
<p>  ​    是通过hashcode和扰乱函数确定的，先计算好key的hashCode,然后将hashCode的低16位和高16位进行相异或，异或完成后再进行取模(其实也就是与容量-1进行相与[有0则全为0，全1才为1])。一句话总结就是：<code>取key的hashCode值、高位运算、取模运算</code></p>
</blockquote>
<ul>
<li>  <strong>HashMap 扩容机制是怎样的？</strong></li>
</ul>
<blockquote>
<p>  ​    先判断是否超过了整数型的最大值，如果没有，再判断是否已经超过了扩容阈值，如果超过了，则直接扩容两倍，扩容的数量都是2的n次方，HashMap都是优先扩容的，然后其次才是树化等等。</p>
<p>  总的来说分为两步：<code>1. 寻找扩容后数组的大小以及新的扩容阈值，2. 将原有哈希表拷贝到新的哈希表中。</code></p>
</blockquote>
<ul>
<li><p><strong>JDK 1.8 在扩容和解决哈希冲突上对 HashMap 源码做了哪些改动？有什么好处?</strong></p>
<blockquote>
<ol>
<li>  在扩容方面，由于是选用了2的n次方作为桶的数量，所以在取模的时候就非常方便了，直接看hashCode的前一位是1或者0就可以判断在扩容后的新位置，无需重新取模运算；</li>
<li>  HashMap 在 1.7的时候扩容后，链表的节点顺序会倒置，1.8则不会出现这种情况。因为1.7是后进先出，1.8是先进先出。1.7是头插法，1.8是尾插法；</li>
<li>  JDK1.8用&amp; (length-1) 代替了取模运算</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li>  <strong>什么时候会使用HashMap？他有什么特点？</strong></li>
</ul>
<blockquote>
<p>  ​    基于Map接口实现的Key-Value容器，允许为空值，同时非有序，线程不安全，非同步。</p>
</blockquote>
<ul>
<li>  <strong>你知道HashMap的工作原理吗？</strong></li>
</ul>
<blockquote>
<p>  ​    经过HashCode和扰乱函数，得到相应的索引位置，然后插入，如果非空直接插入即可，如果是有数据，则判断是链表还是红黑树，如果链表超过8则先判断是否需要扩容，如果不需要就将链表变成红黑树！</p>
</blockquote>
<ul>
<li>  <strong>你知道get和put的原理吗？equals()和hashCode()都有什么作用？</strong></li>
</ul>
<blockquote>
<p>  ​    通过对key的**hashCode()<strong>进行哈希处理，并计算下标（n-1＆hash），从而获得存储桶的位置。如果产生碰撞，则利用</strong>key.equals()**方法去链表或树中去查找对应的队列。</p>
</blockquote>
<ul>
<li>  <strong>你知道hash的实现吗？为什么要这样实现？</strong></li>
</ul>
<blockquote>
<p>  ​    在Java 1.8的实现中，是通过hashCode（）的高16位异或低16位实现的：（h = k.hashCode（））^（h &gt;&gt;&gt; 16），主要是从速度，效益，质量来考虑的，这样做可以在bucket的n比较小的时候，也能保证考虑到高低位都参与到hash的计算中，同时不会有太大的开销。</p>
</blockquote>
<ul>
<li>  <strong>你了解重新调整HashMap大小存在什么问题吗？</strong></li>
</ul>
<blockquote>
<ul>
<li>  当数据过多时，很可能出现性能下降（包括rehash时间）</li>
</ul>
<ul>
<li><p>多线程情况下可能产生条件竞争竞争从而造成死循环（具体表现在CPU接近100％)</p>
<p>  <a href="https://juejin.cn/post/6844903554264596487">老生常谈，HashMap的死循环</a></p>
</li>
</ul>
</blockquote>
<ul>
<li>  <strong>为什么String, Interger这样的wrapper类适合作为键？</strong></li>
</ul>
<blockquote>
<ul>
<li>  class具有final属性，同时重写equals()和hashCode()</li>
</ul>
<ul>
<li>  hashCode变动会导致读取失效</li>
<li>final同时保证线程安全<br>  <strong>对象推荐重写equals和hashCode方法，主要用于Map存取时的对比，同时有利于减少碰撞</strong></li>
</ul>
</blockquote>
<ul>
<li>  <strong>.我们可以使用自定义的对象作为键吗？</strong></li>
</ul>
<blockquote>
<ul>
<li>  这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了</li>
<li>  典型实例就是ThreadLocal，读者可参见笔者的 <a href="https://www.zybuluo.com/kiraSally/note/854555">并发番@ThreadLocal一文通（1.7版）</a></li>
</ul>
</blockquote>
<ul>
<li>  <strong>HashMap的remove陷阱？</strong></li>
</ul>
<blockquote>
<ul>
<li>  通过Iterator方式可正确遍历完成remove操作</li>
<li>  直接调用list的remove方法就会抛异常</li>
</ul>
</blockquote>
<ul>
<li>  <strong>为什么只允许通过iterator进行remove操作？</strong></li>
</ul>
<blockquote>
<ul>
<li>  HashMap和keySet的remove方法都可以通过传递key参数删除任意的元素</li>
<li>  而iterator只能删除当前元素(current)，一旦删除的元素是iterator对象中next所正在引用的，如果没有通过modCount、 expectedModCount的比较实现快速失败抛出异常，下次循环该元素将成为current指向，此时iterator就遍历了一个已移除的过期数据</li>
<li>之所以推荐迭代器remove的根本原因在于只有迭代器的remove方法中实现了变更时于modCount的同步工作<br>  <code>expectedModCount = modCount;</code></li>
</ul>
</blockquote>
<ul>
<li>  <strong>如果是遍历过程中增加或修改数据呢？</strong></li>
</ul>
<blockquote>
<p>  增加或修改数据只能通过Map的put方法实现，在遍历过程中修改数据可以，但如果增加新key就会在下次循环时抛异常，因为在添加新key时modCount也会自增(迭代器只实现了remove方法也是原因之一)</p>
</blockquote>
<ul>
<li>  <strong>有什么方法可以减少碰撞？</strong></li>
</ul>
<blockquote>
<ul>
<li><p>扰动函数可以减少碰撞</p>
<p>  原理是如果两个不相等的对象返回不同的 hashcode 的话，那么碰撞的几率就会小些。这就意味着存链表结构减小，这样取值的话就不会频繁调用 equal 方法，从而提高 HashMap 的性能（扰动即 Hash 方法内部的算法实现，目的是让不同对象返回不同hashcode）。</p>
</li>
<li><p>使用不可变的、声明作 final 对象，并且采用合适的 equals() 和 hashCode() 方法，将会减少碰撞的发生</p>
<p>  <strong>不可变性</strong>使得能够缓存不同键的 hashcode，这将提高整个获取对象的速度，使用 String、Integer 这样的 wrapper 类作为键是非常好的选择。</p>
</li>
</ul>
</blockquote>
<ul>
<li>  <strong>HashMap为什么线程不安全的</strong>？</li>
</ul>
<blockquote>
<ol>
<li>  Put时多线程操作可能导致数据不一致</li>
<li>  Get时可能会因为扩容导致死循环（cpu为100%）</li>
<li>  put非null元素后get出来的却是null   <a href="https://www.cnblogs.com/alexlo/p/4955391.html">并发安全问题之HashMap</a></li>
</ol>
</blockquote>
<ul>
<li>  <strong>可以使用CocurrentHashMap 来代替 Hashtable 吗？</strong></li>
</ul>
<blockquote>
<ul>
<li>  我们知道 Hashtable 是 synchronized 的，但是 ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对 map 的一部分进行上锁。</li>
</ul>
<ul>
<li>  ConcurrentHashMap 当然可以代替 HashTable，但是 HashTable 提供更强的线程安全性</li>
<li>  它们都可以用于多线程的环境，但是当 Hashtable 的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。 由于 ConcurrentHashMap 引入了分割（segmentation），不论它变得多么大，仅仅需要锁定 Map 的某个部分，其它的线程不需要等到迭代完成才能访问 Map。 简而言之，在迭代的过程中，ConcurrentHashMap 仅仅锁定 Map 的某个部分，而 Hashtable 则会锁定整个 Map。</li>
</ul>
</blockquote>
<p>贴一个复习时可以看的问答</p>
<blockquote>
<p>  <a href="https://cloud.tencent.com/developer/article/1491634">https://cloud.tencent.com/developer/article/1491634</a></p>
</blockquote>
<h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><p>接下来我们一起来分析一波 <strong>TreeMap</strong> ！！！    </p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/nullllun/p/8251212.html">TreeMap 源码分析</a></p>
<p><a href="https://blog.csdn.net/qq_32166627/article/details/72773293">java集合（6）：TreeMap源码分析（jdk1.8）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247483909&idx=1&sn=65fd18c4e83218ac70d18bf0f02d5b13&chksm=e80db473df7a3d6541c8c8330c1896ca26c9b99ab976b8171bb8defd2b16574fe3e1d0a1bbe7&scene=21#wechat_redirect">如何决定使用HashMap Or TreeMap</a></p>
<h2 id="问题引导-1"><a href="#问题引导-1" class="headerlink" title="问题引导"></a>问题引导</h2><ul>
<li>  如何决定使用 HashMap 还是 TreeMap？</li>
<li>  TreeMap的特点</li>
</ul>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="/2022/07/31/Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220730164326813.png" alt="image-20220730164326813"></p>
<ol>
<li> TreeMap 底层基于<code>红黑树</code>实现</li>
<li> 该集合最重要的特点就是<strong>可排序</strong>，该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</li>
<li> TreeMap 继承了 AbstractMap，同时实现了 NavigableMap (导航 map )，而 NavigableMap 则是继承了 SortedMap ,而 SortedMap 和 AbstractMap 则是实现了 Map 接口。</li>
<li> NavigableMap 接口，NavigableMap 接口声明了一些列具有导航功能的方法，通过这些导航方法，我们可以快速定位到目标的 key 或 Entry。比如：</li>
</ol>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><code>JDK 1.8</code>中的<code>TreeMap</code>源码有两千多行，还是比较多的。TreeMap实现的核心部分是关于<code>红黑树</code>的实现，其绝大部分的方法基本都是对底层红黑树增、删、查操作的一个封装。如简介一节所说，只要弄懂了红黑树原理，TreeMap 就没什么秘密了。关于<code>红黑树</code>的原理，请参考本人的另一篇文章 <a href="https://jeromememory.github.io/2020/01/16/%E7%BA%A2%E9%BB%91%E6%A0%91.html">红黑树详细分析</a>。</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><code>TreeMap</code>基于红黑树实现，而红黑树是一种自平衡二叉查找树，所以 TreeMap 的查找操作流程和二叉查找树一致。二叉树的查找流程是这样的，先将目标值和根节点的值进行比较，如果目标值小于根节点的值，则再和根节点的左孩子进行比较。如果目标值大于根节点的值，则继续和根节点的右孩子比较。在查找过程中，如果目标值和二叉树中的某个节点值相等，则返回 true，否则返回 false。TreeMap 查找和此类似，只不过在 TreeMap 中，节点（Entry）存储的是键值对。在查找过程中，比较的是键的大小，返回的是值，如果没找到，则返回<code>null</code>。TreeMap 中的查找方法是<code>get</code>，具体实现在<code>getEntry</code>方法中，相关源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找操作的核心逻辑就在这个 while 循环里</span></span><br><span class="line">    <span class="comment">// key 与 root 作比较</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul>
<li>  <em>Iterator</em> 顺序遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap map = <span class="keyword">new</span> TreeMap();</span><br><span class="line">Set set = map.entrySet();</span><br><span class="line">Iterator iter = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">    Object key = entry.getKey();</span><br><span class="line">    Object value = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <em>foreach</em> 遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历Map 第二种方式</span></span><br><span class="line">Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">map1.put(<span class="string">&quot;jack&quot;</span>, <span class="number">20</span>);</span><br><span class="line">map1.put(<span class="string">&quot;rose&quot;</span>, <span class="number">18</span>);</span><br><span class="line">map1.put(<span class="string">&quot;lucy&quot;</span>, <span class="number">17</span>);</span><br><span class="line">map1.put(<span class="string">&quot;java&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Map.Entry(String,Integer) 获取，然后使用entry.getKey()获取到键，通过entry.getValue()获取到值</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : map1.entrySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;键 key ：&quot;</span>+entry.getKey()+<span class="string">&quot; 值value ：&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码片段中可以看出，大家一般都是对 TreeMap 的 key 集合或 Entry 集合进行遍历。上面代码片段中用 foreach 遍历 entrySet 方法产生的集合，在编译时会转换成用迭代器遍历，等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set entry = map.entrySet();</span><br><span class="line">Iterator ite = entry.iterator();</span><br><span class="line"><span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">    Object key = entry.getKey();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一方面，TreeMap 有一个特性，即可以保证键的有序性，默认是正序。所以在遍历过程中，大家会发现 TreeMap 会从小到大输出键的值。那么，接下来就来分析一下<code>keySet</code>方法，以及在遍历 keySet 方法产生的集合时，TreeMap 是如何保证键的有序性的。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> navigableKeySet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;K&gt; <span class="title">navigableKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    KeySet&lt;K&gt; nks = navigableKeySet;</span><br><span class="line">    <span class="keyword">return</span> (nks != <span class="keyword">null</span>) ? nks : (navigableKeySet = <span class="keyword">new</span> KeySet&lt;&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NavigableMap&lt;E, ?&gt; m;</span><br><span class="line">    KeySet(NavigableMap&lt;E,?&gt; map) &#123; m = map; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m <span class="keyword">instanceof</span> TreeMap)</span><br><span class="line">            <span class="keyword">return</span> ((TreeMap&lt;E,?&gt;)m).keyIterator();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ((TreeMap.NavigableSubMap&lt;E,?&gt;)m).keyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略非关键代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator&lt;K&gt; <span class="title">keyIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(getFirstEntry());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    KeyIterator(Entry&lt;K,V&gt; first) &#123;</span><br><span class="line">        <span class="keyword">super</span>(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry().key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    Entry&lt;K,V&gt; lastReturned;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">    PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        next = first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="comment">// 寻找节点 e 的后继节点</span></span><br><span class="line">        next = successor(e);</span><br><span class="line">        lastReturned = e;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the successor of the specified Entry, or null if no such.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">            <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">            Entry&lt;K,V&gt; ch = t;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">                ch = p;</span><br><span class="line">                p = p.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码比较多，keySet 涉及的代码还是比较多的，大家可以从上往下看。从上面源码可以看出 keySet 方法返回的是<code>KeySet</code>类的对象。这个类实现了<code>Iterable</code>接口，可以返回一个迭代器。该迭代器的具体实现是<code>KeyIterator</code>，而 KeyIterator 类的核心逻辑是在<code>PrivateEntryIterator</code>中实现的。上面的代码虽多，但核心代码还是 KeySet 类和 PrivateEntryIterator 类的 <code>nextEntry</code>方法。KeySet 类就是一个集合，这里不分析了。而 nextEntry 方法比较重要，下面简单分析一下。</p>
<p>在初始化 KeyIterator 时，会将 TreeMap 中包含最小键的 Entry 传给 PrivateEntryIterator。当调用 nextEntry 方法时，通过调用 successor 方法找到当前 entry 的后继，并让 next 指向后继，最后返回当前的 entry。通过这种方式即可实现按正序返回键值的的逻辑。</p>
<h3 id="插入与删除"><a href="#插入与删除" class="headerlink" title="插入与删除"></a>插入与删除</h3><p>其实就是红黑树的插入和删除，具体红黑树的插入和删除见我另写的红黑树文章。</p>
<p>TreeMap在删除的时候，采用的也是找后继节点。</p>
<h3 id="自定义比较器"><a href="#自定义比较器" class="headerlink" title="自定义比较器"></a>自定义比较器</h3><ul>
<li>  在实体类对象中实现Comparable接口并实现了compareTo()方法【String，Integer对象就是此种方式】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeMap2_Comparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;User, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="keyword">new</span> User(<span class="string">&quot;jerome&quot;</span>, <span class="number">30</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> User(<span class="string">&quot;memory&quot;</span>, <span class="number">30</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> User(<span class="string">&quot;aa&quot;</span>, <span class="number">22</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> User(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;User, String&gt; each : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(each.getKey()+<span class="string">&quot;::&quot;</span>+each.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User [username=&quot;</span> + username + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先比较 age ，再比较 username</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="keyword">this</span>.age - user.age;</span><br><span class="line">        <span class="keyword">return</span> temp == <span class="number">0</span> ? <span class="keyword">this</span>.username.compareTo(user.username) : temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">User [username=bb, age=<span class="number">20</span>]::hello</span><br><span class="line">User [username=aa, age=<span class="number">22</span>]::hello</span><br><span class="line">User [username=jerome, age=<span class="number">30</span>]::hello</span><br><span class="line">User [username=memory, age=<span class="number">30</span>]::hello</span><br></pre></td></tr></table></figure>

<ul>
<li>  写一个类实现java.util.Comparator接口(注意这里是Comparator，上面是Comparable)，并将该类对象传递给TreeMap的构造方法。这种方式将实体类和比较机制解耦合，可以写很多个不同的比较器对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeMap2_Comparator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;User2, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> TreeMapComparator());</span><br><span class="line"></span><br><span class="line">        map.put(<span class="keyword">new</span> User2(<span class="string">&quot;jerome&quot;</span>, <span class="number">30</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> User2(<span class="string">&quot;memory&quot;</span>, <span class="number">30</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> User2(<span class="string">&quot;aa&quot;</span>, <span class="number">22</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> User2(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;User2, String&gt; each : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(each.getKey()+<span class="string">&quot;::&quot;</span>+each.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User2</span> </span>&#123;  <span class="comment">// User对象不再实现任何接口</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User2</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User2 [username=&quot;</span> + username + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeMapComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">User2</span>&gt; </span>&#123;  <span class="comment">// 比较器类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User2 o1, User2 o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = o1.getAge() - o2.getAge();</span><br><span class="line">        <span class="keyword">return</span> temp == <span class="number">0</span> ? o1.getUsername().compareTo(o2.getUsername()) : temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  不写比较器类，而是使用匿名内部类的形式来写比较器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeMap2_InnerComparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;User3, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;User3&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User3 o1, User3 o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = o1.getAge() - o2.getAge();</span><br><span class="line">                <span class="keyword">return</span> temp == <span class="number">0</span> ? o1.getUsername().compareTo(o2.getUsername()) : temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="keyword">new</span> User3(<span class="string">&quot;jimmy1&quot;</span>, <span class="number">30</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> User3(<span class="string">&quot;jimmy2&quot;</span>, <span class="number">30</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> User3(<span class="string">&quot;jimmy&quot;</span>, <span class="number">22</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> User3(<span class="string">&quot;jimmy&quot;</span>, <span class="number">20</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;User3, String&gt; each : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(each.getKey() + <span class="string">&quot;::&quot;</span> + each.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User3</span> </span>&#123;  <span class="comment">// User对象不再实现任何接口</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User3</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User3 [username=&quot;</span> + username + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>HashMap 和 TreeMap 有迭代器吗？</strong></p>
<p>  keySet()和entrySet()方法，在将HashMap的时候已经讲过了，Map没有迭代器，要将Map转化为Set，用Set的迭代器才能进行元素迭代。</p>
</li>
<li><p><strong>如何决定使用 HashMap 还是 TreeMap？</strong></p>
<p>  都是非线程安全的，如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，故大多不需要排序的时候我们会使用HashMap。</p>
</li>
<li><p><strong>TreeMap的特点？</strong></p>
<p>  非线程安全，可排序，正常情况下不允许重复(默认没有重写比较器)，底层采用的是红黑树。因为其非线程安全，故可以允许null值，这个跟HashMap、ArrayList、LinkedList是一样的。</p>
<p>  Map 的 key 值都是不可以重复的，故 Set 与 List 最大的区别就是一个数据不可重复，一个是可以重复的。</p>
</li>
<li><p>  HashMap、TreeMap、ConcurrentHashMap、HashTable、ArrayDeque、ArrayList、LinkedList、Vector线程安全问题以及 key、value 是否能为空？</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">集合类型</th>
<th align="center">是否线程安全</th>
<th align="center">key、value是否可以为空</th>
<th align="center">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HashMap</td>
<td align="center">否</td>
<td align="center">key、value均可以为空</td>
<td align="center">Key 可以为空，但必须唯一，value没有限制</td>
</tr>
<tr>
<td align="center">TreeMap</td>
<td align="center">否</td>
<td align="center">key不可以为空，value可以为空</td>
<td align="center">key不能为null，因为其需要排序，value可以为null</td>
</tr>
<tr>
<td align="center">ConcurrentHashMap</td>
<td align="center">是</td>
<td align="center">Key、value均不能为空</td>
<td align="center">map.get(key) == null 会存在二义性，<br />1. 可能是key对应的value是null <br />2. 可能key不存在<br />需要通过containKeys(key) 判断，但是有可能被其他线程修改而导致错误的结论<br /><a href="https://segmentfault.com/a/1190000021105716">ConcurrentHashMap的key和value不能为null</a></td>
</tr>
<tr>
<td align="center">HashTable</td>
<td align="center">是</td>
<td align="center">Key、value均不能为空</td>
<td align="center">理由同ConcurrentHashMap</td>
</tr>
<tr>
<td align="center">ArrayDeque</td>
<td align="center">否</td>
<td align="center">值不能为空</td>
<td align="center">不能存入 null，因为在add时就有判断，如果是 null，就报空指针异常</td>
</tr>
<tr>
<td align="center">ArrayList</td>
<td align="center">否</td>
<td align="center">值可以为空</td>
<td align="center">可以为空，当成一个对象加入或删除，添加null也会增加size</td>
</tr>
<tr>
<td align="center">LinkedList</td>
<td align="center">否</td>
<td align="center">值可以为空</td>
<td align="center">同ArrayList</td>
</tr>
<tr>
<td align="center">Vector</td>
<td align="center">是</td>
<td align="center">值可以为空</td>
<td align="center">同ArrayList</td>
</tr>
</tbody></table>
<p><a href="https://juejin.cn/post/6879291161274482695">fail-fast 和 fail-safe机制讲解</a></p>
<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000012964859#comment-area">LinkedHashMap源码详细分析</a></p>
<p><a href="https://juejin.im/post/5b665f865188251b1243149d">LinkedHashMap 源码解读(JDK 1.8)</a></p>
<p><a href="https://yq.aliyun.com/articles/674072">LinkedHashMap详解</a></p>
<p><a href="https://juejin.im/post/5a4b433b6fb9a0451705916f#heading-5">Java集合之LinkedHashMap</a></p>
<p><a href="https://yanglukuan.github.io/2017/09/05/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap%E8%AF%A6%E8%A7%A3/">Java集合框架之LinkedHashMap详解</a></p>
<p><a href="https://juejin.im/post/5ba0ad6b5188255c8066586f">Java LinkedHashMap类源码解析</a></p>
<p><a href="https://zouzls.github.io/2017/07/20/Java8%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B9%8BLinkedHashMap/">Java8集合系列之LinkedHashMap</a></p>
<p><a href="https://blog.csdn.net/qq_33206732/article/details/80338354">LinkedHashMap、ConcurrentHashMap概括</a></p>
<h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul>
<li>  LinkedHashMap是HashMap的一个子类，它保留<strong>插入或者访问</strong>顺序，帮助我们实现了<strong>有序</strong>的HashMap。</li>
<li>  其维护一个双向链表，并不是说其除了维护存入的数据，另外维护了一个双向链表对象，而是说其根据重写HashMap的实体类Entry，来实现能够将HashMap的数据组成一个双向列表，其存储的结构还是<strong>数组+链表+红黑树</strong>的形式，也就是链表上的节点有三个指针，分别是before、after、next。</li>
</ul>
<h2 id="与-HashMap-的区别"><a href="#与-HashMap-的区别" class="headerlink" title="与 HashMap 的区别"></a>与 HashMap 的区别</h2><p>这里用一个 demo 呈现出 LinkedHashMap 的有序的特点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//      LinkedHashMap&lt;String,Integer&gt; map = new LinkedHashMap(16, 0.75f,true);</span></span><br><span class="line">        LinkedHashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        map.put(<span class="string">&quot;huawei&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        map.put(<span class="string">&quot;xiaomi&quot;</span>,<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//      map.get(&quot;apple&quot;);</span></span><br><span class="line"><span class="comment">//      map.get(&quot;xiaomi&quot;);</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry a:map.entrySet())&#123;</span><br><span class="line">            System.out.println(a.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">输出为：</span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">5000</span></span><br><span class="line"><span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到，在使用上，LinkedHashMap和HashMap的区别就是LinkedHashMap是有序的。</strong> 上面这个例子是根据插入顺序排序，此外，LinkedHashMap还有一个参数(accessOrder)决定<strong>是否在此基础上再根据访问顺序(get,put)排序</strong>,记住，是在插入顺序的基础上再排序，后面看了源码就知道为什么了。看下例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap(<span class="number">16</span>, <span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//        LinkedHashMap&lt;String,Integer&gt; map = new LinkedHashMap();</span></span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        map.put(<span class="string">&quot;huawei&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        map.put(<span class="string">&quot;xiaomi&quot;</span>,<span class="number">2000</span>);</span><br><span class="line">        map.get(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        map.get(<span class="string">&quot;xiaomi&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry a:map.entrySet())&#123;</span><br><span class="line">            System.out.println(a.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">输出为：</span><br><span class="line"><span class="number">5000</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p>很明显能看出来，由于将 <em>accessOrder</em> == true，按照了读取顺序排列，最开始的顺序是 apple - huawei - xiaomi，由于读取了apple，apple则进入到尾(tail)，顺序变为 huawei - xiaomi - apple，又读取了 xiaomi，故顺序变为 huawei - apple - xiaomi ，故最后的答案是 5000 - 10000 - 2000。</p>
<h2 id="LinkedHashMap的存储结构"><a href="#LinkedHashMap的存储结构" class="headerlink" title="LinkedHashMap的存储结构"></a>LinkedHashMap的存储结构</h2><p><code>LinkedHashMap</code>之所以能实现存取的顺序性，主要是他重新定义了 <code>Entry</code> ，这个新的 <code>Entry</code> 继承自<code>HashMap.Node</code>，并做了新的扩展，下面我们结合源码来分析一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 继承自 HashMap.Node，新增了 before、after 记录插入顺序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//链表结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3801124242820219131L</span>;</span><br><span class="line"><span class="comment">//链表头部</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">//链表尾部</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问顺序</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<p>由上面的代码我们可以看出，这个自定义的 <code>Entry</code>比 <code>HashMap.Node</code>多了两个属性，<code>before</code>和<code>after</code>。正是使用这两个关键的属性，在<code>LinkedHashMap</code>内部实现了一个双向链表。双向链表就是每个节点除了存储数据本身之外，还保存着两个指针，在<code>java</code>里面就是指向对象的引用，一个是前驱节点，也就是他的前一个节点的引用，一个是后继节点，也就是他的后一个节点的引用。这样，就可以实现存储一个有序节点的数据结构了。（这里说明下，在jdk1.7中，使用的结构为环形双向链表）另外，继承自<code>HashMap.Node</code>的<code>Entry</code>自身还保留着用于维持单链表的<code>next</code>属性，因此<code>LinkedHashMap</code>的<code>Entry</code>节点具有三个指针域，<code>next</code>指针维护<code>Hash</code>桶中冲突<code>key</code>的链表，<code>before</code>和<code>after</code>维护双向链表。</p>
<h2 id="重要补充点"><a href="#重要补充点" class="headerlink" title="重要补充点"></a>重要补充点</h2><ul>
<li>  为何 <em>TreeNode</em> 这个类继承的是 LinkedHashMap 的 Entry，而不是 HashMap 中的 Node ？</li>
</ul>
<p>​        HashMap 的内部类 TreeNode 不继承它的内部类 Node，却继承自 Node 的子类 LinkedHashMap 内部类 Entry。这里这样做是有一定原因的，这里先不说。先来简单说明一下上面的继承体系。LinkedHashMap 内部类 Entry 继承自 HashMap 内部类 Node，并新增了两个引用，分别是 before 和 after。这两个引用的用途不难理解，也就是用于维护双向链表。同时，TreeNode 继承 LinkedHashMap 的内部类 Entry 后，就具备了和其他 Entry 一起组成链表的能力。但是这里需要大家考虑一个问题。当我们使用 HashMap 时，TreeNode 并不需要具备组成链表能力。如果继承 LinkedHashMap 内部类 Entry ，TreeNode 就多了两个用不到的引用，这样做不是会浪费空间吗？简单说明一下这个问题（水平有限，不保证完全正确），这里这么做确实会浪费空间，但与 TreeNode 通过继承获取的组成链表的能力相比，这点浪费是值得的。</p>
<blockquote>
<p>  Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use<br>  (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In<br>  usages with well-distributed user hashCodes, tree bins are rarely used.</p>
</blockquote>
<p>​        大致的意思是 TreeNode 对象的大小约是普通 Node 对象的2倍，我们仅在桶（bin）中包含足够多的节点时再使用。当桶中的节点数量变少时（取决于删除和扩容），TreeNode 会被转成 Node。当用户实现的 hashCode 方法具有良好分布性时，树类型的桶将会很少被使用。</p>
<p>​        通过上面的注释，我们可以了解到。一般情况下，只要 hashCode 的实现不糟糕，Node 组成的链表很少会被转成由 TreeNode 组成的红黑树。也就是说 TreeNode 使用的并不多，浪费那点空间是可接受的。假如 TreeNode 机制继承自 Node 类，那么它要想具备组成链表的能力，就需要 Node 去继承 LinkedHashMap 的内部类 Entry。这个时候就得不偿失了，浪费很多空间去获取不一定用得到的能力。</p>
<h3 id="利用LinkedHashMap实现LRU缓存-或者-LeetCode-第-146-题"><a href="#利用LinkedHashMap实现LRU缓存-或者-LeetCode-第-146-题" class="headerlink" title="利用LinkedHashMap实现LRU缓存( 或者 LeetCode 第 146 题)"></a>利用LinkedHashMap实现LRU缓存( 或者 LeetCode 第 146 题)</h3><p><strong>LRU即Least Recently Used，最近最少使用，也就是说，当缓存满了，会优先淘汰那些最近最不常访问的数据</strong>。我们的LinkedHashMap正好满足这个特性，为什么呢？当我们开启accessOrder为true时，<strong>最新访问(get或者put(更新操作))的数据会被丢到队列的尾巴处，那么双向队列的头就是最不经常使用的数据了</strong>。比如:</p>
<p>如果有1 2 3这3个Entry，那么访问了1，就把1移到尾部去，即2 3 1。每次访问都把访问的那个数据移到双向队列的尾部去，那么每次要淘汰数据的时候，双向队列最头的那个数据不就是最不常访问的那个数据了吗？换句话说，双向链表最头的那个数据就是要淘汰的数据。</p>
<p>此外，LinkedHashMap还提供了一个方法，这个方法就是为了我们实现LRU缓存而提供的，<strong>removeEldestEntry(Map.Entry eldest) 方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回 false</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxSize, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        maxElements = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 在插入结点后调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(java.util.Map.Entry eldest)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//逻辑很简单，当大小超出了Map的容量，就移除掉双向队列头部的元素，给其他元素腾出点地来。</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; maxElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> maxElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zerotomax/p/8687425.html#go9">ConcurrentHashMap 源码分析</a></p>
<p>[并发容器之ConcurrentHashMap(JDK 1.8版本)](<a href="https://juejin.im/post/5aeeaba8f265da0b9d781d16#heading">https://juejin.im/post/5aeeaba8f265da0b9d781d16#heading</a>    -7) 写的最好！</p>
<p><a href="https://toutiao.io/posts/dga4oq/preview">死磕 ConcurrentHashMap</a></p>
<p><a href="https://juejin.im/entry/59fc786d518825297f3fa968">Java 8 ConcurrentHashMap源码分析</a></p>
<p><a href="https://yq.aliyun.com/articles/673765">ConcurrentHashMap 详解一</a></p>
<p><a href="https://juejin.im/post/5c36bcc0e51d45513236ee78#heading-4">java并发之ConcurrentHashMap 1.8原理详解</a> 写的也非常有深度，可惜排版很差！！！</p>
<p><a href="https://www.zhenchao.org/2019/01/31/java/cas-based-concurrent-hashmap/">写得好</a></p>
<p>主要就是参考上面三个自己觉得写得好的！</p>
<h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>在使用 HashMap 时在多线程情况下扩容会出现 CPU 接近 100%的情况，因为 hashmap 并不是线程安全的，通常我们可以使用在 java 体系中古老的 hashtable 类，该类基本上所有的方法都采用 synchronized 进行线程安全的控制，可想而知，在高并发的情况下，每次只有一个线程能够获取对象监视器锁，这样的并发性能的确不令人满意。另外一种方式通过 Collections 的<code>Map synchronizedMap(Map m)</code>将 hashmap 包装成一个线程安全的 map。比如 SynchronzedMap 的 put 方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上 SynchronizedMap 实现依然是采用 synchronized 独占式锁进行线程安全的并发控制的。同样，这种方案的性能也是令人不太满意的。针对这种境况，Doug Lea 大师不遗余力的为我们创造了一些线程安全的并发容器，让每一个 java 开发人员倍感幸福。相对于 hashmap 来说，ConcurrentHashMap 就是线程安全的 map，其中<strong>利用了锁分段的思想提高了并发度</strong>。</p>
<p>ConcurrentHashMap 在 JDK1.7 的版本网上资料很多，有兴趣的可以去看看。 JDK 1.7 版本关键要素：</p>
<ol>
<li> segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；</li>
<li> segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。</li>
</ol>
<p>而到了 JDK 1.8 的 ConcurrentHashMap 就有了很大的变化，光是代码量就足足增加了很多。<strong>1.8 版本舍弃了 segment，并且大量使用了 synchronized，以及 CAS 无锁操作以保证 ConcurrentHashMap 操作的线程安全性</strong>。至于为什么不用 ReentrantLock 而是 Synchronzied 呢？实际上，synchronzied 做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，但不能降级，因此，使用 synchronized 相较于 ReentrantLock 的性能会持平甚至在某些情况更优，具体的性能测试可以去网上查阅一些资料。另外，底层数据结构改变为采用数组+链表+红黑树的数据形式。</p>
<h2 id="与HashMap区别"><a href="#与HashMap区别" class="headerlink" title="与HashMap区别"></a>与HashMap区别</h2><p>线程安全 与 非线程安全 的区别</p>
<h2 id="关键属性和类"><a href="#关键属性和类" class="headerlink" title="关键属性和类"></a>关键属性和类</h2><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>所有数据都存在table中，table的容量会根据实际情况进行扩容，table[i]存放的数据类型有以下3种：</p>
<ul>
<li>  *<strong>TreeBin*</strong> 用于包装红黑树结构的结点类型</li>
<li>  *<strong>ForwardingNode*</strong> 扩容时存放的结点类型，并发扩容的实现关键之一</li>
<li>  *<strong>Node*</strong> 普通结点类型，表示链表头结点</li>
</ul>
<p>作为 ConcurrentHashMap 的数据容器，采用 *<strong>懒加载*</strong> 的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为 2 的幂次方。</p>
<h3 id="nextTable"><a href="#nextTable" class="headerlink" title="nextTable"></a><strong>nextTable</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩容时使用，平时为 null，只有在扩容的时候才为非 null</span></span><br><span class="line"><span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br></pre></td></tr></table></figure>

<h3 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure>

<p>控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义：</p>
<ul>
<li>  当为负数时：-1代表正在初始化（其实也就相当于第一次扩容），-N代表有N-1个线程正在<strong>帮忙</strong>进行扩容</li>
<li>  当为0时：代表当时的table还没有被初始化</li>
<li>  当为正数时：表示初始化或者下一次进行扩容的大小</li>
</ul>
<p>sizeCtl 变量担当了 5 种角色， 设计非常精巧</p>
<p>① 首次初始化时， 其变量含义为初始容量</p>
<p>② 扩容以后， 其值为触发下一次扩容的元素数量阈值</p>
<p>③ 其正负状态， 标识了当前数组是否处于扩容状态</p>
<p>④ sizeCtl 为负值时，高16位bit反映了正在进行的扩容操作是针对哪个容量进行的</p>
<p>⑤ sizeCtl 为负值时，低 16位bit 反映了参与此次扩容的线程有多少个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> table未完成初始化:</span><br><span class="line">    sizeCtl = <span class="number">0</span>  <span class="comment">//未指定初始容量时的默认值</span></span><br><span class="line">    sizeCtl &gt; <span class="number">0</span>  <span class="comment">//指定初始容量(非传入值，是2的幂次修正值)大小的两倍</span></span><br><span class="line">    sizeCtl =- <span class="number">1</span> <span class="comment">//表明table正在初始化</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> nextTable为空:</span><br><span class="line">    <span class="keyword">if</span> 扩容时发生错误(如内存不足、table.length * <span class="number">2</span> &gt; Integer.MAX_VALUE等):</span><br><span class="line">        sizeCtl = Integer.MAX_VALUE    <span class="comment">//不必再扩容了！</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sizeCtl = table.length * <span class="number">0.75</span>  <span class="comment">//扩容阈值调为table容量大小的0.75倍</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sizeCtl = -(<span class="number">1</span>+N)  <span class="comment">//N的低RESIZE_STAMP_SHIFT位表示参与扩容线程数，后面详细介绍</span></span><br></pre></td></tr></table></figure>

<h3 id="sun-misc-Unsafe-U"><a href="#sun-misc-Unsafe-U" class="headerlink" title="sun.misc.Unsafe U"></a><strong>sun.misc.Unsafe U</strong></h3><p>在 ConcurrentHashMap 的实现中可以看到大量的 U.compareAndSwapXXXX 的方法去修改 ConcurrentHashMap 的一些属性。这些方法实际上是利用了 <em><strong>CAS 算法*</strong> 保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而 CAS 操作依赖于现代处理器指令集，通过底层</em>*CMPXCHG<strong>指令实现。CAS(V,O,N)核心思想为：</strong>若当前变量实际值 V 与期望的旧值 O 相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值 N 赋值给变量；若当前变量实际值 V 与期望的旧值 O 不相同，则表明该变量已经被其他线程做了处理，此时将新值 N 赋给变量操作就是不安全的，在进行重试**。而在大量的同步组件和并发容器的实现中使用 CAS 是通过<code>sun.misc.Unsafe</code>类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为 java 中的“指针”。该成员变量的获取是在静态代码块中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">		.......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ConcurrentHashMap 中，主要用到 CAS 算法的有三个方法：</p>
<p><strong>tabAt</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法用来获取 table 数组中索引为 i 的 Node 元素。</p>
<p><strong>casTabAt</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于 CAS 尝试更新 table 上下标为 i 的结点的值为 v。</p>
<p><strong>setTabAt</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于设置 table 上下标为 i 的结点为 v，相对于 casTabAt 方法的区别在于不关注历史值。</p>
<h3 id="Node-1"><a href="#Node-1" class="headerlink" title="Node"></a><strong>Node</strong></h3><p>Node 类实现了 Map.Entry 接口，主要存放 key-value 对，并且具有 next 域，另外可以看出很多属性都是用 volatile 进行修饰的，也就是为了保证内存可见性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeNode-1"><a href="#TreeNode-1" class="headerlink" title="TreeNode"></a><strong>TreeNode</strong></h3><p>树节点，继承于承载数据的 Node 类。而红黑树的操作是针对 TreeBin 类的，从该类的注释也可以看出，也就是 TreeBin 会将 TreeNode 进行再一次封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * Nodes <span class="keyword">for</span> use in TreeBins</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a><strong>TreeBin</strong></h3><p>这个类并不负责包装用户的 key、value 信息，而是包装的很多 TreeNode 节点。实际的 ConcurrentHashMap“数组”中，存放的是 TreeBin 对象，而不是 TreeNode 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a><strong>ForwardingNode</strong></h3><p>在扩容时才会出现的特殊节点，在转移的时候放在头部的节点，是一个空节点，其 key,value,hash 全部为 null。并拥有 nextTable 指针引用新的 table 数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="部分-final-常量"><a href="#部分-final-常量" class="headerlink" title="部分 final 常量"></a>部分 final 常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node数组最大容量：2^30=1073741824,因为第一位是符号位，所以是 30 次幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认初始值，必须是2的幂数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//数组可能最大值，需要与toArray（）相关方法关联</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//并发级别，遗留下来的，为兼容以前的版本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 链表转红黑树阀值,&gt; 8 链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 2^15-1，help resize的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 32-16=16，sizeCtl中记录size大小的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">// forwarding nodes的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; </span><br><span class="line"><span class="comment">// 树根节点的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; </span><br><span class="line"><span class="comment">// ReservationNode的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; </span><br><span class="line"><span class="comment">// 可用处理器数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>

<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在使用 ConcurrentHashMap 第一件事自然而然就是 new 出来一个 ConcurrentHashMap 对象，一共提供了如下几个构造器方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span></span><br><span class="line">ConcurrentHashMap()</span><br><span class="line"><span class="comment">// 2. 给定map的大小</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity)</span><br><span class="line"><span class="comment">// 3. 给定一个map</span></span><br><span class="line">ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br><span class="line"><span class="comment">// 4. 给定map的大小以及加载因子</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span><br><span class="line"><span class="comment">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程，jdk1.8基本不用）</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap 一共给我们提供了 5 种构造器方法，具体使用请看注释，我们来看看第 2 种构造器，传入指定大小时的情况，该构造器源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 小于0直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">	<span class="comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span></span><br><span class="line">  <span class="comment">// 至于为什么这样取这个值...暂时我还没搞懂，后面也有tryPresize()也是这样</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">	<span class="comment">//3. 赋值给sizeCtl</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑请看注释，很容易理解，如果小于 0 就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将 cap 赋值给 sizeCtl,关于 sizeCtl 的说明请看上面的说明，<strong>当调用构造器方法之后，sizeCtl 的大小应该就代表了 ConcurrentHashMap 的大小，即 table 数组长度</strong>。tableSizeFor 做了哪些事情了？源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two table size for the given desired capacity.</span></span><br><span class="line"><span class="comment"> * See Hackers Delight, sec 3.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个 2 的幂次方数，也就是说 ConcurrentHashMap 的大小一定是 2 的幂次方，比如，当指定大小为 18 时，为了满足 2 的幂次方特性，实际上 concurrentHashMapd 的大小为 2 的 5 次方（32）。另外，需要注意的是，<strong>调用构造器方法的时候并未构造出 table 数组（可以理解为 ConcurrentHashMap 的数据容器），只是算出 table 数组的长度，当第一次向 ConcurrentHashMap 插入数据的时候才真正的完成初始化创建 table 数组的工作</strong>。</p>
<h3 id="初始化table"><a href="#初始化table" class="headerlink" title="初始化table"></a>初始化table</h3><p>整体流程如下：</p>
<ol>
<li> 判断 sizeCtl 值是否小于 0，如果小于 0 则表示 ConcurrentHashMap 正在执行初始化操作，所以需要先等待一会，如果其它线程初始化失败还可以顶替上去</li>
<li> 如果 sizeCtl 值大于等于 0，则基于 CAS 策略抢占标记 sizeCtl 为 -1，表示 ConcurrentHashMap 正在执行初始化，然后构造 table，并更新 sizeCtl 的值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="comment">// 1. 保证只有一个线程正在进行初始化操作，发现sizeCtl为负数时，得让出时间片等待</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// 2. 得出数组的大小</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">					<span class="comment">// 3. 这里才真正的初始化数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">					<span class="comment">// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-【重点，有很多引申，包括扩容】"><a href="#put-【重点，有很多引申，包括扩容】" class="headerlink" title="put() 【重点，有很多引申，包括扩容】"></a>put() 【重点，有很多引申，包括扩容】</h3><p>先放源码，然后我们慢慢来分析一波，这是整个 ConcurrentHashMap() 的核心，我们以点推面，将 put() 用到的比较有代表性的函数都挑出来讲一讲！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode()); <span class="comment">//1.两次hash，减少hash冲突，可以均匀分布，后面会讲</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>; <span class="comment">//用于记录元素个数,也就是链表长度</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class="comment">//对这个table进行迭代</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//2.这里就是上面构造方法没有进行初始化，在这里进行判断，为null就调用initTable进行初始化，属于懒汉模式初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable(); <span class="comment">//上面已经讲过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;<span class="comment">//3.如果i位置没有数据，就直接无锁CAS插入,上文已经讲过了</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">//4.如果在进行扩容(当前节点是forwardingNode)，则先进行扩容操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);  <span class="comment">//后面会详解</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//5.如果以上条件都不满足，那就要进行加锁操作，即存在hash冲突，锁住链表或者红黑树的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">//f改变再次循环</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">//表示该节点是链表结构(红黑树 -2，或者正在转移都为负数)</span></span><br><span class="line">                        binCount = <span class="number">1</span>;  </span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//这里涉及到相同的key进行put就会覆盖原先的value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) <span class="comment">//只有不存在的时候才插入</span></span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;  <span class="comment">//插入链表尾部</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;<span class="comment">//红黑树结构</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//红黑树结构旋转插入</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; <span class="comment">//6.如果链表的长度大于8时就会进行红黑树的转换</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);<span class="comment">//7.统计size，并且检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>故整个 put() 的流程分为 7 步：</p>
<p>1.调用 ***spread()***，进行两次哈希</p>
<p>2.如果没有初始化就先调用 *<strong>initTable()*</strong> 方法来进行初始化过程</p>
<p>3.如果没有hash冲突就直接 *<strong>CAS 插入*</strong></p>
<p>4.如果还在进行扩容操作就先进行扩容</p>
<p>5.如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入</p>
<p>6.最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环</p>
<p>7.如果添加成功就调用 *<strong>addCount()*</strong> 方法统计 size，并且检查是否需要扩容</p>
<p>接下来针对每一步进行细致的分析，包括内部函数的具体实现！</p>
<h4 id="spread"><a href="#spread" class="headerlink" title="spread()"></a>spread()</h4><p>首先是 spread() 函数！先上源码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是我们在 HashMap 章节讲过的，将 hashcode 值的低16位和高16位 <em>相异或</em>，也称之为 扰动函数！</p>
<h4 id="initTable-amp-tabAt-amp-casTabAt"><a href="#initTable-amp-tabAt-amp-casTabAt" class="headerlink" title="initTable() &amp; tabAt() &amp; casTabAt()"></a>initTable() &amp; tabAt() &amp; casTabAt()</h4><p>上文已经讲过这三个函数了，让我们 go on！！</p>
<h4 id="helpTransfer"><a href="#helpTransfer" class="headerlink" title="helpTransfer()"></a>helpTransfer()</h4><p>如果在进行扩容，则先进行扩容操作，这个函数就是帮助扩容的！这样可以提高扩容的速度！</p>
<p>该方法的主要作用就是基于 CAS 尝试添加一个线程去协助扩容操作，如果能够成功加入则将 sizeCtl 值加 1。方法 <code>transfer</code> 是真正执行扩容操作的地方，并在多个步骤中被触发。这里先给出该方法的定义（如下），具体的实现后面会专门进行分析，该方法接收 2 个参数，其中 tab 是当前需要被扩容的 table，而 nextTab 是扩容之后的 table，容量上是之前的两倍，helpTransfer 传递的 nextTab 是一个非 null 值，因为触发 helpTransfer 的前提就是当前已经处于扩容阶段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helps transfer if a resize is in progress.</span></span><br><span class="line"><span class="comment"> * 帮助从旧的table的元素复制到新的table中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 新的table nextTab已经存在前提下才能帮助扩容</span></span><br><span class="line">    <span class="comment">// 当前结点是 ForwardingNode 类型</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length); <span class="comment">// 下面会讲，扩容戳</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 条件1判断是否为当前扩容戳</span></span><br><span class="line">            <span class="comment">// 条件2判断是否扩容结束</span></span><br><span class="line">            <span class="comment">// 条件3判断扩容线程是否已经超过最大并发扩容线程数 (这其实是一个bug,见下面详解)</span></span><br><span class="line">            <span class="comment">// 条件4判断当前是否有可以分配的任务</span></span><br><span class="line">            <span class="comment">// sc=((rs=resizeStamp())&lt;&lt;&lt;RESIZE_STAMP_SHIFT ) </span></span><br><span class="line">            <span class="comment">// sc 高16位用于记录本次扩容戳,低16位用于记录扩容线程数量,rs = sc - 1</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 基于 CAS 将 扩容线程数 + 1，说明又有一个线程加入扩容了</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);<span class="comment">// 调用扩容方法，扩容最核心的函数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 helptransfer() 中，调用了 *<strong>resizeStamp()*</strong> 函数(当然还有 ***transfer()***，这个是扩容核心代码，下面单独会拎出来讲)，我们现在分析一下这两个函数！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Table Initialization and Resizing -------------- */</span></span><br><span class="line"><span class="comment">// 生成表的扩容戳，每个n都有不同的扩容戳</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the stamp bits for resizing a table of size n.</span></span><br><span class="line"><span class="comment">   * Must be negative when shifted left by RESIZE_STAMP_SHIFT.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>*<strong>Integer.numberOfLeadingZeros(n)*</strong> 在指定 int 值的二进制补码表示形式中最高位（最左边）的 1 位之前，返回零位的数量。具体我也不懂啥意思，反正就是会生成一个特殊的扩容戳！</p>
<h4 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin()"></a>treeifyBin()</h4><p>来到这里，就是 put() 的第六步了，上源码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">copyprivate <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K, V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; b;</span><br><span class="line">    <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 如果 table 长度小于 64，执行扩容操作</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 否则，将链表转换成红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点 hash 大于 0，说明是链表</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K, V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 将链表转换成一棵红黑树</span></span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K, V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K, V&gt; p = <span class="keyword">new</span> TreeNode&lt;&gt;(e.hash, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hd = p;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将红黑树设置到 table 对应的位置</span></span><br><span class="line">                    <span class="comment">// 注意哦，数组中存储的可是 TreeBin</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细心的小伙伴发现了，这里又有一个扩容操作的函数 tryPresize() ，来，咱不能放过它，进去看看！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前期望的大小（size）小于最大允许容量的一半，则扩容大小为 size 的 1.5 倍加 1，在向上取最小的 2 次幂,注意哦，这里的 size 传进来的时候就已经是原数组的两倍大小了！！！</span></span><br><span class="line">  	<span class="comment">// 这里我没搞清他要干嘛... 因为 c 可是一次性扩了好多倍</span></span><br><span class="line">    <span class="comment">// 真正去执行扩容的还是 transfer 这个函数</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123; <span class="comment">// 检查当前未处于扩容阶段</span></span><br><span class="line">        Node&lt;K, V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 初始化 nextTable</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node&lt;?, ?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 2. 基于 CAS 将 sc 的值加 1，然后执行 transfer 方法</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K, V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span></span><br><span class="line">                        || sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span></span><br><span class="line">                        || transferIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 执行 transfer 方法</span></span><br><span class="line">                    <span class="keyword">this</span>.transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. 基于 CAS 将 sizeCtl 的值设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="comment">// 执行 transfer 方法，此时 nextTable 是 null</span></span><br><span class="line">                <span class="keyword">this</span>.transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的核心操作在于最后一个添加 transfer 任务，并设置 sizeCtl 值，该方法第一次调用 transfer 方法时 sizeCtl 一定是大于等于 0 的，所以方法会尝试将 sizeCtl 设置为 <code>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code>，这是大负数，并执行 <code>transfer(tab, null)</code> 操作，后面的循环 sizeCtl 均小于 0，所以会执行 <code>transfer(tab, nt)</code>，并将 sizeCtl 加 1。注意整个过程中 sizeCtl 值的变化，在一次扩容操作中第一次调用 transfer 方法时将 sizeCtl 设置为 <code>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code>，并在扩容过程再次调用 transfer 方法时将 sizeCtl 加 1。这对于下一节理解扩容操作什么时候结束至关重要。</p>
<h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer()"></a>transfer()</h4><p>来了，它终于来了…在之前我们已经铺垫了很久了，本来是打算再放到后面一点的，因为在 put() 的第七步 addCount() 方法中也调用了这个方法，但是… 我忍不住了！！！</p>
<p>在讲 transfer() 之前，我们来回顾一下总共有哪些函数调用了它，也就是我们需要在什么时候扩容呢？</p>
<ul>
<li>  **helpTransfer()**。当一个线程要对table中元素进行操作的时候，如果检测到节点的HASH值为MOVED的时候，就会调用helpTransfer方法，在helpTransfer中再调用transfer方法来帮助完成数组的扩容。</li>
<li>  **tryPresize()**。treeIfybin 和 putAll 方法中调用，treeIfybin 主要是在put添加元素完之后，判断该数组节点相关元素是不是已经超过8个的时候，如果超过则会调用这个 tryPresize 方法来扩容数组或者把链表转为树。</li>
<li>  **addCount()**。当对数组进行操作，使得数组中存储的元素个数发生了变化的时候会调用的方法。</li>
</ul>
<p>总结一下，也就是两种情况：</p>
<ul>
<li>  只有在往map中添加元素的时候，在某一个节点的数目已经超过了8个，同时数组的长度又小于64的时候，才会触发数组的扩容。</li>
<li>  当数组中元素达到了sizeCtl的数量的时候，则会调用transfer方法来进行扩容。</li>
</ul>
<p>扩容操作简单地说就是新建一个长度翻倍的 nextTable，然后将之前 table 上的结点重新哈希迁移到新的 nextTable 上，并在迁移完成之后使用 nextTable 替换原先的 table。对于一个 table 而言，上面分布着 n 个 bin 结点，而结点迁移的过程可以是并发的，这样可以提升迁移的效率。ConcurrentHashMap 使用了一个 stride 变量用于指定将 stride 个 bin 结点组成一个任务单元由一个线程负责处理，在单核 CPU 下 stride 的值为 table 的长度 n，在多核 CPU 下为 <code>(n &gt;&gt;&gt; 3) / NCPU</code>，最小值为 16。</p>
<p>ConcurrentHashMap 定义了一个类实例变量 transferIndex，用于指定任务的边界。任务划分的过程在 table 上是从后往前进行的，例如现在有 n 个结点，则编号 <code>（n-1-stride, ..., n-1）</code> 的任务交给第 1 个线程进行处理，编号 <code>（n-1-2*stride, ..., n-1-stride）</code> 的任务交给第 2 个线程进行处理，以此类推。当有新的线程加入时可以依据 transferIndex 值知道接下去应该分配哪一块的 bin 结点给当前线程。</p>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * stride 即步进，</span></span><br><span class="line"><span class="comment">     * 在单核下为 table 的长度 n，在多核模式下为 (n &gt;&gt;&gt; 3) / NCPU，最小值为 16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 每核处理的量小于16，则强制赋值16</span></span><br><span class="line">    <span class="comment">// NCPU为CPU核心数，每个核心均分复制任务，如果均分小于16个，那么以16为步长分给处理器</span></span><br><span class="line">    <span class="comment">// 例如0-15号给处理器1，16-32号分给处理器2。处理器3就不用接任务了。 </span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) &#123;</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 如果 nextTable 未初始化，则先进行初始化，容量是之前的两倍</span></span><br><span class="line">    <span class="comment">// 如果nextTab为空则初始化为原tab的两倍，这里只会有单线程进得来，因为初始化nextTab只需要一个，</span></span><br><span class="line">    <span class="comment">// addcount里面判断了nextTab为空则不执行扩容任务</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node&lt;?, ?&gt;[n &lt;&lt; <span class="number">1</span>]; <span class="comment">// 容量翻倍</span></span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n; <span class="comment">//扩容总进度，transferIndex之后的桶都已分配出去,因为是倒序分配</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行迁移工作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// ForwardingNode 表示一个正在被迁移的结点，对应的 hash 值是 MOVED</span></span><br><span class="line">    ForwardingNode&lt;K, V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>; <span class="comment">// 标记一个结点是否迁移完成</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// 标记扩容任务是否完成</span></span><br><span class="line">    <span class="comment">// i 是索引，bound 是边界值（左边界值），从后往前迁移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>; ; ) &#123;</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2.1 基于 CAS 计算本次任务的边界值，即 i 和 bound 值，</span></span><br><span class="line"><span class="comment">         *     将 i 指向 transferIndex，将 bound 指向 transferIndex - stride</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 标记当前结点迁移完成</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing) &#123;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一旦 transferIndex &lt;= 0，表示所有任务已经分配给相应的线程进行处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;  <span class="comment">//  分配完成，下面直接执行迁移任务</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 基于 CAS 计算 transferIndex 值（即 transferIndex - stride）</span></span><br><span class="line">            <span class="comment">// nextBound 是本次任务的边界</span></span><br><span class="line">            <span class="comment">//确定当前线程每次分配的待迁移桶的范围[bound, nextIndex)</span></span><br><span class="line">            <span class="comment">//每个线程执行完之前的任务以后会走这个分支继续获取新的任务,直到所有任务都分配完毕</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(</span><br><span class="line">                    <span class="keyword">this</span>,</span><br><span class="line">                    TRANSFERINDEX,</span><br><span class="line">                    nextIndex,</span><br><span class="line">                    nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// ~end while</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2.2 执行迁移任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">// 完成了所有结点的迁移</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab; <span class="comment">// 更新 table 为 nextTable</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// sizeCtl 值更新为 table 长度的 1.5 倍</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任务继续</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 基于 CAS 将 sizeCtl 减 1</span></span><br><span class="line"><span class="comment">             * 在迁移操作开始前会将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，每一个线程加入迁移任务就会将 sizeCtl 加 1，</span></span><br><span class="line"><span class="comment">             * 所以这里执行 sizeCtl 减 1，代表当前任务完成</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123;</span><br><span class="line">                    <span class="comment">// 当前任务结束，但是整体任务还未完成</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此时 sizeCtl == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，说明所有的任务都执行完了</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit,再次检查一下整张表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，获取 table 中位置为 i 的头结点，且为 null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在当前位置设置一个空的 ForwardingNode 节点</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，当前位置已经是一个 ForwardingNode，代表正在执行迁移工作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，开始对当前结点执行迁移工作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 再次校验结点</span></span><br><span class="line">                    Node&lt;K, V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 当前 bin 是一个链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n; <span class="comment">// n 为老 table 的长度</span></span><br><span class="line">                        Node&lt;K, V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">// 遍历当前链表，找到最后 p.hash &amp; n 值相同的第一个结点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// runBit == 0 表示还在老 table 原先的位置</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 此处 runBit 等于老 table 的长度，即 n</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 以 lastRun 为界</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash;</span><br><span class="line">                            K pk = p.key;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;&gt;(ph, pk, pv, ln);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 将其中一个链表放置在 nextTable 的 i 位置</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 将另外一个链表放置在 nextTable 的 i+n 位置</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 设置当前 table 的 i 位置为 ForwardingNode 空结点，代表已经处理完</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前 bin 是一颗红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K, V&gt; t = (TreeBin&lt;K, V&gt;) f;</span><br><span class="line">                        TreeNode&lt;K, V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K, V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K, V&gt; p = <span class="keyword">new</span> TreeNode&lt;&gt;(h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 如果将红黑树一分为二后，结点数目小于 6，则将红黑树转换成链表 */</span></span><br><span class="line"></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;&gt;(hi) : t;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将其中一个红黑树（或链表）放置在 nextTable 的 i 位置</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 将另外一个红黑树（或链表）放置在 nextTable 的 i+n 位置</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 设置当前 table 的 i 位置为 ForwardingNode 空结点，代表已经处理完</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的实现很复杂，不过整体流程可以概括为 2 大部分：</p>
<ol>
<li> *<strong>如果 nextTable 未初始化，则先执行初始化操作，新的 table 容量翻倍*</strong></li>
<li> *<strong>执行迁移任务*</strong></li>
</ol>
<p>其中过程 1 比较简单，不过需要注意的是并不是所有触发 transfer 方法都需要执行初始化 table 的操作，只有主动触发扩容的线程需要执行该操作，对于后来加入“帮忙”的线程会跳过过程 1，直接进入过程 2。</p>
<p>过程 2 通过 transferIndex 实例变量协调任务的分配，并为每个线程分配 stride 个结点进行迁移，任务分配的过程实际上就是确定当前线程迁移结点的上下界的过程，该过程位于 while 循环中（即代码注释 2.1），该循环整体上就是一个 CAS 操作，如果迁移任务已经完成，或者没有剩余的结点可以迁移（实例变量 transferIndex 小于等于 0），则退出 CAS，否则尝试为本次任务分配新的上下界，同时更新 transferIndex 值。</p>
<p>接下来正式开始迁移工作，整体流程可以概括为：</p>
<ol>
<li> <strong>检查整体迁移任务是否完成，如果完成则更新 table 和 sizeCtl 值</strong></li>
<li> <strong>否则，检查当前任务是否已经完成，如果完成则退出本次任务</strong></li>
<li> <strong>对于仍在进行中的任务会继续执行迁移操作，如果当前结点是一个空结点，则在该位置设置一个空的 ForwardingNode 结点，用于标记当前结点正在迁移中</strong></li>
<li> <strong>否则，如果当前结点是一个 ForwardingNode 结点，即当前结点正在迁移中，进入下一轮任务分配</strong></li>
<li> <strong>否则，对当前结点执行迁移操作</strong></li>
</ol>
<p>下面针对流程中的一些关键点进行说明，首先来看一下过程 2 相关的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基于 CAS 将 sizeCtl 减 1</span></span><br><span class="line"><span class="comment"> * 在迁移操作开始前会将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，每一个线程加入迁移任务就会将 sizeCtl 加 1，</span></span><br><span class="line"><span class="comment"> * 前面两个调用 transfer函数的，在调用之前都会先加 sizeCtl + 1</span></span><br><span class="line"><span class="comment"> * 所以这里执行 sizeCtl 减 1，代表当前任务完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123;</span><br><span class="line">        <span class="comment">// 当前任务结束，但是整体任务还未完成</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 sizeCtl == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，说明所有的任务都执行完了</span></span><br><span class="line">    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们曾提到当新增一个线程支持迁移任务时会执行 <code>U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)</code> 操作，并且在扩容操作开始前会设置 sizeCtl 的值为 <code>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code>，而这里在完成一个任务的时候会执行 <code>U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)</code> 操作将 sizeCtl 的值减 1。上面的代码会判定当前 sizeCtl 值是否等于 <code>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code>，如果相等则说明整体扩容任务完成，否则仅说明当前任务完成，将线程任务数减 1。</p>
<p>接下来我们继续来看一个结点迁移的过程，迁移区分链表和红黑树，不过基本思想是想通的，这里以链表进行说明，相关实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前 bin 是一个链表</span></span><br><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> runBit = fh &amp; n; <span class="comment">// n 为老 table 的长度</span></span><br><span class="line">    Node&lt;K, V&gt; lastRun = f;</span><br><span class="line">    <span class="comment">// 遍历当前链表，找到最后 p.hash &amp; n 值相同的第一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">        <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">        <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">            runBit = b;</span><br><span class="line">            lastRun = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// runBit == 0 表示还在老 table 原先的位置</span></span><br><span class="line">    <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">        ln = lastRun;</span><br><span class="line">        hn = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处 runBit 等于老 table 的长度，即 n</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        hn = lastRun;</span><br><span class="line">        ln = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以 lastRun 为界</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">        <span class="keyword">int</span> ph = p.hash;</span><br><span class="line">        K pk = p.key;</span><br><span class="line">        V pv = p.val;</span><br><span class="line">        <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">            ln = <span class="keyword">new</span> Node&lt;&gt;(ph, pk, pv, ln);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hn = <span class="keyword">new</span> Node&lt;&gt;(ph, pk, pv, hn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将其中一个链表放置在 nextTable 的 i 位置</span></span><br><span class="line">    setTabAt(nextTab, i, ln);</span><br><span class="line">    <span class="comment">// 将另外一个链表放置在 nextTable 的 i+n 位置</span></span><br><span class="line">    setTabAt(nextTab, i + n, hn);</span><br><span class="line">    <span class="comment">// 设置当前 table 的 i 位置为 ForwardingNode 空结点，代表已经处理完</span></span><br><span class="line">    setTabAt(tab, i, fwd);</span><br><span class="line">    advance = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段代码如果希望更好的理解，建议自己模拟一个 table，并 debug 一下执行流程。其实也不难，这段代码的工作就是将一个链表的拆分成两个链表，并将它们插入到新 table 适当的位置。假设老的 table 长度为 16，那么上面的实现有一个巧妙的地方在于对链表中所有结点的哈希值执行 <code>p.hash &amp; n</code> 操作，其结果不是 0 就是 16（老 table 的长度），所以我们可以依据 <code>p.hash &amp; n</code> 的值将一个链表拆分成两个链表，其中值均为 0 的结点构成的链表仍然放置在新 table 的当前位置 i，而值均为 16 的结点构成的链表则放置在新的位置，即 i + 16。变量 lastRun 所表示的结点实际上是最后几个具备相同 <code>p.hash &amp; n</code> 值的连续结点的最左边结点，因为这样可以减少该结点右边几个结点的迁移工作，因为它们具备相同的 <code>p.hash &amp; n</code> 值，自然也就位于同一个链表上。</p>
<h4 id="addCount"><a href="#addCount" class="headerlink" title="addCount()"></a>addCount()</h4><p>在 put 方法结尾处调用了 addCount 方法，把当前 ConcurrentHashMap 的元素个数+1， 这个方法一共做了两件事,更新 baseCount 的值，检测是否进行扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 putVal 传入的参数是 1</span></span><br><span class="line"><span class="comment">//binCount，binCount 默认是0，只有 hash 冲突了才会大于 1.且他的大小是链表的长度（如果不是红黑数结构的话）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//利用CAS方法更新baseCount的值</span></span><br><span class="line">    <span class="comment">// 如果计数盒子不是空 或者</span></span><br><span class="line">    <span class="comment">// 如果修改 baseCount 失败</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果计数盒子是空（尚未出现并发）</span></span><br><span class="line">        <span class="comment">// 如果随机取余一个数组位置为空 或者</span></span><br><span class="line">        <span class="comment">// 修改这个槽位的变量失败（出现并发了）</span></span><br><span class="line">        <span class="comment">// 执行 fullAddCount 方法。并结束</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要检查,检查是否需要扩容，在 putVal 方法调用时，默认就是要检查的。</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 如果map.size() 大于 sizeCtl（达到扩容阈值需要扩容） 且</span></span><br><span class="line">        <span class="comment">// table 不是空；且 table 的长度小于 1 &lt;&lt; 30。（可以扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 根据 length 得到一个标识</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果已经有其他线程在执行扩容操作</span></span><br><span class="line">                <span class="comment">// 可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2.</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 更新 sizeCtl 为负数后，开始扩容。</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下该方法的逻辑： x 参数表示的此次需要对表中元素的个数加几。check 参数表示是否需要进行扩容检查，大于等于0 需要进行检查，而我们的 putVal 方法的 binCount 参数最小也是 0 ，因此，每次添加元素都会进行检查。（除非是覆盖操作）</p>
<ol>
<li> 判断计数盒子属性是否是空，如果是空，就尝试修改 baseCount 变量，对该变量进行加 X。</li>
<li> 如果计数盒子不是空，或者修改 baseCount 变量失败了，则放弃对 baseCount 进行操作。</li>
<li> 如果计数盒子是 null 或者计数盒子的 length 是 0，或者随机取一个位置取于数组长度是 null，那么就对刚刚的元素进行 CAS 赋值。</li>
<li> 如果赋值失败，或者满足上面的条件，则调用 fullAddCount 方法重新死循环插入。</li>
<li> 这里如果操作 baseCount 失败了（或者计数盒子不是 Null），且对计数盒子赋值成功，那么就检查 check 变量，如果该变量小于等于 1. 直接结束。否则，计算一下 count 变量。</li>
<li> 如果 check 大于等于 0 ，说明需要对是否扩容进行检查。</li>
<li> 如果 map 的 size 大于 sizeCtl（扩容阈值），且 table 的长度小于 1 &lt;&lt; 30，那么就进行扩容。</li>
<li> 根据 length 得到一个标识符，然后，判断 sizeCtl 状态，如果小于 0 ，说明要么在初始化，要么在扩容。</li>
<li> 如果正在扩容，那么就校验一下数据是否变化了（具体可以看上面代码的注释）。如果检验数据不通过，break。</li>
<li> 如果校验数据通过了，那么将 sizeCtl 加一，表示多了一个线程帮助扩容。然后进行扩容。</li>
<li> 如果没有在扩容，但是需要扩容。那么就将 sizeCtl 更新，赋值为标识符左移 16 位 —— 一个负数。然后加 2。 表示，已经有一个线程开始扩容了。然后进行扩容。然后再次更新 count，看看是否还需要扩容。</li>
</ol>
<p>从上面的分析中我们可以看，addCount()是扩容是老老实实按容量x2来扩容的，tryPresize()会传入一个size参数，可能一次性扩容很多倍。后面采用一样的方式调用transfer()来进行真正的扩容处理。</p>
<blockquote>
<p>  作者：exposure<br>  链接：<a href="https://juejin.im/post/5c36bcc0e51d45513236ee78">https://juejin.im/post/5c36bcc0e51d45513236ee78</a><br>  来源：掘金<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>方法 put 的执行流程可以加深我们对于 ConcurrentHashMap 存储结构的理解，而理解了 ConcurrentHashMap 的存储结构，那么分析 get 方法的运行机制也是水到渠成的事情，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; e, p;</span><br><span class="line">    <span class="keyword">int</span> n, eh;</span><br><span class="line">    K ek;</span><br><span class="line">    <span class="comment">// 计算 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// table 表不为空，且 key 对应的 table 头结点存在</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))) &#123;</span><br><span class="line">                <span class="comment">// 找到对应的 key，返回 value</span></span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前 bin 为树，执行 find 方法检索</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前 bin 是链表，直接遍历检索</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法首先依据相同的实现计算 key 的哈希值，然后定位 key 在 table 中的 bin 位置。如果 bin 结点存在，则依据当前 bin 类型（链表或红黑树）检索目标值。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Q：弱一致性的问题？</p>
<p>A：之前经常有看到说 ConcurrentHashMap 在jdk1.6 版本中是弱一致性的，原因是其跟 CopyOnWriteArrayList 一样，只有在写数据时加锁，在读数据时不需要加锁，且数组引用是 volatile 关键字修饰的，这个弱一致性很好理解，就是读到的数据可能不是最新的，因为在写完后数组引用并没有发生改变，只是元素的值发生了变化，这个时候 volatile 是不会去刷新数据的，只有等写完后的数据从工作内存写回到主内存中，读到的数据才是写后的数据，所以是弱一致性。至于 jdk1.8而言，此时的锁已经是行粒度了，并且读数据时使用了 CAS，强行去读到 volatile的值，所以此时应该是强一致性的。</p>
<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p>由于这个基本已经被淘汰了…所以就不再进行系统的源码分析了。</p>
<p>其实 HashTable 源代码只有1000多行点，源代码很少，也基本上是 HashMap 的原来的版本加上 synchronized 关键字，每次都是锁定整个哈希表，所以效率非常低下，注意哈~ 跟 HashMap 的区别主要其基本元素还是 Entry，然后默认初始值是 11，不是 2 的幂次方，同时扩容的时候也不是按 2 的幂次方进行扩容的，而是 2 的幂次方 + 1来扩容的。并且，取余也是直接取余，因为其总数不是 2 的幂次方，故不能直接相与得到哈希桶的下标值。</p>
<h2 id="与HashMap区别-1"><a href="#与HashMap区别-1" class="headerlink" title="与HashMap区别"></a>与HashMap区别</h2><ul>
<li><p><strong>实现方式不一样</strong></p>
<p>  Hashtable继承自 <em>Dictionary</em> 类，而 <em>HashMap</em> 继承自 <em>AbstractMap</em> 类。但二者都实现了 <em>Map</em> 接口。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>线程安全性不同</strong></p>
<p>  Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。</p>
</li>
<li><p><strong>是否提供contains方法</strong><br>  HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。<br>  Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。</p>
</li>
<li><p>  *<strong>key和value是否允许null值*</strong> 【重点！！！可以引申到 fail-fast 和 fail-safe 机制，进而引发到多线程上】</p>
</li>
<li><p><strong>迭代器不同</strong></p>
<p>  HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。</p>
<p>  所以，当其他线程改变了HashMap 的结构，如：增删，将会抛出ConcurrentModificationException 异常，而 Hashtable 则不会。[fail-fast 和 fail-safe]</p>
</li>
<li><p><strong>扩容机制不同</strong></p>
<p>  当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为<strong>当前容量翻倍</strong>，Hashtable 扩容规则为<strong>当前容量翻倍 + 1</strong>。</p>
</li>
<li><p><strong>初始化容量不同</strong></p>
<p>  HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p>
</li>
<li><p><strong>Hash值获取不一样</strong></p>
<p>  <code>HashMap</code> 内部使用<code>hash(Object key)</code>扰动函数对 key 的 <code>hashCode</code> 进行扰动后作为 <code>hash</code> 值。<code>HashTable</code> 是直接使用 key 的 <code>hashCode()</code> 返回值作为 hash 值。</p>
</li>
</ul>
<h1 id="HashSet-amp-TreeSet-amp-LinkedHashSet"><a href="#HashSet-amp-TreeSet-amp-LinkedHashSet" class="headerlink" title="HashSet &amp; TreeSet &amp; LinkedHashSet"></a>HashSet &amp; TreeSet &amp; LinkedHashSet</h1><p>Set 的底层实现就是 Map，唯一的区别就是 Set 存的值就是 Map 的 key，value 值是一个固定值，所以…就不用分析啦！！！</p>
<ul>
<li>  有个注意点哈~~ TreeMap 由于 key 不可以为 null，value 可以为null。所以在 TreeSet 中，就不能插入 null 元素。</li>
</ul>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><h2 id="fail-fast-和-fail-safe-机制"><a href="#fail-fast-和-fail-safe-机制" class="headerlink" title="fail-fast 和 fail-safe 机制"></a>fail-fast 和 fail-safe 机制</h2><p><strong>一：快速失败（fail—fast）</strong></p>
<ul>
<li>  在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li>
<li>  原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
<li>  注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</li>
<li>  场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改。</li>
</ul>
<p><strong>二：安全失败（fail—safe）</strong></p>
<ul>
<li>  采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li>
<li>  原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li>
<li>  缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li>
<li>  场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li>
</ul>
<p><strong>快速失败和安全失败是对迭代器而言的。</strong></p>
<p>快速失败：当在遍历一个集合的时候，如果有另外一个线程在修改这个集合，就会抛出ConcurrentModification异常，java.util下都是快速失败。 安全失败：在遍历时会对集合做一个拷贝，所以修改集合元素不会影响迭代器遍历。在java.util.concurrent下都是安全失败。</p>
<h2 id="线程安全详解"><a href="#线程安全详解" class="headerlink" title="线程安全详解"></a>线程安全详解</h2><h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/WDeewsvWUEBIuabvVVhweA">线程安全问题</a></p>
]]></content>
      <categories>
        <category>Java集合系列</category>
      </categories>
      <tags>
        <tag>java Map源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>List源码分析</title>
    <url>/2022/07/31/List%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>  作为一名Java开发工程师，集合是我们最常用的一个工具，特别是List集合，接下来将带领大家深入List源码，去了解、学习List中的编程思想。</p>
</blockquote>
<span id="more"></span>

<h1 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h1><p>ArrayList 是我们 开发中常用的 Java 集合类，从学习 Java 开始我们基本上就对它天天相见了，,本文将从以下几部分分析 <strong>ArrayList</strong>：</p>
<ul>
<li>  ArrayList 概述</li>
<li>  ArrayList 的构造函数，也就是我们创建一个 ArrayList 的方法</li>
<li>  ArrayList 的添加元素的方法， 以及 ArrayList 的扩容机制</li>
<li>  ArrayList 的删除元素的常用方法</li>
<li>  ArrayList 的 改查常用方法</li>
<li>  ArrayList 的 toArray 方法</li>
<li>  ArrayList 的遍历方法，以及常见的错误操作即产生错误操作的原因</li>
</ul>
<h2 id="ArrayList-概述"><a href="#ArrayList-概述" class="headerlink" title="ArrayList 概述"></a>ArrayList 概述</h2><h3 id="ArrayList的基本特点"><a href="#ArrayList的基本特点" class="headerlink" title="ArrayList的基本特点"></a>ArrayList的基本特点</h3><ul>
<li>  ArrayList 底层是一个动态扩容的数组结构</li>
<li>  允许存放（不止一个） null 元素</li>
<li>  允许存放重复数据，存储顺序按照元素的添加顺序</li>
<li>  ArrayList 并不是一个线程安全的集合。如果集合的增删操作需要保证线程的安全性，可以考虑使用 <code>CopyOnWriteArrayList 『使用的是 ReentrantLock 保证同步，但是有弱一致性，因为写数据时是先拷贝再复制回去。』</code>或者使用 <code>collections.synchronizedList(List l) 函数返回一个线程安全的ArrayList类</code>。当然了，没有绝对的线程安全，这里的线程安全只能保证单个方法的线程安全，如果复合操作，比如一个线程不断读取一个数，另外一个线程不断删除一个数，两个方法的复合操作，也会导致线程不安全，这块我在 jvm 的最后一节也有讲。</li>
</ul>
<h3 id="ArrayList-的继承关系"><a href="#ArrayList-的继承关系" class="headerlink" title="ArrayList 的继承关系"></a>ArrayList 的继承关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>从 ArrayList 的继承关系来看， ArrayList 继承自 AbstractList ，实现了List, RandomAccess, Cloneable, java.io.Serializable 接口。</p>
<ul>
<li>  其中 AbstractList和 List 是规定了 ArrayList 作为一个集合框架必须具备的一些属性和方法，ArrayList 本身覆写了基类和接口的大部分方法，这就包含我们要分析的增删改查操作。</li>
<li>  ArrayList 实现 RandomAccess 接口标识着其支持随机快速访问，查看源码可以知道 RandomAccess 其实只是一个标识，标识某个类拥有随机快速访问的能力，针对 ArrayList 而言通过 <strong>get(index)</strong> 去访问元素可以达到 O(1) 的时间复杂度。有些集合类不拥有这种随机快速访问的能力，比如 LinkedList 就没有实现这个接口。</li>
<li>  ArrayList 实现 Cloneable 接口标识着他可以被克隆/复制，其内部实现了 <strong>clone</strong> 方法供使用者调用来对 ArrayList 进行克隆，但其实现只通过 Arrays.copyOf 完成了对 ArrayList 进行「浅拷贝」，也就是你改变 ArrayList clone后的集合中的元素，源集合中的元素也会改变，对于深浅拷贝我已经单独整理一篇文章来讲述这里不再过多的说。</li>
<li>  对于 java.io.Serializable 标识着集合可被被序列化。</li>
</ul>
<p>我们发现了一些有趣的事情，除了 List 以外，ArrayList 实现的接口都是标识接口，标识着这个类具有怎样的特点，看起来更像是一个属性。</p>
<h2 id="ArrayList-的构造方法"><a href="#ArrayList-的构造方法" class="headerlink" title="ArrayList 的构造方法"></a>ArrayList 的构造方法</h2><p>在说构造方法之前我们要先看下与构造参数有关的几个全局变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ArrayList 默认的数组容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个共享的空的数组实例，当使用 ArrayList(0) 或者 ArrayList(Collection&lt;? extends E&gt; c) </span></span><br><span class="line"><span class="comment">* 并且 c.size() = 0 的时候讲 elementData 数组讲指向这个实例对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 另一个共享空数组实例，第一次 add 元素的时候将使用它来判断数组大小是否设置为 DEFAULT_CAPACITY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 真正装载集合元素的底层数组 </span></span><br><span class="line"><span class="comment">* 至于 transient 关键字这里简单说一句，被它修饰的成员变量无法被 Serializable 序列化 </span></span><br><span class="line"><span class="comment">* 有兴趣的可以去网上查相关资料</span></span><br><span class="line"><span class="comment">* https://www.jianshu.com/p/14876ef38721 这个写得好</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  其中最需要关注的就是 transient 修饰了 elementData，我们知道 transient 修饰的变量是防止变量被序列化和反序列化，那为何 ArrayList 继承了 Serializable，却将其内部元素变为 transient 呢？因为 elementData 是一个缓存数组，<strong>会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上面的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间</strong>。</p>
<p>  还有就是，那 ArrayList 是如何实现序列化的呢？是因为其写了 writeObject() 和 readObject() ，虽然这两个方法都是使用的私有方法，但如何调用的呢？就是通过反射机制得以调用的。反射里面是有 setAccessible() 可以忽略方法前的 private。</p>
<p>  具体见：</p>
<p>  作者：汪和呆喵<br>  链接：<a href="https://www.jianshu.com/p/14876ef38721">https://www.jianshu.com/p/14876ef38721</a><br>  来源：简书<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>对于上述几个成员变量，我们只是在注释中简单的说明，对于他们具体有什么作用，在下边分析构造方法和扩容机制的时候将会更详细的讲解。</p>
<p>ArrayList 一共三种构造方式，我们先从无参的构造方法来开始</p>
<h3 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造一个初始容量为10的空列表。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我们经常使用的一个构造方法，其内部实现只是将 <strong>elementData</strong> 指向了我们刚才讲得 <strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong> 这个空数组，这个空数组的容量是 0， 但是源码注释却说这是构造一个初始容量为10的空列表。这是为什么？其实在集合调用 add 方法添加元素的时候将会调用 <strong>ensureCapacityInternal</strong> 方法，在这个方法内部判断了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">       minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，如果采用无参数构造方法的时候第一次添加元素肯定走进 if 判断中 minCapacity 将被赋值为 10，所以<strong>构造一个初始容量为10的空列表</strong> 也就是这个意思。</p>
<h3 id="指定初始容量的构造方法"><a href="#指定初始容量的构造方法" class="headerlink" title="指定初始容量的构造方法"></a>指定初始容量的构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 构造一个具有指定初始容量的空列表。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  初始容量 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> 如果参数小于 0 将会抛出 IllegalArgumentException  参数不合法异常</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们预先知道一个集合元素的容纳的个数的时候推荐使用这个构造方法，比如我们有个FragmentPagerAdapter 一共需要装 15 个 Fragment ，那么我们就可以在构造集合的时候生成一个初始容量为 15 的一个集合。有人会认为 ArrayList 自身具有动态扩容的机制，无需这么麻烦，下面我们讲解扩容机制的时候我们就会发现，每次扩容是需要有一定的内存开销的，而这个开销在预先知道容量的时候是可以避免的。</p>
<p>源代码中指定初始容量的构造方法实现，判断了如果 我们指定容量大于 0 ，将会直接 new 一个数组，赋值给 elementData 引用作为集合真正的存储数组，而指定容量等于 0 的时候使用成员变量 EMPTY_ELEMENTDATA 作为暂时的存储数组，这是 EMPTY_ELEMENTDATA 这个空数组的一个用处（不必太过于纠EMPTY_ELEMENTDATA 的作用，其实它的在源码中出现的频率并不高）。</p>
<h3 id="使用另个一个集合-Collection-的构造方法"><a href="#使用另个一个集合-Collection-的构造方法" class="headerlink" title="使用另个一个集合 Collection 的构造方法"></a>使用另个一个集合 Collection 的构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造一个包含指定集合元素的列表，元素的顺序由集合的迭代器返回。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> 源集合，其元素将被放置到这个集合中。 </span></span><br><span class="line"><span class="comment">* @如果参数为 null，将会抛出 NullPointerException 空指针异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">  elementData = c.toArray();</span><br><span class="line">  <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// c.toArray 可能(错误地)不返回 Object[]类型的数组 参见 jdk 的 bug 列表(6260652)</span></span><br><span class="line">      <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">          elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果集合大小为空将赋值为 EMPTY_ELEMENTDATA 等同于 new ArrayList(0);</span></span><br><span class="line">      <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>看完这个代码我最疑惑的地方是 Collection.toArray() 和 Arrays.copyOf() 这两个方法的使用，看来想明白这个构造参数具体做了什么必须理解这两个方法了。</p>
<h3 id="Object-Collection-toArray-方法"><a href="#Object-Collection-toArray-方法" class="headerlink" title="Object[] Collection.toArray() 方法"></a>Object[] Collection.toArray() 方法</h3><p>我们都知道 Collection 是集合框架的超类，其实 Collection.toArray 是交给具体的集合子类去实现的，这就说明不同的集合可能有不同的实现。他用来将一个集合转化为一个 Object[] 数组，事实上的真的是这样的么？参见 jdk 的 bug 列表(6260652)又是什么意思呢 ？我们来看下下边的这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; subClasses = Arrays.asList(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// class java.util.Arrays$ArrayList  </span></span><br><span class="line">System.out.println(list.getClass());  </span><br><span class="line">    </span><br><span class="line">Object[] objects = subClasses.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// class java.lang.String;  </span></span><br><span class="line">Object[] objArray = list.toArray();  </span><br><span class="line"><span class="comment">//这里返回的是 String[]</span></span><br><span class="line">System.out.println(objects.getClass().getSimpleName()); </span><br><span class="line"></span><br><span class="line">objArray[<span class="number">0</span>] = <span class="keyword">new</span> Object(); <span class="comment">// cause ArrayStoreException</span></span><br></pre></td></tr></table></figure>

<p>咦？为啥这里并不是一个 Object 数组呢？其实我们注意到，list.getClass 得到的并不是我们使用的 ArrayList 而是 Arrays 的内部类 Arrays$ArrayList。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList(E[] array) &#123;</span><br><span class="line">       <span class="comment">//这里只是检查了数组是否为空，不为空直接将原数组赋值给这个 ArrayList 的存储数组。</span></span><br><span class="line">       a = Objects.requireNonNull(array);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray()&#123;</span><br><span class="line">  <span class="keyword">return</span> a.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们调用的 toArray 方法就是这个内部对于 Collection.toArray 的实现， a.clone() ,这里 clone 并不会改变一个数组的类型，所以当原始数组中放的 String 类型的时候就会出现上边的这种情况了。</p>
<p>其实我们可以认为这是 jdk 的一个 bug，早在 05年的时候被人提出来了，但是一直没修复，但是在新的 <strong>「jdk 1.9」</strong> 种这个 bug 被修复了。</p>
<p>有兴趣的可以追踪 <a href="https://link.juejin.im/?target=http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652">bug 6260652</a> 看下。</p>
<h3 id="Arrays-copyOf-方法"><a href="#Arrays-copyOf-方法" class="headerlink" title="Arrays.copyOf 方法"></a>Arrays.copyOf 方法</h3><p>这个方法是在集合源码中常见的一个方法，他有很多重载方式,我们来看下最根本的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">//根据class的类型是否是 Object[] 来决定是 new 还是反射去构造一个泛型数组</span></span><br><span class="line">   T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">       ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">       : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">       <span class="comment">//使用 native 方法批量赋值元素至新数组中。</span></span><br><span class="line">   System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                    Math.min(original.length, newLength));</span><br><span class="line">   <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的注释也看出来了，Arrays.copyOf 方法复制数组的时候先判断了指定的数组类型是否为 <strong>Object[]</strong> 类型，否则使用反射去构造一个指定类型的数组。最后使用 System.arraycopy 这个 native 方法，去实现最终的数组赋值，newLength 如果比 original.length 大的时候会将多余的空间赋值为 null 由下边的例子可见:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arrString = &#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">Object[] copyOf = Arrays.copyOf(arrString, <span class="number">5</span>, Object[].class);</span><br><span class="line"><span class="comment">//[abc, def, null, null, null]</span></span><br><span class="line">System.out.println(Arrays.toString(copyOf));</span><br></pre></td></tr></table></figure>

<p>当然 ArrayList(Collection&lt;? extends E&gt; c) 复制的时候传递的是 <strong>c.size()</strong> 所以不会出现 null。</p>
<p>ex: 对于 System.arraycopy 该方法，本文不再展开讨论，有一篇对于其分析很好的文章大家可以去参考System：<a href="https://link.juejin.im/?target=https://segmentfault.com/a/1190000009922279">System.arraycopy方法详解</a></p>
<p>ok，绕了这么大的圈子终于明白了，ArrayList(Collection&lt;? extends E&gt; c)干了啥了，其实就是将一个集合中的元素塞到 ArrayList 底层的数组中。至此我们也将 ArrayList 的构造研究完了。</p>
<h2 id="ArrayList的添加元素-amp-扩容机制"><a href="#ArrayList的添加元素-amp-扩容机制" class="headerlink" title="ArrayList的添加元素 &amp; 扩容机制"></a>ArrayList的添加元素 &amp; 扩容机制</h2><p>敲黑板了！这块是面试的常客了，所以必须仔细研究下了。我们先看下如何给一个 ArrayList 添加一个元素:</p>
<h3 id="在集合末尾添加一个元素的方法"><a href="#在集合末尾添加一个元素的方法" class="headerlink" title="在集合末尾添加一个元素的方法"></a>在集合末尾添加一个元素的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员变量 size 标识集合当前元素个数初始为 0</span></span><br><span class="line"><span class="keyword">int</span> size；</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 将指定元素添加到集合（底层数组）末尾</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> 将要添加的元素</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回 true 表示添加成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查当前底层数组容量，如果容量不够则进行扩容</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  <span class="comment">//将数组添加一个元素，size 加 1</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 add 方法的时候总会调用 ensureCapacityInternal 来判断是否需要进行数组扩容， ensureCapacityInternal 参数为当前集合长度 size + 1，这很好理解，是否需要扩充长度，需要看当前底层数组是否够放 size + 1个元素的。</p>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩容检查</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是无参构造方法构造的的集合，第一次添加元素的时候会满足这个条件 minCapacity 将会被赋值为 10</span></span><br><span class="line">   <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">       minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 将 size + 1 或 10 传入 ensureExplicitCapacity 进行扩容判断</span></span><br><span class="line">   ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//操作数加 1 用于保证并发访问 </span></span><br><span class="line">   modCount++;</span><br><span class="line">   <span class="comment">// 如果 当前数组的长度比添加元素后的长度要小则进行扩容 </span></span><br><span class="line">   <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">       grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的源码主要做了扩容前的判断操作，注意参数为当前集合元素个数+1，第一次添加元素的时候 size + 1 = 1 ,而 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA, 长度为 0 ，1 - 0 &gt; 0, 所以需要进行 grow 操作也就是扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 集合的最大长度 Integer.MAX_VALUE - 8 是为了减少出错的几率 Integer 最大值已经很大了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 增加容量，以确保它至少能容纳最小容量参数指定的元素个数。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> 满足条件的最小容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前 elementData 的大小，也就是 List 中当前的容量</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">//oldCapacity &gt;&gt; 1 等价于 oldCapacity / 2  所以新容量为当前容量的 1.5 倍</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//如果扩大1.5倍后仍旧比 minCapacity 小那么直接等于 minCapacity</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">//如果新数组大小比  MAX_ARRAY_SIZE 就需要进一步比较 minCapacity 和 MAX_ARRAY_SIZE 的大小</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">  <span class="comment">// minCapacity通常接近 size 大小</span></span><br><span class="line">  <span class="comment">//使用 Arrays.copyOf 构建一个长度为 newCapacity 新数组 并将 elementData 指向新数组</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 比较 minCapacity 与 Integer.MAX_VALUE - 8 的大小如果大则放弃-8的设定，设置为 Integer.MAX_VALUE </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">  <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">      Integer.MAX_VALUE :</span><br><span class="line">      MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此看来 ArrayList 的扩容机制的知识点一共有两个</p>
<ol>
<li>  每次扩容的大小为原来大小的 *<strong>1.5*</strong> 倍 （当然这里没有包含 1.5倍后大于 MAX_ARRAY_SIZE 的情况）</li>
<li>  扩容的过程其实是一个将原来元素拷贝到一个扩容后长度的新数组中。所以 ArrayList 的扩容其实是相对来说比较消耗性能的。</li>
</ol>
<h3 id="在指定角标位置添加元素的方法"><a href="#在指定角标位置添加元素的方法" class="headerlink" title="在指定角标位置添加元素的方法"></a>在指定角标位置添加元素的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将指定的元素插入该列表中的指定位置。将当前位置的元素(如果有)和任何后续元素移到右边(将一个元素添加到它们的索引中)。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> 要插入的索引位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> 要添加的元素</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> 如果 index 大于集合长度 小于 0 则抛出角标越界 IndexOutOfBoundsException 异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 检查角标是否越界</span></span><br><span class="line">   rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 扩容检查</span></span><br><span class="line">   ensureCapacityInternal(size + <span class="number">1</span>);      </span><br><span class="line">   <span class="comment">//调用 native 方法新型数组拷贝</span></span><br><span class="line">   System.arraycopy(elementData, index, elementData, </span><br><span class="line">                    index + <span class="number">1</span>,size - index);</span><br><span class="line">    <span class="comment">// 添加新元素</span></span><br><span class="line">   elementData[index] = element;</span><br><span class="line">   size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道一个数组是不能在角标位置直接插入元素的，ArrayList 通过数组拷贝的方法将指定角标位置以及其后续元素整体向后移动一个位置，空出 index 角标的位置，来赋值新的元素。</p>
<p>将一个数组 <strong>src</strong> 起始 <strong>srcPos</strong> 角标之后 <strong>length</strong> 长度间的元素，赋值到 <strong>dest</strong> 数组中 <strong>destPos</strong> 到 <strong>destPos + length -1</strong>长度角标位置上。只是在 <strong>add</strong> 方法中 <strong>src</strong> 和 <strong>dest</strong> 为同一个数组而已。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="批量添加元素"><a href="#批量添加元素" class="headerlink" title="批量添加元素"></a>批量添加元素</h3><p>由于批量添加和添加一个元素逻辑大概相同则这里不详细说了，代码注释可以了解整个添加流程。</p>
<p>在数组末尾添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 c.toArray 将集合转化数组</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">// 要添加的元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="comment">//扩容检查以及扩容</span></span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        <span class="comment">//将参数集合中的元素添加到原来数组 [size，size + numNew -1] 的角标位置上。</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="comment">//与单一添加的 add 方法不同的是批量添加有返回值，如果 numNew == 0 表示没有要添加的元素则需要返回 false </span></span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在数组指定角标位置添加"><a href="#在数组指定角标位置添加" class="headerlink" title="在数组指定角标位置添加"></a>在数组指定角标位置添加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同样检查要插入的位置是否会导致角标越界</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew); </span><br><span class="line">    <span class="comment">//这里做了判断，如果要numMoved &gt; 0 代表插入的位置在集合中间位置，和在 numMoved == 0最后位置 则表示要在数组末尾添加 如果 &lt; 0  rangeCheckForAdd 就跑出了角标越界</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法不同的地方在于如果移动角标即之后的元素，addAll(int index, Collection&lt;? extends E&gt; c)里做了判断，如果要 <strong>numMoved &gt; 0</strong> 代表插入的位置在集合中间位置，和在 <strong>numMoved == 0</strong> 最后位置 则表示要在数组末尾添加 如果 <strong>numMoved &lt; 0</strong> ，<strong>rangeCheckForAdd</strong> 就抛出了角标越界异常了。</p>
<p>与单一添加的 <strong>add</strong> 方法不同的是批量添加有返回值，如果 <strong>numNew == 0</strong> 表示没有要添加的元素则需要返回 false。</p>
<h2 id="ArrayList-删除元素"><a href="#ArrayList-删除元素" class="headerlink" title="ArrayList 删除元素"></a>ArrayList 删除元素</h2><h3 id="根据角标移除元素"><a href="#根据角标移除元素" class="headerlink" title="根据角标移除元素"></a>根据角标移除元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将任何后续元素移到左边(从它们的索引中减去一个)。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//检查 index 是否 &gt;= size</span></span><br><span class="line">   rangeCheck(index);</span><br><span class="line">   modCount++;</span><br><span class="line">   <span class="comment">//index 位置的元素 </span></span><br><span class="line">   E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 需要移动的元素个数</span></span><br><span class="line">   <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//采用拷贝赋值的方法将 index 之后所有的元素 向前移动一个位置</span></span><br><span class="line">       System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                        numMoved);</span><br><span class="line">   <span class="comment">// 将 element 末尾的元素位置设为 null                 </span></span><br><span class="line">   elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 返回 index 位置的元素 </span></span><br><span class="line">   <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较要移除的角标位置和当前 elementData 中元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据角标移除元素的方法源码如上所示，值得注意的地方是：</p>
<p>rangeCheck 和 rangeCheckForAdd 方法不同 ，rangeCheck 只检查了 <strong>index</strong>是否大于等于 <strong>size</strong>，因为我们知道 <strong>size</strong> 为 <strong>elementData</strong> 已存储数据的个数，我们只能移除 <strong>elementData</strong> 数组中 [0 , size -1] 的元素，否则应该抛出角标越界。</p>
<p>但是为什么没有和 <strong>rangeCheckForAdd</strong> 一样检查小于0的角标呢，是不是<strong>remove(-1)</strong> 不会抛异常呢？ 其实不是的，因为 <strong>rangeCheck(index);</strong> 后我们去调用 <strong>elementData(index)</strong> 的时候也会抛出 <strong>IndexOutOfBoundsException</strong> 的异常，这是数组本身抛出的，不是 <strong>ArrayList</strong> 抛出的。那为什么要检查&gt;= size 呢？ 数组本身不也会检查么？ 哈哈.. 细心的同学肯定知道 <strong>elementData.length</strong> 并不一定等于 <strong>size</strong>，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; testRemove = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"> testRemove.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> testRemove.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  <span class="comment">// java.lang.IndexOutOfBoundsException: Index: 2, Size: 2</span></span><br><span class="line"> String remove = testRemove.remove(<span class="number">2</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;remove = &quot;</span> + remove + <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>new ArrayList&lt;&gt;(10)</strong> 表示 <strong>elementData</strong> 初始容量为10，所以 <strong>elementData.length = 10</strong> 而我们只给集合添加了两个元素所以 <strong>size = 2</strong> 这也就是为啥要 <strong>rangeCheck</strong> 的原因了。</p>
<h3 id="移除指定元素"><a href="#移除指定元素" class="headerlink" title="移除指定元素"></a>移除指定元素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy/**</span><br><span class="line">* 删除指定元素，如果它存在则反会 true，如果不存在返回 false。</span><br><span class="line">* 更准确地说是删除集合中第一出现 o 元素位置的元素 ，</span><br><span class="line">* 也就是说只会删除一个，并且如果有重复的话，只会删除第一个次出现的位置。</span><br><span class="line">*/</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    // 如果元素为空则只需判断 == 也就是内存地址</span><br><span class="line">   if (o == null) &#123;</span><br><span class="line">       for (int index = 0; index &lt; size; index++)</span><br><span class="line">           if (elementData[index] == null) &#123;</span><br><span class="line">                //得到第一个等于 null 的元素角标并移除该元素 返回 ture</span><br><span class="line">               fastRemove(index);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">        // 如果元素不为空则需要用 equals 判断。</span><br><span class="line">       for (int index = 0; index &lt; size; index++)</span><br><span class="line">           if (o.equals(elementData[index])) &#123;</span><br><span class="line">                //得到第一个等于 o 的元素角标并移除该元素 返回 ture</span><br><span class="line">               fastRemove(index);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除元素的逻辑和 remve(Index)一样 </span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">   modCount++;</span><br><span class="line">   int numMoved = size - index - 1;</span><br><span class="line">   if (numMoved &gt; 0)</span><br><span class="line">       System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                        numMoved);</span><br><span class="line">   elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上边代码可以看出来，移除元素和移除指定角标元素一样最终都是通过 <strong>System.arraycopy</strong> 将 <strong>index</strong> 之后的元素前移一位，并释放原来位于 <strong>size</strong> 位置的元素。</p>
<p>还可以看出，如果数组中有指定多个与 o 相同的元素只会移除角标最小的那个，并且 null 和 非null 的时候判断方法不一样。<strong>至于 equals 和 == 的区别，还有 hashCode 方法，我会之后在总结一篇单独的文章。</strong>等不急的可以先去网上找找喽。</p>
<blockquote>
<p>  注意，以下几点：</p>
<ol>
<li> Integer 重写的 equals 方法有自动拆箱；</li>
<li> equals如果不重写，那跟 == 是一样的，如果要重写，必须 equal 和 hashcode 都重写；</li>
<li> 最好的例子就是 HashSet，如果key不重写 hashcode()，那可能equals相等但是会导致存入两个一样的。</li>
</ol>
</blockquote>
<h3 id="批量移除-保留-removeAll-retainAll"><a href="#批量移除-保留-removeAll-retainAll" class="headerlink" title="批量移除/保留 removeAll/retainAll"></a>批量移除/保留 removeAll/retainAll</h3><p><strong>ArrayList</strong> 提供了 <strong>removeAll/retainAll</strong> 操作，这两个操作分别是 <strong>批量删除与参数集合中共同享有的元素</strong> 和 <strong>批量删除与参数集合中不共同享有的元素，保留共同享有的元素</strong>，两个方法只有一个参数不同!!!（retainAll是求交集）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 批量删除与参数集合中共同享有的元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判空 如果为空则抛出 NullPointerException 异常 Objects 的方法</span></span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** 只保留与 c 中元素相同的元素相同的元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">   Objects.requireNonNull(c);</span><br><span class="line">   <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** 批量删除的指定方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="comment">// r w 两个角标 r 为 elementData 中元素的索引 </span></span><br><span class="line">    <span class="comment">// w 为删除元素后集合的长度 </span></span><br><span class="line">   <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="comment">// 如果 c 当前集合中不包含当前元素，那么则保留</span></span><br><span class="line">           <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">               elementData[w++] = elementData[r];</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">// 如果c.contains（o）可能会抛出异常，如果抛出异常后 r!=size 则将 r 之后的元素不在比较直接放入数组</span></span><br><span class="line">       <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">           System.arraycopy(elementData, r,</span><br><span class="line">                            elementData, w,</span><br><span class="line">                            size - r);</span><br><span class="line">          <span class="comment">// w 加上剩余元素的长度</span></span><br><span class="line">           w += size - r;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 如果集合移除过元素，则需要将 w 之后的元素设置为 null 释放内存</span></span><br><span class="line">       <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">           <span class="comment">// clear to let GC do its work</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">               elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">           modCount += size - w;</span><br><span class="line">           size = w;</span><br><span class="line">           modified = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//返回是否成功移除过元素，哪怕一个</span></span><br><span class="line">   <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到移除指定集合中包含的元素的方法代码量是目前分析代码中最长的了，但是逻辑也很清晰：</p>
<ul>
<li>  从 0 开始遍历 <strong>elementData</strong> 如果 r 位置的元素不存在于指定集合 c 中，那么我们就将他复制给数组 w 位置， 整个遍历过程中 <strong>w &lt;= r</strong>。</li>
<li>  由于 <strong>c.contains(o)<strong>可能会抛出异常</strong>ClassCastException/NullPointerException</strong>，如果因为异常而终止（这两个异常是可选操作，集合源码中并没有显示生命该方法一定会抛异常），那么我们将会产生一次错误操作，所以 finally 中执行了判断操作，如果 <strong>r!= size</strong> 那么肯定是发生了异常，那么则将 r 之后的元素不在比较直接放入数组。最终得到的结果并不一定正确是删除了所有与 c 中的元素。</li>
<li>  批量删除和保留中，涉及高效的保存/删除两个集合公有元素的算法，是值得我们学习的地方,写的真好哈哈哈哈哈！！！</li>
</ul>
<h2 id="ArrayList-的改查"><a href="#ArrayList-的改查" class="headerlink" title="ArrayList 的改查"></a>ArrayList 的改查</h2><p>对于一个ArrayList 的改查方法就很简单了，set 和 get 方法。下面我们看下源码吧：</p>
<h3 id="修改指定角标位置的元素"><a href="#修改指定角标位置的元素" class="headerlink" title="修改指定角标位置的元素"></a>修改指定角标位置的元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//角标越界检查</span></span><br><span class="line">   rangeCheck(index);</span><br><span class="line"> <span class="comment">//下标取数据注意这里不是elementData[index] 而是 elementData(index) 方法</span></span><br><span class="line">   E oldValue = elementData(index);</span><br><span class="line">   <span class="comment">//将 index 位置设置为新的元素</span></span><br><span class="line">   elementData[index] = element;</span><br><span class="line">   <span class="comment">// 返回之前在 index 位置的元素</span></span><br><span class="line">   <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询指定角标的元素"><a href="#查询指定角标的元素" class="headerlink" title="查询指定角标的元素"></a>查询指定角标的元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//越界检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//下标取数据注意这里不是elementData[index] 而是 elementData(index) 方法</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询指定元素的角标或者集合是否包含某个元素"><a href="#查询指定元素的角标或者集合是否包含某个元素" class="headerlink" title="查询指定元素的角标或者集合是否包含某个元素"></a>查询指定元素的角标或者集合是否包含某个元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//集合中是否包含元素 indexOf 返回 -1 表示不包含 return false 否则返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回集合中第一个与 o 元素相等的元素角标，返回 -1 表示集合中不存在这个元素</span></span><br><span class="line"><span class="comment">* 这里还做了空元素直接判断 == 的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">           <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">           <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 从 elementData 末尾开始遍历遍历数组，所以返回的是集合中最后一个与 o 相等的元素的角标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">         <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">         <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">             <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList-集合的-toArry-方法"><a href="#ArrayList-集合的-toArry-方法" class="headerlink" title="ArrayList 集合的 toArry 方法"></a>ArrayList 集合的 toArry 方法</h2><p>其实 Object[] toArray(); 方法，以及其重载函数 \ T[] toArray(T[] a); 是接口 <strong>Collection</strong> 的方法，<strong>ArrayList</strong> 实现了这两个方法，很少见ArrayList 源码分析的文章分析这两个方法，顾名思义这两个方法的是用来，将一个集合转为数组的方法，那么两者的不同之处是，后者可以指定数组的类型，前者返回为一个 Object[] 超类数组。那么我们具体下源码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">   <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">   <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">       <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">       <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">   System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">   <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">       a[size] = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Object[] toArray() 只是调用了一次 Arrays.copyOf() 将集合中元素拷贝到一个新的 Object[] 数组并返回。这个 Arrays.copyOf() 方法前边已经讲了。所以 toArray() 方法并没有什么疑问，有疑问的地方在于toArray(T[] a) 。</p>
<p>我们可以传入一个指定类型的标志数组作为参数，toArray(T[] a) 方法最终会返回这个类型的包含集合元素的新数组。但是源码判断了 ：</p>
<ul>
<li><p>  如果 <strong>a.length &lt; size</strong> 即当前集合元素的个数与参数 a 数组元素的大小的时候将和 toArray() 一样返回一个新的数组。</p>
</li>
<li><p>  如果 <strong>a.length == size</strong> 将不会产生新的数组直接将集合中的元素调用 System.arraycopy() 方法将元素复制到参数数组中，返回 a。</p>
</li>
<li><p>  <strong>a.length &gt; size</strong> 也不会产生新的数组,但是值得注意的是 <strong>a[size] = null;</strong> 这一句改变了原数组中 <strong>index = size</strong> 位置的元素，被重新设置为 null 了。</p>
</li>
</ul>
<h2 id="ArrayList-的遍历"><a href="#ArrayList-的遍历" class="headerlink" title="ArrayList 的遍历"></a>ArrayList 的遍历</h2><p>ArrayList 的遍历方式 jdk 1.8 之前有三种 ：for 循环遍历， foreach 遍历，迭代器遍历,jdk 1.8 之后又引入了forEach 操作，我们先来看看迭代器的源码实现：</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器 Iterator 模式是用于遍历各种集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 ArrayList 作为集合类也不例外，迭代器本身只提供三个接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;<span class="comment">//是否还有下一个元素</span></span><br><span class="line">      <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;<span class="comment">// 返回当前元素 可以理解为他相当于 fori 中 i 索引</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;<span class="comment">// 移除一个当前的元素 也就是 next 元素。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 中调用 iterator() 将会返回一个内部类对象 Itr 其实现了 Iterator 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面让我们看下其实现的源码：</p>
<p>正如我们的 for 循环遍历一样，数组角标总是从 0 开始的，所以 cursor 初始值为 0 ， hasNext 表示是否遍历到数组末尾，即 i &lt; size 。对于 <strong>modCount</strong> 变量之所以一直没有介绍是因为他集合并发访问有关系，用于标记当前集合被修改（增删）的次数，如果并发访问了集合那么将会导致这个 <strong>modCount</strong> 的变化，在遍历过程中不正确的操作集合将会抛出 <strong>ConcurrentModificationException</strong> ，这是 Java 「fail-fast 的机制」，对于如何正确的在遍历过程中操作集合稍后会有说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> cursor; <span class="comment">// 对照 hasNext 方法 cursor 应理解为下个调用 next 返回的元素 初始为 0</span></span><br><span class="line">   <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 上一个返回的角标</span></span><br><span class="line">   <span class="keyword">int</span> expectedModCount = modCount;<span class="comment">//初始化的时候将其赋值为当前集合中的操作数，</span></span><br><span class="line">   <span class="comment">// 是否还有下一个元素 cursor == size 表示当前集合已经遍历完了 所以只有当 cursor 不等于 size 的时候 才会有下一个元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> cursor != size;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>next 方法是我们获取集合中元素的方法，next 返回当前遍历位置的元素，如果在调用 next 之前集合被修改，并且迭代器中的期望操作数并没有改变，将会引发<strong>ConcurrentModificationException</strong>。next 方法多次调用 <strong>checkForComodification</strong> 来检验这个条件是否成立。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 验证期望的操作数与当前集合中的操作数是否相同 如果不同将会抛出异常</span></span><br><span class="line">     checkForComodification();</span><br><span class="line">     <span class="comment">// 如果迭代器的索引已经大于集合中元素的个数则抛出异常，这里不抛出角标越界</span></span><br><span class="line">     <span class="keyword">int</span> i = cursor;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">     Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">     <span class="comment">// 由于多线程的问题这里再次判断是否越界，如果有异步线程修改了List（增删）这里就可能产生异常</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">     <span class="comment">// cursor 移动</span></span><br><span class="line">     cursor = i + <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//最终返回 集合中对应位置的元素，并将 lastRet 赋值为已经访问的元素的下标</span></span><br><span class="line">     <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>只有 Iterator 的 remove 方法会在调用集合的 remove 之后让 期望 操作数改变使expectedModCount与 modCount 再相等，所以是安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实质调用了集合的 remove 方法移除元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 比如操作者没有调用 next 方法就调用了 remove 操作，lastRet 等于 -1的时候抛异常</span></span><br><span class="line">       <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="comment">//检查操作数</span></span><br><span class="line">       checkForComodification();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//移除上次调用 next 访问的元素</span></span><br><span class="line">           ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">           <span class="comment">// 集合中少了一个元素，所以 cursor 向前移动一个位置（调用 next 时候 cursor = lastRet + 1）</span></span><br><span class="line">           cursor = lastRet;</span><br><span class="line">           <span class="comment">//删除元素后赋值-1，确保先前 remove 时候的判断</span></span><br><span class="line">           lastRet = -<span class="number">1</span>;</span><br><span class="line">           <span class="comment">//修改操作数期望值， modCount 在调用集合的 remove 的时候被修改过了。</span></span><br><span class="line">           expectedModCount = modCount;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="comment">// 集合的 remove 会有可能抛出 rangeCheck 异常，catch 掉统一抛出 		 ConcurrentModificationException </span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>检查期望的操作数与当前集合的操作数是否相同。Java8 发布了很多函数式编程的特性包括 lamada 和Stream 操作。迭代器也因此添加了 forEachRemaining 方法，这个方法可以将当前迭代器访问的元素（next 方法）后的元素传递出去还没用到过，源码就不放出来了,大家有兴趣自己了解下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//... Java8 的新特性，可以将当前迭代器访问的元素（next 方法）后的元素传递出去还没用到过，源码就不放出来了,大家有兴趣自己了解下。</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 检查期望的操作数与当前集合的操作数是否相同</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ListIterator-迭代器"><a href="#ListIterator-迭代器" class="headerlink" title="ListIterator 迭代器"></a>ListIterator 迭代器</h3><p>ArrayList 可以通过以下两种方式获取 ListIterator 迭代器，区别在于初始角标的位置。不带参数的迭代器默认的cursor = 0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ListItr对象继承自前边分析的 Itr，也就是说他拥有 Itr 的所有方法，并在此基础上进行扩展，其扩展了访问当前角标前一个元素的方法。以及在遍历过程中添加元素和修改元素的方法。</p>
<p>ListItr 的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       cursor = index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ListItr 的 previous 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// cursor = 0 表示游标在数组第一个元素的左边，此时 `hasPrevious` 返回false</span></span><br><span class="line">  <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cursor;<span class="comment">//调用返回当前角标位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cursor - <span class="number">1</span>;<span class="comment">//调用返回上一个角标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前角标的上一个元素，并前移移动角标</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// fast-fail 检查</span></span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 如果前移角标 &lt;0 代表遍历到数组遍历完成，一般在调用 previous 要调用 hasPrevious 判断</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="comment">//获取元素    </span></span><br><span class="line">  Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">  <span class="comment">//获取成功后修改角标位置和 lastRet 位置    </span></span><br><span class="line">  cursor = i;</span><br><span class="line">  <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ListItr 的 add 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// fast-fail 检查</span></span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取当前角标位置，一般的是调用 previous 后，角标改变后后去 cursor </span></span><br><span class="line">      <span class="keyword">int</span> i = cursor;</span><br><span class="line">      <span class="comment">//添加元素在角标位置</span></span><br><span class="line">      ArrayList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">      <span class="comment">//集合修改完成后要改变当前角标位置</span></span><br><span class="line">      cursor = i + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//重新置位 -1 如果使用迭代器修改了角标位置元素后不允许立刻使用 set 方法修改修改后角标未知的额元素 参考 set 的源代码</span></span><br><span class="line">      lastRet = -<span class="number">1</span>;</span><br><span class="line">      expectedModCount = modCount;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能对比两个迭代器后，会对 cursor 指向的位置有所疑惑，现在我们来看下一段示例代码对应的图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testListItr</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ArrayList&lt;Integer&gt; list  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   list.add(<span class="number">1</span>);</span><br><span class="line">   list.add(<span class="number">2</span>);</span><br><span class="line">   list.add(<span class="number">3</span>);</span><br><span class="line">   list.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">   ListIterator&lt;Integer&gt; listIterator = list.listIterator(list.size());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (listIterator.hasPrevious())&#123;</span><br><span class="line">   		<span class="keyword">if</span> (listIterator.previous() == <span class="number">2</span>)&#123;</span><br><span class="line">           listIterator.add(<span class="number">0</span>); </span><br><span class="line"><span class="comment">//         listIterator.set(10); //Exception in thread &quot;main&quot; java.lang.IllegalStateException</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list [1, 0, 2, 3, 4]</span></span><br><span class="line">   System.out.println(<span class="string">&quot;list &quot;</span> + list.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里可以看出，cursor在previous的时候是先移动，然后在返回值，next方法是先返回当前值，然后移动。</p>
<h3 id="java8-新增加的遍历方法-forEach"><a href="#java8-新增加的遍历方法-forEach" class="headerlink" title="java8 新增加的遍历方法 forEach"></a>java8 新增加的遍历方法 forEach</h3><p>java8增加很多好用的 API，工作和学习中也在慢慢接触这些 API，forEach 操作可能是我继 lambda 后，第一个使用的 API 了（囧），jdk doc 对这个方法的解释是：</p>
<p>对此集合的每个条目执行给定操作，直到处理完所有条目或操作抛出异常为止。 除非实现类另有规定，否则按照条目集迭代的顺序执行操作（如果指定了迭代顺序）。操作抛出的异常需要调用者自己处理。</p>
<p>其实其内部实现也很简单，只是一个判断了操作数的 for 循环，所以在效率上不会有提升，但是在安全性上的确有提升，也少些很多代码不是么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查调用者传进来的操作函数是否为空</span></span><br><span class="line">   Objects.requireNonNull(action);</span><br><span class="line">   <span class="comment">//与迭代不同期望操作被赋值为 final 也就是 forEach 过程中不允许并发修改集合否则会抛出异常</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="keyword">final</span> E[] elementData = (E[]) <span class="keyword">this</span>.elementData;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">   <span class="comment">//每次取元素之前判断操作数，确保操作正常</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">       action.accept(elementData[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于高级 for 循环以及最普通的 fori 方法这里不再赘述。下面我们看下面试会问到一个问题，也是我们在单线程操作集合的时候需要注意的一个问题，如果正确的在遍历过程中修改集合。</p>
<p>错误操作 1 在 for循环修改集合后继续遍历<br>第一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;SubClass&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list2.add(<span class="keyword">new</span> SubClass(<span class="number">1</span>));</span><br><span class="line">list2.add(<span class="keyword">new</span> SubClass(<span class="number">2</span>));</span><br><span class="line">list2.add(<span class="keyword">new</span> SubClass(<span class="number">3</span>));</span><br><span class="line">list2.add(<span class="keyword">new</span> SubClass(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.size(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (list2.get(i).test == <span class="number">3</span>) &#123;</span><br><span class="line">      list2.remove(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list2);</span><br><span class="line"><span class="comment">//[SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, SubClass&#123;test=3&#125;]</span></span><br></pre></td></tr></table></figure>

<p>这个例子我们会发现，程序并没有抛出异常，但是从运行经过上来看并不是我们想要的，因为还有 SubClass.test = 3的数据在，这是因为 remove 操作改变了list.size(),而 fori 中每次执行都会重新调用一次lists2.size()，当我们删除了倒数第二个元素后，list2.size() = 3,i = 3 &lt; 3 不成立则没有在进行 remove 操作，知道了为什么以后我们试着这样改变了循环方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = list2.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (list2.get(i).test == <span class="number">3</span>) &#123;</span><br><span class="line">      list2.remove(i);<span class="comment">//remove 以后 list 内部将 size 重新改变了 for 循环下次调用的时候可能就不进去了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: Index: 3, Size: 3</span></span><br></pre></td></tr></table></figure>

<p>果真程序抛出了角标越界的异常，因为这样每次 fori 的时候我们不去拿更新后的 list 元素的 size 大小，所以当我们删除一个元素后，size = 3 当我们 for 循环去list2.get(3)的时候就会被 rangeCheck方法抛出异常。</p>
<h3 id="错误操作导致-ConcurrentModificationException-异常"><a href="#错误操作导致-ConcurrentModificationException-异常" class="headerlink" title="错误操作导致 ConcurrentModificationException 异常"></a>错误操作导致 ConcurrentModificationException 异常</h3><p>我们分析迭代器的时候，知道 ConcurrentModificationException是指因为迭代器调用 checkForComodification 方法比较 modCount 和 expectedModCount 方法大小的时候抛出异常。我们在分析 ArrayList 的时候在每次对集合进行修改， 即有 add 和 remove 操作的时候每次都会对 modCount ++。</p>
<p>modCount 这个变量主要用来记录 ArrayList 被修改的次数，那么为什么要记录这个次数呢？是为了防止多线程对同一集合进行修改产生错误，记录了这个变量，在对 ArrayList 进行迭代的过程中我们能很快的发现这个变量是否被修改过，如果被修改了 ConcurrentModificationException 将会产生。下面我们来看下例子，这个例子并不是在多线程下的，而是因为我们在同一线程中对 list 进行了错误操作导致的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;SubClass&gt; iterator = lists.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  SubClass next = iterator.next();</span><br><span class="line">  <span class="keyword">int</span> index = next.test;</span><br><span class="line">  <span class="keyword">if</span> (index == <span class="number">3</span>) &#123;</span><br><span class="line">      list2.remove(index);<span class="comment">//操作1： 注意是 list2.remove 操作</span></span><br><span class="line">      <span class="comment">//iterator.remove()；/操作2 注意是 iterator.remove 操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作1： Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">//操作2：  [SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;]</span></span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<p>我们对操作1，2分别运行程序，可以看到，操作1很快就抛出了 java.util.ConcurrentModificationException 异常，操作2 则顺利运行出正常结果，如果对 modCount 注意了的话，我们很容易理解，list.remove(index) 操作会修改List 的 modCount，而 iterator.next() 内部每次会检验 expectedModCount != modCount，所以当我们使用 list.remove 下一次再调用 iterator.next() 就会报错了，而iterator.remove为什么是安全的呢？因为其操作内部会在调用 list.remove 后重新将新的 modCount 赋值给 expectedModCount。所以我们直接调用 list.remove 操作是错误的。对于多线程的影响这里不在展开这里推荐有兴趣的朋友看下这个文章 Java ConcurrentModificationException异常原因和解决方法;</p>
<p>经过了一轮分析我们我们知道了错误产生原因了，但是大家是否能真的分辨出什么操作是错误的呢？我们来看下边这个面试题，这是我在网上无意中看到的一道大众点评的面试题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  list.add(<span class="string">&quot;sh&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; list.iterator().hasNext(); i++) &#123;</span><br><span class="line">         <span class="comment">// hasNext 只是判断了 cursor != size，并没有移动cursor，所以只要 size 不是 0 ，就不会退出循环</span></span><br><span class="line">        <span class="comment">// 最后size == 5，list.remove(5)越界：IndexOutOfBoundsException</span></span><br><span class="line">  			<span class="comment">// 这里并不会去报 ConcurrentModificationException(),因为list.iterator()每次都会去new一个新的Itr对象，每次初始化这个对象都会把最新的 modCount 赋值给 expectedCount，所以不可能做到 modeCount != expectedCount，而且只有 iterator.next() 会有这个错误。</span></span><br><span class="line">  list.remove(i);</span><br><span class="line">  System.out.println(<span class="string">&quot;秘密&quot;</span> + list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一道面试题"><a href="#一道面试题" class="headerlink" title="一道面试题"></a>一道面试题</h3><p>相信大家肯定知道这样操作是会产生错误的，但是最终会抛出角标越界还是ConcurrentModificationException呢？</p>
<p>其实这里会抛出角标越界异常，为什么呢，因为 for 循环的条件 list.iterator().hasNext()，<strong>我们知道 list.iterator() 将会new 一个新的 iterator 对象，而在 new 的过程中我们将 每次 list.remove 后的 modCount 赋值给了新的 iterator 的 expectedModCount</strong>，所以不会抛出 ConcurrentModificationException 异常，而 hasNext 内部只判断了cursor != size 当我们删除了一半元素以后，size 变成了 5 而新的 list.iterator() 的 cursor 等于 0 ，0!=5 for 循环继续，那么当执行到 list.remove（5）的时候就会抛出角标越界了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>  ArrayList 底层是一个动态扩容的数组结构,每次扩容需要增加1.5倍的容量</li>
<li>  ArrayList 扩容底层是通过 Arrays.CopyOf 和 System.arraycopy 来实现的。每次都会产生新的数组，和数组中内容的拷贝，所以会耗费性能，所以在多增删的操作的情况可优先考虑 LinkList 而不是 ArrayList。</li>
<li>  ArrayList 的 toArray 方法重载方法的使用。</li>
<li>  <strong>允许存放（不止一个） null 元素</strong></li>
<li>  允许存放重复数据，存储顺序按照元素的添加顺序</li>
<li>  ArrayList 并不是一个线程安全的集合。如果集合的增删操作需要保证线程的安全性，可以考虑使用 CopyOnWriteArrayList 或者使collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类.</li>
<li>  不正确访问集合元素的时候 ConcurrentModificationException和 java.lang.IndexOutOfBoundsException 异常产生的时机和原理。</li>
</ul>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p><a href="https://juejin.im/post/5abfde3f6fb9a028e46ec51c">搞懂 JAVA LinkedList 源码</a></p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li><p>  继承自 <code>AbstractSequentialList</code> 并实现了 <code>List</code> 接口以及 <code>Deque</code> 双向队列接口，因此 LinkedList 不但拥有 List 相关的操作方法，也有队列的相关操作方法。</p>
</li>
<li><p><strong><code>LinkedList</code> 集合底层实现的数据结构为双向链表</strong></p>
<p>  <strong><code>LinkedList</code> 集合中元素允许为 null</strong></p>
<p>  <strong><code>LinkedList</code> 允许存入重复的数据</strong></p>
<p>  <strong><code>LinkedList</code> 中元素存放顺序为存入顺序。</strong></p>
<p>  <strong><code>LinkedList</code> 是非线程安全的，如果想保证线程安全的前提下操作 <code>LinkedList</code>，可以使用 <code>List list = Collections.synchronizedList(new LinkedList(...));</code> 来生成一个线程安全的 <code>LinkedList</code></strong></p>
</li>
<li><p>实现List，利用了其是两个单链表组成的，实现Deque，利用其是双向链表的性质，注意哈，Deque既可以当队列也可以当栈，所以队列和栈的方法LinkedList全有。</p>
<ul>
<li>  add和offer是增加元素</li>
<li>  remove和poll是移除元素</li>
<li>  get和peek是查询元素</li>
</ul>
</li>
</ul>
<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>简而言之，Vector 与 ArrayList 之间的关系，就是 HashMap 和 HashTable 之间的关系，Vector 的方法基本上都是 ArrayList 的方法 加个 synchronized 关键字组成的，这边讲下它与 ArrayList 的不同，就可以结束了！</p>
<p>不同点有：</p>
<ul>
<li>  Vector 线程安全，是同步的；ArrayList 非线程安全，非同步的</li>
<li>  *<strong>扩容策略不同，ArrayList 扩容是变成原来的 1.5 倍，而 Vector 和 ArrayDeque 扩容一样，都是变为原来的两倍*</strong></li>
<li>  Vector 可以使用 Enumeration 和 Iterator 进行元素遍历，ArrayList 只提供了 Iterator 的方式</li>
<li>  由于使用的线程同步，Vector 的效率比 ArrayList 低，但是 jdk8 之后，由于对 synchronized 的关键字的优化，引入了 偏向锁 等轻量级锁之后， Vector 和 ArrayList 的性能差异已经不大了</li>
</ul>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>没啥好分析的，实现这个接口的，接触的比较多的也就是 PriorityQueue、ArrayDeque。</p>
<p>直接放链接：</p>
<p><a href="https://juejin.im/post/5a3763ed51882506a463b740#heading-10">Java集合（七） Queue详解</a></p>
<p><a href="https://blog.csdn.net/wangyang1354/article/details/57081920">Java集合ArrayDeque类解读</a></p>
<p><a href="https://blog.csdn.net/weixin_34256074/article/details/91418615">死磕 java集合之ArrayDeque源码分析</a></p>
<h2 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h2><p>就其实现而言，ArrayDeque采用了<strong>循环数组</strong>的方式来完成双端队列的功能。</p>
<ol>
<li> 无限的扩展，自动扩展队列大小的。（当然在不会内存溢出的情况下）</li>
<li> 非线程安全的，不支持并发访问和修改。</li>
<li> 支持fast-fail。</li>
<li> 作为栈使用的话比比栈要快。</li>
<li> 当队列使用比 LinkedList 要快。</li>
<li> null元素被禁止使用，这个跟 ArrayList 和 LinkedList 也不一样</li>
<li> 初始值跟 ArrayList 不一样，这里的初始值是 16，扩容也是直接扩容两倍，跟 ArrayList 的 1.5 倍不一样，扩容的时候利用了容量是2次幂这个性质，跟 HashMap 一样，直接与 length 相与即可。</li>
</ol>
]]></content>
      <categories>
        <category>Java集合系列</category>
      </categories>
      <tags>
        <tag>java list源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-原型模式</title>
    <url>/2022/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了原型模式的定义，并简单介绍了如何clone一个散列表。</p>
</blockquote>
<span id="more"></span>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。</p>
<p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</p>
<p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从RPC、网络、数据库、文件系统等非常慢速的IO中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们以下面的场景来介绍原型模式</p>
<p>假设数据库中存储了大约10万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。</p>
<p>系统A在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。如果你熟悉的是Java语言，可以直接使用语言中提供的HashMap容器来实现。其中，HashMap的key为搜索关键词，value为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入HashMap就可以了。</p>
<p>不过，我们还有另外一个系统B，专门用来分析搜索日志，定期（比如间隔10分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对v2版本的数据进行更新，得到v3版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</p>
<p>为了保证系统A中数据的实时性（不一定非常实时，但数据也不能太旧），系统A需要定期根据数据库中的数据，更新内存中的索引和数据。</p>
<p>我们该如何实现这个需求呢？</p>
<p>实际上，也不难。我们只需要在系统A中，记录当前数据的版本Va对应的更新时间Ta，从数据库中捞出更新时间大于Ta的所有搜索关键词，也就是找出Va版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">    <span class="keyword">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        currentKeywords.replace(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title">getSearchWords</span><span class="params">(<span class="keyword">long</span> lastUpdateTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，现在，我们有一个特殊的要求：</p>
<p>任何时刻，系统A中的所有数据都必须是同一个版本的，要么都是版本a，要么都是版本b，不能有的是版本a，有的是版本b(意思是系统A中Map的数据更改必须全部一起替换，只能先存储到另一个Map中，然后赋值给旧的Map)。那刚刚的更新方式就不能满足这个要求了。除此之外，我们还要求：在更新内存数据的时候，系统A不能处于不可用状态，也就是不能停机更新数据。</p>
<p>那我们该如何实现现在这个需求呢？</p>
<p>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本a数据）上更新，而是重新创建另一个版本数据（假设是版本b数据），等新的版本数据建好之后，再一次性地将服务版本从版本a切换到版本b。这样既保证了数据一直可用，又避免了中间状态的存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中取出所有的数据，放入到newKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentKeywords = newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title">getSearchWords</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出所有的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中newKeywords的构建成本比较高，我们需要将这10万条数据从数据库中读出，然后计算哈希值，构建newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</p>
<p>我们拷贝currentKeywords数据到newKeywords中，然后从数据库中只捞出新增或者有更新的关键词，更新到newKeywords中。而相对于10万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span></span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">    <span class="keyword">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());</span><br><span class="line">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class="line">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">    currentKeywords = newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title">getSearchWords</span><span class="params">(<span class="keyword">long</span> lastUpdateTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了clone函数，我们知道，这个函数默认是浅拷贝，即仅仅拷贝对象中的基本数据类型的数据，以及引用对象的内存地址，不会递归的拷贝引用对象本身。</p>
<p>上面的实现方式并没有达到我们刚刚的要求，即系统A在同一时刻只能有一个版本。所以我们采用深拷贝的方式来实现上述的要求(两种方式：递归拷贝对象、序列化对象再反序列化)。</p>
<p>newKeywords不仅仅复制currentKeywords的索引，还把SearchWord对象也复制一份出来，这样newKeywords和currentKeywords就指向不同的SearchWord对象，也就不存在更新newKeywords的数据会导致currentKeywords的数据也被更新的问题了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Shallow copy</span></span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">    <span class="keyword">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        newKeywords.remove(searchWord.getKeyword());</span><br><span class="line">      &#125;</span><br><span class="line">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">    currentKeywords = newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title">getSearchWords</span><span class="params">(<span class="keyword">long</span> lastUpdateTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java设计模式之创建型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-建造者模式</title>
    <url>/2022/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文从两个问题出发，介绍了为什么要使用建造者、以及建造者和工厂模式的区别。</p>
</blockquote>
<span id="more"></span>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>直接使用构造函数或者配合set方法就能创建对象，为什么还需要建造者模式来创建呢？</li>
<li>建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</li>
</ul>
<h3 id="为什么需要建造者模式？"><a href="#为什么需要建造者模式？" class="headerlink" title="为什么需要建造者模式？"></a>为什么需要建造者模式？</h3><p>假设有这样一道设计面试题：我们需要定义一个资源池配置类ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个ResourcePoolConfig类。</p>
<p><img src="/2022/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResourcePoolConfig</span><span class="params">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;name should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxTotal != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxIdle != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minIdle != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，ResourcePoolConfig只有4个可配置项，对应到构造函数中，也只有4个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了8个、10个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的bug。</p>
<p>解决这个问题的办法你应该也已经想到了，那就是用set()函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项name是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项maxTotal、maxIdle、minIdle都不是必填的，所以我们通过set()函数来设置，让使用者自主选择填写或者不填写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResourcePoolConfig</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;name should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxTotal</span><span class="params">(<span class="keyword">int</span> maxTotal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxIdle</span><span class="params">(<span class="keyword">int</span> maxIdle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinIdle</span><span class="params">(<span class="keyword">int</span> minIdle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过set()方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p>
<ul>
<li><strong>必填项过多：</strong>我们刚刚讲到，name是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过set()方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li>
<li><strong>参数有依赖关系：</strong>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了maxTotal、maxIdle、minIdle其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle和minIdle要小于等于maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li>
<li><strong>对象不可变：</strong>如果我们希望ResourcePoolConfig类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在ResourcePoolConfig类中暴露set()方法。</li>
</ul>
<p>为了解决上述的三个问题，就需要使用建造者模式了。</p>
<p>我们可以把校验逻辑放置到Builder类中，先创建建造者，并且通过set()方法设置建造者的变量值，然后在使用build()方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把ResourcePoolConfig的构造函数改为private私有权限。这样我们就只能通过建造者来创建ResourcePoolConfig类对象。并且，ResourcePoolConfig没有提供任何set()方法，这样我们创建出来的对象就是不可变对象了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ResourcePoolConfig</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">    <span class="keyword">this</span>.maxTotal = builder.maxTotal;</span><br><span class="line">    <span class="keyword">this</span>.maxIdle = builder.maxIdle;</span><br><span class="line">    <span class="keyword">this</span>.minIdle = builder.minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span></span><br><span class="line">  <span class="comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourcePoolConfig <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ResourcePoolConfig(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxTotal</span><span class="params">(<span class="keyword">int</span> maxTotal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxIdle</span><span class="params">(<span class="keyword">int</span> maxIdle)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMinIdle</span><span class="params">(<span class="keyword">int</span> minIdle)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig.Builder()</span><br><span class="line">        .setName(<span class="string">&quot;dbconnectionpool&quot;</span>)</span><br><span class="line">        .setMaxTotal(<span class="number">16</span>)</span><br><span class="line">        .setMaxIdle(<span class="number">10</span>)</span><br><span class="line">        .setMinIdle(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后set的方式，那就会导致在第一个set之后，对象处于无效状态。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Rectangle r = <span class="keyword">new</span> Rectange(); <span class="comment">// r is invalid</span></span><br><span class="line">r.setWidth(<span class="number">2</span>); <span class="comment">// r is invalid</span></span><br><span class="line">r.setHeight(<span class="number">3</span>); <span class="comment">// r is valid</span></span><br></pre></td></tr></table></figure>

<p>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。</p>
<p>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露set()方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig类中的成员变量，要在Builder类中重新再定义一遍。</p>
<h3 id="与工厂模式有何区别？"><a href="#与工厂模式有何区别？" class="headerlink" title="与工厂模式有何区别？"></a>与工厂模式有何区别？</h3><p><strong>工厂模式：</strong>用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p>
<p>建造者模式：建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<p>网上有一个经典的例子很好地解释了两者的区别。</p>
<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用建造者模式的情况</p>
<ul>
<li>创建对象时，必填的参数属性过多</li>
<li>参数之间有依赖关系</li>
<li>希望创建一个不可变的对象（对象创建出来就不能更改）</li>
</ul>
]]></content>
      <categories>
        <category>Java设计模式之创建型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-工厂模式</title>
    <url>/2022/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了工厂模式的三种模式， 并简单的介绍了一下DI容器的实现原理</p>
</blockquote>
<span id="more"></span>

<p>工厂模式一般情况下分为三种：简单工厂(静态工厂方法模式)、工厂方法、抽象工厂。下面一一进行介绍</p>
<h3 id="简单工厂-静态方法工厂模式"><a href="#简单工厂-静态方法工厂模式" class="headerlink" title="简单工厂(静态方法工厂模式)"></a>简单工厂(静态方法工厂模式)</h3><p>在一个工厂类A中，创建一个对象(如果对象包含子类，通过参数来决定实例化哪个子类)。由于该工厂中创建对象的方法为静态方法，故简单工厂模式又叫静态方法工厂模式</p>
<p>通过一个例子来解释什么是简单工厂。</p>
<p>在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象RuleConfig。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(</span><br><span class="line">             <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    String configText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让类的职责更加单一、代码更加清晰，我们可以进一步将上述代码中的if-else剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(</span><br><span class="line">              <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    String configText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span>&#123;</span><br><span class="line">    IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的，比如Java中的DateFormat、Calender。除此之外，工厂类中创建对象的方法一般都是create开头，比如代码中的createParser()，但有的也命名为getInstance()、createInstance()、newInstance()，有的甚至命名为valueOf()（比如Java String类的valueOf()函数）等等，这个我们根据具体的场景和习惯来命名就好。</p>
<p>在上面的代码实现中，我们每次调用RuleConfigParserFactory的createParser()的时候，都要创建一个新的parser。实际上，如果parser可以复用，为了节省内存和对象创建的时间，我们可以将parser事先创建好缓存起来。当调用createParser()函数的时候，我们从缓存中取出parser对象直接使用。</p>
<p>这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> JsonRuleConfigParser());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> XmlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> YamlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> PropertiesRuleConfigParser());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configFormat == <span class="keyword">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，简单工厂模式中可能多处有if-else语句，并且如果需要增加新的parse时，需要改动RuleConfigParserFactory类，违反了开闭原则。但是实际上，如果不是需要频繁地添加新的parser，只是偶尔修改一下RuleConfigParserFactory代码，稍微不符合开闭原则，也是完全可以接受的。</p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>如果在增加新的parse时，不想修改工厂类的代码，那么就可以利用工厂方法模式来解决(增加一个工厂接口，每个parse都创建一个工厂类，并且实现该工厂接口)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">IRuleConfigParser <span class="title">createParser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种parser的时候，只需要新增一个实现了IRuleConfigParserFactory接口的Factory类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。</p>
<p>从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现RuleConfigSource的load()函数。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    IRuleConfigParserFactory parserFactory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> JsonRuleConfigParserFactory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> XmlRuleConfigParserFactory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> YamlRuleConfigParserFactory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> PropertiesRuleConfigParserFactory();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(<span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser = parserFactory.createParser();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    String configText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了load()函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？</p>
<p>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap类是创建工厂对象的工厂类，getParserFactory()返回的是缓存好的单例工厂对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parserFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(<span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser = parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    String configText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class="line"><span class="comment">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactoryMap</span> </span>&#123; <span class="comment">//工厂的工厂</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> JsonRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> XmlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> YamlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> PropertiesRuleConfigParserFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParserFactory <span class="title">getParserFactory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());</span><br><span class="line">    <span class="keyword">return</span> parserFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的parser类和parser factory类，并且在RuleConfigParserFactoryMap类中，将新的parser factory对象添加到cachedFactories中即可。代码的改动非常少，基本上符合开闭原则。</p>
<p>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多Factory类，也会增加代码的复杂性，而且，每个Factory类只是做简单的new操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</p>
<h4 id="简单工厂-or-工厂方法"><a href="#简单工厂-or-工厂方法" class="headerlink" title="简单工厂 or 工厂方法"></a>简单工厂 or 工厂方法</h4><ul>
<li>对象的创建逻辑比较复杂，需要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式</li>
<li>如果对象的初始化比较简单，可以采用简单工厂模式</li>
</ul>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule规则配置还是System系统配置）来分类，那就会对应下面这8个parser类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">针对规则配置的解析器：基于接口IRuleConfigParser</span><br><span class="line">JsonRuleConfigParser</span><br><span class="line">XmlRuleConfigParser</span><br><span class="line">YamlRuleConfigParser</span><br><span class="line">PropertiesRuleConfigParser</span><br><span class="line"></span><br><span class="line">针对系统配置的解析器：基于接口ISystemConfigParser</span><br><span class="line">JsonSystemConfigParser</span><br><span class="line">XmlSystemConfigParser</span><br><span class="line">YamlSystemConfigParser</span><br><span class="line">PropertiesSystemConfigParser</span><br></pre></td></tr></table></figure>

<p>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个parser都编写一个工厂类，也就是要编写8个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如IBizConfigParser），那就要再对应地增加4个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？</p>
<p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser等），而不是只创建一种parser对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>\1. 类似规则配置解析的例子，代码中存在if-else分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨if-else创建对象的代码抽离出来，放到工厂类中。</li>
<li>\2. 尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</li>
</ul>
<p>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂</p>
<p>类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，我建议使用工厂方法模式。</p>
<p>除了刚刚提到的这几种情况之外，如果创建对象的逻辑并不复杂，那我们就直接通过new来创建对象就可以了，不需要使用工厂模式。</p>
<h3 id="案例（如何设计实现一个Dependency-Injection框架-）"><a href="#案例（如何设计实现一个Dependency-Injection框架-）" class="headerlink" title="案例（如何设计实现一个Dependency Injection框架?）"></a>案例（如何设计实现一个Dependency Injection框架?）</h3><h4 id="DI容器和工厂模式的区别"><a href="#DI容器和工厂模式的区别" class="headerlink" title="DI容器和工厂模式的区别"></a>DI容器和工厂模式的区别</h4><ul>
<li>DI容器最基本的设计思路就是基于工厂模式的。DI容器相当于一个大的工厂类，在程序启动时，根据配置加载需要创建的类对象。当应用需要某个对象时，直接从DI容器中获取即可。</li>
<li>DI容器相比于工厂模式来说，工厂模式仅仅只负责一个类或者几个相关联类对象的创建，而DI容器负责整个应用中对象的创建和管理。</li>
<li>DI容器的核心功能：配置解析、对象创建、对象生命周期的管理</li>
</ul>
<h4 id="DI容器的核心功能"><a href="#DI容器的核心功能" class="headerlink" title="DI容器的核心功能"></a>DI容器的核心功能</h4><p><strong>配置解析</strong></p>
<p>工厂模式的工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知DI容器要创建哪些对象。这种形式就是我们要讲的配置。</p>
<p>我们将需要由DI容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> RedisCounter redisCounter;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RateLimiter</span><span class="params">(RedisCounter redisCounter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.redisCounter = redisCounter;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCounter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String ipAddress;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedisCounter</span><span class="params">(String ipAddress, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ipAddress = ipAddress;</span><br><span class="line">    <span class="keyword">this</span>.port = port;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置文件beans.xml：</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;bean id=<span class="string">&quot;rateLimiter&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span><br><span class="line">      &lt;constructor-arg ref=<span class="string">&quot;redisCounter&quot;</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">   &lt;bean id=<span class="string">&quot;redisCounter&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xzg.redisCounter&quot;</span>&gt;</span><br><span class="line">     &lt;constructor-arg type=<span class="string">&quot;String&quot;</span> value=<span class="string">&quot;127.0.0.1&quot;</span>&gt;</span><br><span class="line">     &lt;constructor-arg type=<span class="string">&quot;int&quot;</span> value=<span class="number">1234</span>&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>上面是一个典型的Spring容器的配置文件。Spring容器读取这个配置文件，解析出要创建的两个对象：rateLimiter和redisCounter，并且得到两者的依赖关系：rateLimiter依赖redisCounter。</p>
<p><strong>对象创建</strong></p>
<p>在DI容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如BeansFactory。</p>
<p>BeanFactory通过反射的方式来动态的加载类、创建类。</p>
<p><strong>对象的生命周期管理</strong></p>
<ul>
<li>在Spring框架中，我们可以通过配置scope属性，来区分这两种不同类型的对象。scope=prototype表示返回新创建的对象，scope=singleton表示返回单例对象。</li>
<li>除此之外，我们还可以配置对象是否支持懒加载。如果lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果lazy-init=false，对象在应用启动的时候就事先创建好。</li>
<li>不仅如此，我们还可以配置对象的init-method和destroy-method方法，比如init-method=loadProperties()，destroy-method=updateConfigFile()。DI容器在创建好对象之后，会主动调用init-method属性指定的方法来初始化对象。在对象被最终销毁之前，DI容器会主动调用destroy-method属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</li>
</ul>
<h4 id="实现一个简单的DI容器"><a href="#实现一个简单的DI容器" class="headerlink" title="实现一个简单的DI容器"></a>实现一个简单的DI容器</h4><p><strong>使用方式</strong></p>
<p>DI容器的使用方式如下代码所示，接下来我们来重点介绍一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">            <span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean(<span class="string">&quot;rateLimiter&quot;</span>);</span><br><span class="line">    rateLimiter.test();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置解析</strong></p>
<p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个DI容器的最小原型。像Spring框架这样的DI容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;bean id=<span class="string">&quot;rateLimiter&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span><br><span class="line">      &lt;constructor-arg ref=<span class="string">&quot;redisCounter&quot;</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">   &lt;bean id=<span class="string">&quot;redisCounter&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xzg.redisCounter&quot;</span> scope=<span class="string">&quot;singleton&quot;</span> lazy-init=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">     &lt;constructor-arg type=<span class="string">&quot;String&quot;</span> value=<span class="string">&quot;127.0.0.1&quot;</span>&gt;</span><br><span class="line">     &lt;constructor-arg type=<span class="string">&quot;int&quot;</span> value=<span class="number">1234</span>&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">getBean</span><span class="params">(String beanId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> BeansFactory beansFactory;</span><br><span class="line">  <span class="keyword">private</span> BeanConfigParser beanConfigParser;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beansFactory = <span class="keyword">new</span> BeansFactory();</span><br><span class="line">    <span class="keyword">this</span>.beanConfigParser = <span class="keyword">new</span> XmlBeanConfigParser();</span><br><span class="line">    loadBeanDefinitions(configLocation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String configLocation)</span> </span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      in = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/&quot;</span> + configLocation);</span><br><span class="line">      <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can not find config file: &quot;</span> + configLocation);</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);</span><br><span class="line">      beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> log error</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beansFactory.getBean(beanId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext负责组装BeansFactory和BeanConfigParser两个类，串联执行流程：从classpath中加载XML格式的配置文件，通过BeanConfigParser解析为统一的BeanDefinition格式，然后，BeansFactory根据BeanDefinition来创建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanConfigParser</span> </span>&#123;</span><br><span class="line">  <span class="function">List&lt;BeanDefinition&gt; <span class="title">parse</span><span class="params">(InputStream inputStream)</span></span>;</span><br><span class="line">  <span class="function">List&lt;BeanDefinition&gt; <span class="title">parse</span><span class="params">(String configContent)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanConfigParser</span> <span class="keyword">implements</span> <span class="title">BeanConfigParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title">parse</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">    String content = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">    <span class="keyword">return</span> parse(content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title">parse</span><span class="params">(String configContent)</span> </span>&#123;</span><br><span class="line">    List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String className;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Scope scope = Scope.SINGLETON;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> lazyInit = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 省略必要的getter/setter/constructors</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope.equals(Scope.SINGLETON);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line">    SINGLETON,</span><br><span class="line">    PROTOTYPE</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorArg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRef;</span><br><span class="line">    <span class="keyword">private</span> Class type;</span><br><span class="line">    <span class="keyword">private</span> Object arg;</span><br><span class="line">    <span class="comment">// 省略必要的getter/setter/constructors</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件的解析不是我们本节内容的重点，我们只给出大概的实现思路。</p>
<p><strong>对象创建</strong></p>
<p>最后，我们来看BeansFactory是如何设计和实现的。这也是我们这个DI容器最核心的一个类了。它负责根据从配置文件解析得到的BeanDefinition来创建对象。</p>
<ul>
<li>对象创建之后会缓存在singletonObjects这样一个map中，下次再请求此对象的时候，直接从map中取出返回，不需要重新创建。如果对象的scope属性是prototype，那每次请求对象，BeansFactory都会创建一个新的对象返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeansFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如何是单例，则直接从map中返回</span></span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeanDefinitions</span><span class="params">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将beanDefinitionList保存在beanDefinitions中</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      <span class="keyword">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不是lazy的并且是单例的话，直接创建bean</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanDefinition.isLazyInit() == <span class="keyword">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">        createBean(beanDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取bean，走createBean的流程</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">    BeanDefinition beanDefinition = beanDefinitions.get(beanId);</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="string">&quot;Bean is not defined: &quot;</span> + beanId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createBean(beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例直接从map中返回bean</span></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class="line">      <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//反射获取类的class信息</span></span><br><span class="line">      Class beanClass = Class.forName(beanDefinition.getClassName());</span><br><span class="line">      <span class="comment">// 获取class构造函数的参数</span></span><br><span class="line">      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class="line">      <span class="comment">// 如果没有参数，直接实例化，如果有参数，并且参数为ref类型，则createBean(arg)</span></span><br><span class="line">      <span class="keyword">if</span> (args.isEmpty()) &#123;</span><br><span class="line">        bean = beanClass.newInstance();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class[] argClasses = <span class="keyword">new</span> Class[args.size()];</span><br><span class="line">        Object[] argObjects = <span class="keyword">new</span> Object[args.size()];</span><br><span class="line">        <span class="comment">//遍历args中的参数，如果是</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.size(); ++i) &#123;</span><br><span class="line">          BeanDefinition.ConstructorArg arg = args.get(i);</span><br><span class="line">          <span class="keyword">if</span> (!arg.getIsRef()) &#123;</span><br><span class="line">            argClasses[i] = arg.getType();</span><br><span class="line">            argObjects[i] = arg.getArg();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());</span><br><span class="line">            <span class="keyword">if</span> (refBeanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="string">&quot;Bean is not defined: &quot;</span> + arg.getArg());</span><br><span class="line">            &#125;</span><br><span class="line">            argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">            argObjects[i] = createBean(refBeanDefinition);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用bean的构造函数实例化对象</span></span><br><span class="line">        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException</span><br><span class="line">            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationFailureException(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果bean是单例，则放入map中，下次createBean时可以直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">      <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下CreateBean的步骤：</p>
<ul>
<li>如果是单例，并且singletonObjects中已经存在该bean，则直接返回</li>
<li>依次实例化bean的构造函数依赖的其他对象(三级缓存解决循环依赖的问题)</li>
<li>调用bean的构造函数完成bean的实例化</li>
<li>如果bean是单例，则放入singletonObjects中</li>
</ul>
]]></content>
      <categories>
        <category>Java设计模式之创建型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-桥接模式</title>
    <url>/2022/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文结合已经被广泛用烂的星巴克买咖啡举例，来理解桥接模式，并分析了JDBC中桥接模式的应用。</p>
</blockquote>
<span id="more"></span>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>桥接模式其实实现起来非常简单，难的地方在于理解其模式的核心思想。桥接模式的解释通常有下面两种：</p>
<h4 id="第一种解释："><a href="#第一种解释：" class="headerlink" title="第一种解释："></a>第一种解释：</h4><p>将抽象和实现解耦，让它们可以独立变化。</p>
<h4 id="第二种解释："><a href="#第二种解释：" class="headerlink" title="第二种解释："></a>第二种解释：</h4><p>一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>对于上述第二种解释，其实很好理解，我们也拿星巴克来举例，在买咖啡的时候，不仅仅有大杯、中杯、小杯之分，还有加糖、加牛奶、加冰之分，如果按照常规的继承思路来写，那么需要写3*3个子类(大杯加糖、大杯加牛奶…)，如果之后还有其他的维度，那么子类的个数会呈现指数级爆炸。</p>
<p>所以对于上述的情况，就不能用继承来写了，这个采用组合的形式，假设上述的容量维度为A，加料维度为B，我们可以将B进行抽象，在A中持有B的抽象引用，在编写代码的时候只考虑抽象逻辑，不考虑具体加料的实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订购咖啡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICoffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订咖啡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">orderCoffer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容量维度：大杯</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeCoffee</span> <span class="keyword">implements</span> <span class="title">ICoffee</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 持有添加剂维度的抽象引用</span></span><br><span class="line">    <span class="keyword">private</span> ICoffeeAdditives coffeeAdditives;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LargeCoffee</span><span class="params">(ICoffeeAdditives coffeeAdditives)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coffeeAdditives = coffeeAdditives;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderCoffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大杯&quot;</span> + coffeeAdditives.add() + <span class="string">&quot;咖啡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容量维度：中杯</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiddleCoffee</span> <span class="keyword">implements</span> <span class="title">ICoffee</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 持有添加剂维度的抽象引用</span></span><br><span class="line">    <span class="keyword">private</span> ICoffeeAdditives coffeeAdditives;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiddleCoffee</span><span class="params">(ICoffeeAdditives coffeeAdditives)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coffeeAdditives = coffeeAdditives;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderCoffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中杯&quot;</span> + coffeeAdditives.add() + <span class="string">&quot;咖啡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象添加剂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICoffeeAdditives</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 加料</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加牛奶</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">implements</span> <span class="title">ICoffeeAdditives</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;加牛奶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加糖</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> <span class="keyword">implements</span> <span class="title">ICoffeeAdditives</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;加糖&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的代码示例中，我们将添加剂进行了抽象，其实完全可以将容量进行抽象，然后让不同的添加剂持有容量维度的引用。甚至可以将两个维度都抽象，然后新定义一个类去持有这两个引用。</p>
<p>其实我们所关注的重点并不在于抽象了哪个维度，而是将某个维度的抽象和实现进行了解耦，并通过组合的方式进行了调用。</p>
<p>所以在我看来上述的两种解释其实本质是一样的。对于第二种解释来说，将多个维度的变化用组合方式来拆分，其实本质也是将抽象和实现进行解耦，我们在写代码的时候不关注其具体实现是什么，仅仅知道抽象中含有的功能即可。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>我们以JDBC为例进行讲解，我们先来看一下，如何利用JDBC驱动来查询数据库。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//加载及注册JDBC驱动程序</span></span><br><span class="line">String url = <span class="string">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;</span>;</span><br><span class="line">Connection con = DriverManager.getConnection(url);</span><br><span class="line">Statement stmt = con.createStatement()；</span><br><span class="line">String query = <span class="string">&quot;select * from test&quot;</span>;</span><br><span class="line">ResultSet rs=stmt.executeQuery(query);</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">  rs.getString(<span class="number">1</span>);</span><br><span class="line">  rs.getInt(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要把MySQL数据库换成Oracle数据库，只需要把第一行代码中的com.mysql.jdbc.Driver换成oracle.jdbc.driver.OracleDriver就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的Driver类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。</p>
<p>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</p>
<p><img src="/2022/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/1.png" alt="JDBC架构图"></p>
<p>上图其实就可以很好的理解第一种解释了，JDBC在访问的时候并不考虑访问的具体是哪个数据库，它仅仅只关注于抽象Driver（它只要知道Driver类具有访问某个数据库的能力即可），真正的Driver实现交给不同数据库厂商来实现，如果我们要访问某个特定的数据库，只要将对应的数据库驱动注入到DriverManager中即可。</p>
]]></content>
      <categories>
        <category>Java设计模式之结构型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之-单例模式</title>
    <url>/2022/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文详细的介绍了设计模式中最常用的“单例模式”的实现方法，并用实际的例子来编写示例。</p>
</blockquote>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式(概念中对象的唯一性指的是进程内唯一)。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>全局唯一类(如何资源配置文件)</li>
<li>资源访问冲突类(打印日志类)</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面以资源缓存类为例，保证上下文中资源缓存类唯一。</p>
<ul>
<li><p>饿汉式</p>
</li>
<li><ul>
<li>饿汉式保证了线程安全性，但是无法实现延迟加载，在类加载的时候已经初始化完成。</li>
<li>线程的安全性靠JVM保证，每个类在内存中只会加载一次。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOSCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AIOSCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AIOSCache singleton = <span class="keyword">new</span> AIOSCache();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AIOSCache <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>懒汉式</p>
</li>
<li><ul>
<li>懒汉式解决了饿汉式无法延迟加载的问题，但是由于在方法级别加了锁，导致并发的性能低下</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOSCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AIOSCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AIOSCache singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> AIOSCache <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> AIOSCache();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>双重检测</p>
</li>
<li><ul>
<li>双重检测解决了懒汉式的性能问题，采用两次检测 + 更细粒度的锁来实现</li>
</ul>
</li>
</ul>
<p>下面的代码还是会有一些问题</p>
<p>singleton = new AIOSCache() 并不是一个原子操作，总共分为三步：</p>
<p>（1）在堆上给对象分配内存空间</p>
<p>（2）初始化对象(执行构造函数)</p>
<p>（3）将对象内存空间的地址赋值给变量singleton</p>
<p>上述(2)和(3)由于之间没有逻辑依赖关系，JVM可能为了提高性能而进行指令的重排序，将(2)和(3)交换顺序执行。</p>
<p>所以可能出现一种情况，线程A执行对象的初始化操作，先进行了(3)，还未执行(2)或者(2)还未执行完，此时线程B判断对象已经不为空了，即在外部使用了对象。</p>
<p>解决办法：singleton变量加上volatile即可(禁止指令重排序)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOSCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AIOSCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AIOSCache singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AIOSCache <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (AIOSCache.class) &#123;</span><br><span class="line">                <span class="comment">// 之所以要两次判空，是因为加锁只能保证多线程不会同时执行代码块，并不能保证该类仅初始化一次</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> AIOSCache();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>静态内部类</p>
</li>
<li><ul>
<li>既能保证线程安全，也可以实现延迟加载，性能也不差</li>
<li>静态内部类保证对象的实例化在使用的时候才会加载，线程安全由JVM保证(类加载只会进行一次)，并且还没有加锁。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOSCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AIOSCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AIOSCache singleton = <span class="keyword">new</span> AIOSCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AIOSCache <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>枚举</p>
</li>
<li><ul>
<li>最简单的一种方式，由Java的枚举类型保证线程安全和实例唯一。</li>
<li>其中从反编译后的代码可以看出，单例的思想和枚举相似，都是只留一个获取实例对象的入口，其他的全部封死。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>单例将实例权限和构造函数设置为private，无法通过“继承”和“.变量”的形式获取，仅留一个get方法</li>
<li>枚举方式通过设置final来无法继承类，并且不开放get方法获取实例以及构造函数私有，仅仅通过“.变量”的形式访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AIOSCache</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过javap后的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOSCache</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">AIOSCache</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AIOSCache INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">    	INSTANCE = <span class="keyword">new</span> AIOSCache();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> AIOSCache&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li><p>单例对OOP特性的支持不友好</p>
</li>
<li><ul>
<li>单例类对抽象、继承、多态的支持也不友好，不具有可读性</li>
</ul>
</li>
<li><p>单例会隐藏类之间的依赖关系</p>
</li>
<li><ul>
<li>通过构造函数、参数传递声明的类的依赖关系，通过查看函数的定义就很容易识别，但是单例类可以在函数中直接使用，不需要创建。</li>
</ul>
</li>
<li><p>单例对代码的扩展不友好</p>
</li>
<li><ul>
<li>单例类相当于硬编码，如果之后需求变动，需要改动所有使用单例类的地方</li>
</ul>
</li>
<li><p>单例对代码的可测试性不友好</p>
</li>
<li><ul>
<li>如果单例类依赖比较中的外部资源，比如DB，当我们测试的时候无法通过mock的形式替换其代码。</li>
</ul>
</li>
<li><p>单例不支持有参数的构造函数</p>
</li>
<li><ul>
<li>增加init函数，获取实例前，先调用init方法</li>
<li>将参数放到getInstance中</li>
<li>增加全局配置类，单例中在默认构造函数中直接初始化(推荐)，适用于常量。</li>
</ul>
</li>
</ul>
<h2 id="单例的其他替代解决方案"><a href="#单例的其他替代解决方案" class="headerlink" title="单例的其他替代解决方案"></a>单例的其他替代解决方案</h2><ul>
<li>使用静态方法、工厂模式、springIOC容器等</li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>上面我们知道了单例是进程内唯一的</p>
<ul>
<li>如何设计一个线程内唯一的单例（Java提供了ThreadLocal并发工具类）</li>
</ul>
<p><img src="/2022/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1.png" alt="ThreadLocal原理图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOSCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AIOSCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Long, AIOSCache&gt; instances = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AIOSCache <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> id = Thread.currentThread().getId();</span><br><span class="line">        instances.putIfAbsent(id, <span class="keyword">new</span> AIOSCache());</span><br><span class="line">        <span class="keyword">return</span> instances.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如何实现集群环境下的单例，需要将对象保存到文件中</p>
</li>
<li><ul>
<li>获取对象时，首先加锁，然后在获取</li>
<li>对象使用完时，将对象保存到文件中，并释放对象和锁</li>
</ul>
</li>
<li><p>如何实现多例模式 (两种理解)</p>
</li>
<li><ul>
<li>一个类可以创建多个对象，但是个数是有限的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOSCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AIOSCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, AIOSCache&gt; instances = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instances.put(<span class="number">1</span>, <span class="keyword">new</span> AIOSCache());</span><br><span class="line">        instances.put(<span class="number">2</span>, <span class="keyword">new</span> AIOSCache());</span><br><span class="line">        instances.put(<span class="number">3</span>, <span class="keyword">new</span> AIOSCache());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AIOSCache <span class="title">getInstances</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AIOSCache <span class="title">getRandomInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> id = random.nextInt(COUNT) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> instances.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>同一种类型的只能创建一个对象，比如name相同的创建一个对象（枚举就是这种多例模式）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class="line">          = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">(String loggerName)</span> </span>&#123;</span><br><span class="line">    instances.putIfAbsent(loggerName, <span class="keyword">new</span> Logger());</span><br><span class="line">    <span class="keyword">return</span> instances.get(loggerName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印log日志</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java设计模式之创建型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/2022/02/27/Java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>  本文介绍了注解的基本用法，包括注解的定义、属性以及常用的 元注解和Java内置的注解。</p>
</blockquote>
<span id="more"></span>

<h2 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h2><p>注解是在Java SE5.0版本后开始引入的概念，同Class和Interface一样，注解也是一种类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> customAnnotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注解的定义上可以看出，其实注解的写法和接口很像，只是前面多了一个@符号而已。</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>在介绍注解之前，我们先来介绍下什么是元注解。简单的来说，元注解就是可以应用在其他注解上的注解，是一种基本注解。举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Override这个注解想必大家都不陌生，是一种标记注解，用来表明当前方法是子类重写父类的方法。</p>
<p>这个注解上面有两个注解：@Target、@Retention，这两个注解就是元注解。除了这两种外，常见的元注解还有：@Inherited、@Documented、@Repeatable。下面对这些注解进行一下简要的介绍。</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>当@Retention注解到其他注解上时，定义了这个注解的存活时间。他的取值如下所示：</p>
<ul>
<li>  RetentionPolicy.SOURCE：表明注解只在源码阶段有效，编译器在编译时将忽视该注解，即不会保留在编译好的class文件中。</li>
<li>  RetentionPolicy.CLASS(<strong>默认</strong>)：表明注解不会被加载到JVM内存中，仅会在源码和Class文件中有效。</li>
<li>  RetentionPolicy.RUNTIME：在运行期时该注解的信息也存在，即可以通过Java的反射机制获取到该注解的基本信息。</li>
</ul>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>@Target可以用来约束注解可以应用的地方，常用的取值如下所示：</p>
<ul>
<li>  ElementType.FIELD ：表明该注解可以作用在字段域。</li>
<li>  ElementType.TYPE：表明该注解可以作用在类、接口上。</li>
<li>  ElementType.METHOD：表明该注解可以作用在方法上。</li>
<li>  ElementType.PARAMETER：表明该注解可以作用在参数声明上。</li>
<li>  ElementType.CONSTRUCTOR：表明该注解可以作用在构造方法上</li>
<li>  ElementType.ANNOTATION_TYPE：表明该注解可以作用在另一个注解上。</li>
<li>  ElementType.PACKAGE ：表明该注解可以作用在包上。</li>
<li>  ElementType.LOCAL_VARIABLE：表明该注解可以作用局部变量上。</li>
</ul>
<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>@Documented指定了注解的基本信息会出现在JavaDoc的文档中。</p>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>Inherited的意思是继承，但是并不表示注解可以继承，而是表示如果注解A被@Inherited修饰，那么注解A作用的类，其子类也是继承该注解A。</p>
<h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><p>Repeatable的意思是可重复，是Java8之后引入的新特性。可以在同一个类上重复应用相同的某个注解。举个例子：</p>
<ul>
<li>  Animal注解：接受一个动物的名字name</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(Animals.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Animal &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  注解容器：用来保存多个Animal的容器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Animals &#123;</span><br><span class="line">    Animal[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Animal(name = &quot;cat&quot;)</span></span><br><span class="line"><span class="meta">@Animal(name = &quot;dog&quot;)</span></span><br><span class="line"><span class="meta">@Animal(name = &quot;bird&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;TestDemo&gt; clazz = TestDemo.class;</span><br><span class="line">        <span class="comment">//1. 通过getDeclaredAnnotationsByType方法也可以获取</span></span><br><span class="line">        <span class="comment">//Animal[] annotationsByType = clazz.getDeclaredAnnotationsByType(Animal.class);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 通过getAnnotation无法获取到Animal注解的信息</span></span><br><span class="line">        <span class="comment">//Animal annotation = clazz.getAnnotation(Animal.class);</span></span><br><span class="line">        Animal[] annotationsByType = clazz.getAnnotationsByType(Animal.class);</span><br><span class="line">        System.out.println(annotationsByType.length);</span><br><span class="line">        <span class="keyword">for</span> (Animal animal : annotationsByType) &#123;</span><br><span class="line">            System.out.println(animal.name());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">cat</span><br><span class="line">dog</span><br><span class="line">bird</span><br></pre></td></tr></table></figure>

<h2 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h2><p>注解中只有属性，没有方法，但是属性的定义是以“无参数的方法来声明的”，方法的名字就是属性的名字，方法的返回值就是属性的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(Animals.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Animal &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述自定义的@Animal注解中定义了一个属性name，类型是String，默认值为空字符串。使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Animal(name = &quot;cat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要在需要的类上增加其中@Animal即可，并可以自定义name的值，如果@Animal的属性值为value，则可以省略不写。4</p>
<h2 id="注解的原理"><a href="#注解的原理" class="headerlink" title="注解的原理"></a>注解的原理</h2><p>待补充（代理实现）</p>
<h2 id="Java内置的注解"><a href="#Java内置的注解" class="headerlink" title="Java内置的注解"></a>Java内置的注解</h2><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p>表示@Override修饰的方法是子类重写父类的</p>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>用来修饰某个类、方法已经过时，可能在之后的JDK版本后会删除。</p>
<h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>可以用来消除编译器产生的警告信息</p>
]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>Java系列----注解</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之---代理模式</title>
    <url>/2022/02/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  本文详细的介绍了Java设计模式中的“代理模式”，并用实际的例子加深理解。</p>
</blockquote>
<span id="more"></span>

<p>代理模式是一种额外访问目标对象的方法，可以在不更改目标对象逻辑的前提下，提供额外的功能操作，扩展目标对象的功能。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>这种代理模式需要代理对象和目标对象实现一样的接口。</p>
<p>优点：可以在不修改目标对象的前提下扩展目标对象的功能。</p>
<p>缺点：</p>
<ol>
<li>  一旦有很多的目标对象需要代理，那么整个项目中会有很多的代理类。</li>
<li>  而且如果目标对象中需要代理的方法很多，那么代理类中会出现大量重复的代码。</li>
<li>  如果目标接口的增加方法，目标对象和代理对象都需要修改。</li>
</ol>
<blockquote>
<p>  举例：用户登录的代理实现</p>
</blockquote>
<ul>
<li>  接口类：IUserLogin</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserLogin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  目标对象：UserLogin</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLogin</span> <span class="keyword">implements</span> <span class="title">IUserLogin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户登录！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  代理对象：UserLoginProxy</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginProxy</span> <span class="keyword">implements</span> <span class="title">IUserLogin</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserLogin userLogin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserLoginProxy</span><span class="params">(UserLogin userLogin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userLogin = userLogin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before login()&quot;</span>);</span><br><span class="line">        userLogin.login();</span><br><span class="line">        System.out.println(<span class="string">&quot;after login()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    UserLogin login = <span class="keyword">new</span> UserLogin();</span><br><span class="line">    UserLoginProxy proxy = <span class="keyword">new</span> UserLoginProxy(login);</span><br><span class="line">    proxy.login();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  输出结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">before login()</span><br><span class="line">用户登录！</span><br><span class="line">after login()</span><br></pre></td></tr></table></figure>

<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理利用JDK API来实现，动态的在内存中创建代理对象，需要<strong>目标对象必须实现接口</strong>，否则不能使用该方式创建动态代理。</p>
<p>静态代理和动态代理的区别：</p>
<ul>
<li>  静态代理在编译期间实现，动态代理在运行时创建</li>
</ul>
<blockquote>
<p>  举例：用户登录代理实现</p>
</blockquote>
<ul>
<li>  接口类：IUserLogin</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserLogin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  目标对象：UserLogin</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLogin</span> <span class="keyword">implements</span> <span class="title">IUserLogin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户登录！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  代理对象的逻辑：UserLoginProxy(实现InvocationHandler接口，在实际使用时可以用匿名内部类)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserLoginProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JDK动态代理 before---login()&quot;</span>);</span><br><span class="line">        method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;JDK动态代理 after---login()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  代理工厂类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; obj, InvocationHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                obj.getClassLoader(), obj.getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserLogin userLogin = <span class="keyword">new</span> UserLogin();</span><br><span class="line">        System.out.println(userLogin.getClass());</span><br><span class="line">        UserLoginProxy userLoginProxy = <span class="keyword">new</span> UserLoginProxy(userLogin);</span><br><span class="line">        IUserLogin proxy = (IUserLogin) ProxyFactory.createProxy(userLogin.getClass(), userLoginProxy);</span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line">        proxy.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  输出结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class com.alibaba.global.login.UserLogin</span><br><span class="line">class com.sun.proxy.$Proxy0</span><br><span class="line">JDK动态代理 before---login()</span><br><span class="line">用户登录！</span><br><span class="line">JDK动态代理 after---login()</span><br></pre></td></tr></table></figure>

<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>CGLIB是动态代理的另一种实现方式，是一个第三方代码生成类库，通过<strong>在运行时动态的创建目标对象的子类</strong>来扩展目标对象的功能。</p>
<p>CGLIB动态代理和JDK动态代理的区别：</p>
<ul>
<li>  CGLIB动态代理为目标对象的子类，由于Java的单继承原则，所以代理对象不能在继承其他类，而JDK动态代理是实现接口，可以继承其他类。</li>
<li>  JDK动态代理要求目标对象必须实现接口，而CGLIB不需要。所以在目标对象没有接口时，可以采用CGLIB动态代理。</li>
<li>  CGLIB需要单独引入lib包。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  举例：用户登录代理实现</p>
</blockquote>
<ul>
<li>  接口类：IUserLogin</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserLogin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  目标对象：UserLogin</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLogin</span> <span class="keyword">implements</span> <span class="title">IUserLogin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户登录！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  代理对象的逻辑：UserLoginProxy(实现MethodInterceptor接口，在实际使用时可以用匿名内部类)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserLoginProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// o 为代理对象，objects为method的参数列表</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB动态代理 before---login()&quot;</span>);</span><br><span class="line">        method.invoke(target, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB动态代理 after---login()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  代理工厂类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; obj, MethodInterceptor interceptor)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(obj);</span><br><span class="line">        enhancer.setCallback(interceptor);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserLogin userLogin = <span class="keyword">new</span> UserLogin();</span><br><span class="line">        System.out.println(userLogin.getClass());</span><br><span class="line">        UserLoginProxy userLoginProxy = <span class="keyword">new</span> UserLoginProxy(userLogin);</span><br><span class="line">        UserLogin proxy = (UserLogin) ProxyFactory.createProxy(userLogin.getClass(), userLoginProxy);</span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line">        proxy.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  输出结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class com.alibaba.global.login.UserLogin</span><br><span class="line">class com.alibaba.global.login.UserLogin$$EnhancerByCGLIB$$156ad493</span><br><span class="line">CGLIB动态代理 before---login()</span><br><span class="line">用户登录！</span><br><span class="line">CGLIB动态代理 after---login()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java设计模式之结构型</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>家用路由器桥接</title>
    <url>/2022/02/19/%E5%AE%B6%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A1%A5%E6%8E%A5/</url>
    <content><![CDATA[<blockquote>
<p>  我们都知道，路由器的信号会随着距离的增加而变弱，尤其是中间还隔着障碍物时。这样势必就会导致家里面有些房间的wifi信号很差。此时我们就可以采用“桥接 ”或“中继”模式，将两个路由器连接起来，进而达到放大家用路由器wifi信号的功能。</p>
</blockquote>
<span id="more"></span>

<h2 id="桥接和中继的区别"><a href="#桥接和中继的区别" class="headerlink" title="桥接和中继的区别"></a>桥接和中继的区别</h2><p>以下是我自己的理解。<br>路由器的桥接是将两个不同的局域网连接起来，第二个路由器叫做二级路由，这个二级路由有自己的网关、网端、并且可以自主分配DHCP服务器。中继模式则是将主路由的wifi信号进行扩大，第二个路由器相当于交换机，需要将网关和主路由的网关设置在同一网段、并且需要关闭DHCP功能，在中继模式下，接入副路由器的终端设备是从主路由获取的IP地址。<br>综上，桥接模式和中继模式的区别可以从两个方面区分：</p>
<ul>
<li>看接入副路由器的设备的ip地址和主路由的ip地址是否在同一网段：在同一网段为中继模式，不在同一网段为桥接模式</li>
<li>看副路由和主路由的连接方式：主路由LAN -&gt; 副路由WAN(有线、无线均可)为桥接、主路由LAN -&gt; 副路由LAN(有线、无线均可)为中继</li>
</ul>
<h2 id="无线桥接实例"><a href="#无线桥接实例" class="headerlink" title="无线桥接实例"></a>无线桥接实例</h2><p>主路由器：小米<br>副路由器：Tenda N300 v2(相当老的一个路由器，没有5g芯片，哈哈哈)</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>主路由器可以正常上网，记住主路由器的SSID、密码即可<br>下面开始对副路由器进行设置：</p>
<ol>
<li>连接tenda的wifi，第一次不需要输入密码</li>
<li>登录路由器管理界面：192.168.0.1</li>
<li>打开无线设置 -&gt; 找到无线基本设置 -&gt; 选择网桥(WDS) -&gt; 开始扫描 -&gt; 勾选主路由器的SSID</li>
</ol>
<p><img src="/2022/02/19/%E5%AE%B6%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A1%A5%E6%8E%A5/1.png" alt="image.png"></p>
<pre><code>4. 选择无线加密 -&gt; 禁用WPS，设置副路由器的安全规则、加密算法和密码(与主路由相同)
</code></pre>
<ol start="5">
<li>选择高级设置 -&gt; 选择WAN口介质类型 -&gt; 选择无线WAN -&gt; 输入主路由器的SSID和密码，并开始扫描</li>
</ol>
<p><img src="/2022/02/19/%E5%AE%B6%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A1%A5%E6%8E%A5/2.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>路由器</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬取“谁是高手·双升”视频链接</title>
    <url>/2022/01/08/Python%E7%88%AC%E5%8F%96%E3%80%8A%E8%B0%81%E6%98%AF%E9%AB%98%E6%89%8B%C2%B7%E5%8F%8C%E5%8D%87%E3%80%8B%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>​    高中三年陪伴我最久的电视节目就是《谁是高手 · 双升》，天天中午吃饭必看。后来上了大学之后，开始在<a href="http://www.sxrtv.com/content/c/d/">山西网络广播电视台</a>观看，但是该网站更新到2121年1月1日的视频之后就不更新了。后来发现只能通过《黄河plus》APP观看直播或者重播了。但是这个APP的观看体验不是很好，无法像其他的视频APP一样方便的快进或者快退。于是写了如下的代码，用来爬取《黄河plus》中《谁是高手 · 双升》的视频。</p>
<span id="more"></span>
<img src="谁是高手.png" style="zoom: 80%;" />

<h3 id="1-抓取APP数据包"><a href="#1-抓取APP数据包" class="headerlink" title="1. 抓取APP数据包"></a>1. 抓取APP数据包</h3><h4 id="（1）获取视频链接"><a href="#（1）获取视频链接" class="headerlink" title="（1）获取视频链接"></a>（1）获取视频链接</h4><p>​    用Fiddler抓取手机APP《黄河plus》的数据包(Fiddler抓取手机数据包的教程可以自行百度)。如下图所示：</p>
<blockquote>
<p>  <strong>注：</strong>采用Fiddler抓取数据包需要在手机上配置代理，可能会导致某些APP无法联网，很不幸的是我爬取的《黄河plus》APP就在其中。通过网上教程去修改注册表没有成功，在酷安上找到解决办法，在Edxp中刷入TrustMeAlready模块即可解决。</p>
</blockquote>
<p><img src="/2022/01/08/Python%E7%88%AC%E5%8F%96%E3%80%8A%E8%B0%81%E6%98%AF%E9%AB%98%E6%89%8B%C2%B7%E5%8F%8C%E5%8D%87%E3%80%8B%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5/Fiddle%E6%8A%93%E5%8C%85.png"></p>
<p>​    根据上图，我们可以分析出《黄河plus》首先通过<a href="https://livehhhttps.sxrtv.com/lsdream/g5tlpe0/800/1625547000000,1625556000000.m3u8%E6%9D%A5%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E6%AE%B5%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89ts%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E5%88%86%E5%88%AB%E4%B8%8B%E8%BD%BDts%E8%A7%86%E9%A2%91%E5%B9%B6%E6%92%AD%E6%94%BE%E3%80%82%E5%85%B6%E4%B8%AD1625547000000%E5%92%8C1625556000000%E5%88%86%E5%88%AB%E4%B8%BA%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4%E5%AF%B9%E5%BA%94%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E3%80%82m3u8%E7%9A%84%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%E3%80%82">https://livehhhttps.sxrtv.com/lsdream/g5tlpe0/800/1625547000000,1625556000000.m3u8来获取指定时间段内的所有ts视频文件，然后在分别下载ts视频并播放。其中1625547000000和1625556000000分别为指定时间范围对应的时间戳。m3u8的文件内容如下图所示。</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VERSION:<span class="number">3</span></span><br><span class="line">#EXT-X-PLAYLIST-TYPE:VOD</span><br><span class="line">#EXT-X-TARGETDURATION:<span class="number">10</span></span><br><span class="line">#EXT-X-MEDIA-SEQUENCE:<span class="number">0</span></span><br><span class="line">#EXTINF:<span class="number">10</span>,</span><br><span class="line"><span class="number">1625500800000</span>/46204149D10.ts</span><br><span class="line">#EXTINF:<span class="number">10</span>,</span><br><span class="line"><span class="number">1625500800000</span>/46214358D10.ts</span><br><span class="line">#EXTINF:<span class="number">10</span>,</span><br><span class="line"><span class="number">1625500800000</span>/46225030D10.ts</span><br><span class="line">#EXTINF:<span class="number">10</span>,</span><br><span class="line"><span class="number">1625500800000</span>/46234272D10.ts</span><br><span class="line">#EXTINF:<span class="number">10</span>,</span><br><span class="line"><span class="number">1625500800000</span>/46244605D10.ts</span><br><span class="line">#EXTINF:<span class="number">10</span>,</span><br><span class="line"><span class="number">1625500800000</span>/46255118D10.ts</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>​    可以发现m3u8的返回值包含该时间范围内的所有ts文件，并且ts文件下载的链接地址和获取m3u8的url地址前缀相同。所以《谁是高手》视频链接已经获取成功。</p>
<h4 id="（2）获取每天随机字符串的url地址"><a href="#（2）获取每天随机字符串的url地址" class="headerlink" title="（2）获取每天随机字符串的url地址"></a>（2）获取每天随机字符串的url地址</h4><p>​    后来在测试代码的时候，无意中发现视频下载地址的url中“g5tlpe0”字符串每天都不一样，是一个随机的值，这就非常头疼， 不可能每天修改代码，于是继续上述的抓取《黄河plus》数据包过程。经过不懈的努力，终于发现了一个很重要的url地址，如下图所示：</p>
<p><img src="/2022/01/08/Python%E7%88%AC%E5%8F%96%E3%80%8A%E8%B0%81%E6%98%AF%E9%AB%98%E6%89%8B%C2%B7%E5%8F%8C%E5%8D%87%E3%80%8B%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5/token.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">request:</span><br><span class="line">    https://dyhhplus.sxrtv.com/apiv3.8//m3u8.php?token=***</span><br><span class="line"></span><br><span class="line">response:</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;status&quot;:1,</span><br><span class="line">        &quot;message&quot;:&quot;成功&quot;,</span><br><span class="line">        &quot;address&quot;:&quot;&quot;,</span><br><span class="line">        &quot;tss&quot;:&quot;g5tlpe0&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    从图中红框中的url中可以看出，该url地址的响应中包含一个“tss”字段，其值对应的就是每天随机的字符串。所以现在只要能获取到这个地址中的token参数即可。</p>
<h4 id="（3）破解Token"><a href="#（3）破解Token" class="headerlink" title="（3）破解Token"></a>（3）破解Token</h4><p>​    在Fiddler中没有找到Token的任何信息，于是直接通过BlackDex + Jadx的方式，将《黄河plus》的APK安装包进行反编译。</p>
<blockquote>
<p>  <strong>注:</strong> BlackDex用来给APP脱壳，并生成APP的dex文件</p>
<p>  <strong>注:</strong> Jadx用来将dex文件反编译出APP的源码</p>
</blockquote>
<p>​    在源码中通过一顿猛如虎的瞎操作后，终于找到了生成Token的源码位置，如下所示。下面展示的源码是获取随机字符串的url调用位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLiveUrl</span><span class="params">(String str, String str2)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        Utils.OkhttpGet().url(NetApi.M3U8).addParams(<span class="string">&quot;token&quot;</span>, (Object) String.valueOf(getLiveUrl.getLiveToken(str, str2))).build().execute(<span class="keyword">new</span> StringCallback() &#123;</span><br><span class="line">            <span class="comment">/* class tide.juyun.com.ui.activitys.NewLiveJMDActivity.AnonymousClass8 */</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">// tide.juyun.com.okhttputils.callback.Callback</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Call call, Exception exc)</span> </span>&#123;</span><br><span class="line">                NewLiveJMDActivity.<span class="keyword">this</span>.dialog.cancel();</span><br><span class="line">                NewLiveJMDActivity.<span class="keyword">this</span>.initVideo();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, String str)</span> </span>&#123;</span><br><span class="line">                NewLiveJMDActivity.<span class="keyword">this</span>.dialog.cancel();</span><br><span class="line">                <span class="keyword">if</span> (Utils.getErrMsg(str).contains(<span class="string">&quot;成功&quot;</span>)) &#123;</span><br><span class="line">                    NewLiveJMDActivity.<span class="keyword">this</span>.mVideoUrl = Utils.getOtherMegString(str, ConstantValues.ADDRESS);</span><br><span class="line">                    <span class="keyword">if</span> (!NewLiveJMDActivity.<span class="keyword">this</span>.mVideoUrl.contains(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">                        NewLiveJMDActivity newLiveJMDActivity = NewLiveJMDActivity.<span class="keyword">this</span>;</span><br><span class="line">                        newLiveJMDActivity.mVideoUrl = NetApi.getPHPURL() + NewLiveJMDActivity.<span class="keyword">this</span>.mVideoUrl;</span><br><span class="line">                    &#125;</span><br><span class="line">                    NewLiveJMDActivity.<span class="keyword">this</span>.mTss = Utils.getOtherMegString(str, <span class="string">&quot;tss&quot;</span>);</span><br><span class="line">                    NewLiveJMDActivity.<span class="keyword">this</span>.initVideo();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                NewLiveJMDActivity.<span class="keyword">this</span>.initVideo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    继续深入查看getLiveToken函数。从源码可以可以看出，getLiveToken将给定的两个字符串经过md5求值之后通过一系列截取拼接得到一个字符串，然后将该字符串与当前获取的时间拼接后也进行md5求值，之后经过一系列乱七八糟的步骤返回。这个str4即为最终的token。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLiveToken</span><span class="params">(String str, String str2)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String str3 = (System.currentTimeMillis() / <span class="number">1000</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String md52 = getMd5(str + <span class="string">&quot;Tide&quot;</span> + str2);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        sb.append(md52.substring(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">        sb.append(md52.substring(<span class="number">4</span>, <span class="number">8</span>));</span><br><span class="line">        sb.append(md52.substring(<span class="number">14</span>, <span class="number">15</span>));</span><br><span class="line">        sb.append(md52.substring(<span class="number">13</span>, <span class="number">14</span>));</span><br><span class="line">        sb.append(md52.substring(<span class="number">12</span>, <span class="number">13</span>));</span><br><span class="line">        sb.append(md52.substring(<span class="number">25</span>, <span class="number">29</span>));</span><br><span class="line">        sb.append(md52.substring(<span class="number">30</span>, <span class="number">31</span>));</span><br><span class="line">        sb.append(md52.substring(<span class="number">29</span>, <span class="number">30</span>));</span><br><span class="line">        sb.append(md52.substring(<span class="number">28</span>, <span class="number">29</span>));</span><br><span class="line">        sb.append(md52.substring(<span class="number">27</span>, <span class="number">28</span>));</span><br><span class="line">        sb.append(md52.substring(<span class="number">26</span>, <span class="number">27</span>));</span><br><span class="line">        String md53 = getMd5(<span class="string">&quot;tide&quot;</span> + str3 + sb.toString());</span><br><span class="line">        String replace = <span class="keyword">new</span> String(C0196Base64.encodeBase64((<span class="string">&quot;t=&quot;</span> + str3 + <span class="string">&quot;&amp;c=&quot;</span> + str + <span class="string">&quot;&amp;a=&quot;</span> + str2 + <span class="string">&quot;&amp;v=&quot;</span> + (md53.substring(<span class="number">4</span>, <span class="number">5</span>) + md53.substring(<span class="number">16</span>, <span class="number">17</span>) + md53.substring(<span class="number">31</span>, <span class="number">32</span>) + md53.substring(<span class="number">17</span>, <span class="number">18</span>) + md53.substring(<span class="number">8</span>, <span class="number">9</span>))).getBytes(<span class="string">&quot;UTF-8&quot;</span>))).replace(ContainerUtils.KEY_VALUE_DELIMITER, HiAnalyticsConstant.REPORT_VAL_SEPARATOR);</span><br><span class="line">        String trim = Pattern.compile(<span class="string">&quot;[^1-9]&quot;</span>).matcher(replace).replaceAll(<span class="string">&quot;&quot;</span>).trim();</span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; trim.length()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i2 = i + <span class="number">1</span>;</span><br><span class="line">            String substring = trim.substring(i, i2);</span><br><span class="line">            <span class="keyword">if</span> (!arrayList.contains(Integer.valueOf(Integer.parseInt(substring)))) &#123;</span><br><span class="line">                arrayList.add(Integer.valueOf(Integer.parseInt(substring)));</span><br><span class="line">            &#125;</span><br><span class="line">            i = i2;</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator it = arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(((Integer) it.next()).intValue());</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator it2 = arrayList.iterator();</span><br><span class="line">        String str4 = replace;</span><br><span class="line">        <span class="keyword">while</span> (it2.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> intValue = ((Integer) it2.next()).intValue();</span><br><span class="line">            <span class="keyword">if</span> (intValue % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                String substring2 = replace.substring(intValue - <span class="number">1</span>, intValue);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&quot;</span>.indexOf(substring2) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> indexOf = (<span class="string">&quot;abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&quot;</span>.indexOf(substring2) + (intValue * intValue)) % <span class="number">52</span>;</span><br><span class="line">                    str4 = replaceSomeWhere(str4, <span class="string">&quot;abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&quot;</span>.substring(indexOf, indexOf + <span class="number">1</span>), intValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String substring3 = replace.substring(intValue - <span class="number">1</span>, intValue);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&quot;</span>.indexOf(substring3) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> indexOf2 = (<span class="string">&quot;abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&quot;</span>.indexOf(substring3) + intValue) % <span class="number">52</span>;</span><br><span class="line">                    str4 = replaceSomeWhere(str4, <span class="string">&quot;abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&quot;</span>.substring(indexOf2, indexOf2 + <span class="number">1</span>), intValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    在知道《黄河plus》的程序员小哥哥是如何编写token之后，就可以直接开始模仿了，Python直接将上述的逻辑复现一遍如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换时的字符串常量</span></span><br><span class="line">zm_constant = <span class="string">&quot;abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算给定字符串的MD5值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMd5</span>(<span class="params">s</span>):</span></span><br><span class="line">    md52 = hashlib.md5(s.encode(<span class="string">&quot;utf-8&quot;</span>)).digest()</span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> md52:</span><br><span class="line">        i = b &amp; <span class="number">255</span></span><br><span class="line">        result += <span class="string">&#x27;&#123;:02x&#125;&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用指定的des_str代替str4的index索引处的字母</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSomeWhere</span>(<span class="params">str4, des_str, index</span>):</span></span><br><span class="line">    <span class="keyword">if</span> index != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> str4[<span class="number">0</span>:index - <span class="number">1</span>] + des_str + str4[index:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> des_str + str4[index:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每天的Token值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getToken</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    md52_str = getMd5(str1 + <span class="string">&quot;Tide&quot;</span> + str2)</span><br><span class="line">    result += md52_str[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    result += md52_str[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line">    result += md52_str[<span class="number">14</span>:<span class="number">15</span>]</span><br><span class="line">    result += md52_str[<span class="number">13</span>:<span class="number">14</span>]</span><br><span class="line">    result += md52_str[<span class="number">12</span>:<span class="number">13</span>]</span><br><span class="line">    result += md52_str[<span class="number">25</span>:<span class="number">29</span>]</span><br><span class="line">    result += md52_str[<span class="number">30</span>:<span class="number">31</span>]</span><br><span class="line">    result += md52_str[<span class="number">29</span>:<span class="number">30</span>]</span><br><span class="line">    result += md52_str[<span class="number">28</span>:<span class="number">29</span>]</span><br><span class="line">    result += md52_str[<span class="number">27</span>:<span class="number">28</span>]</span><br><span class="line">    result += md52_str[<span class="number">26</span>:<span class="number">27</span>]</span><br><span class="line">    str3 = <span class="built_in">int</span>(datetime.datetime.now().timestamp())</span><br><span class="line">    md53_str = getMd5(<span class="string">&quot;tide&quot;</span> + <span class="built_in">str</span>(str3) + result)</span><br><span class="line">    replace = base64.b64encode((<span class="string">&quot;t=&quot;</span> + <span class="built_in">str</span>(str3) + <span class="string">&quot;&amp;c=&quot;</span> + str1 + <span class="string">&quot;&amp;a=&quot;</span> + str2 + <span class="string">&quot;&amp;v=&quot;</span> +</span><br><span class="line">                                md53_str[<span class="number">4</span>:<span class="number">5</span>] + md53_str[<span class="number">16</span>:<span class="number">17</span>] + md53_str[<span class="number">31</span>:<span class="number">32</span>] + md53_str[<span class="number">17</span>:<span class="number">18</span>] + md53_str[</span><br><span class="line">                                                                                                      <span class="number">8</span>:<span class="number">9</span>]).encode(</span><br><span class="line">        <span class="string">&quot;utf-8&quot;</span>)).decode().replace(</span><br><span class="line">        <span class="string">&quot;=&quot;</span>, <span class="string">&quot;|&quot;</span>)</span><br><span class="line">    dig_list = re.findall(<span class="string">&quot;[1-9]&quot;</span>, replace)</span><br><span class="line">    dig_list = <span class="built_in">list</span>(<span class="built_in">set</span>(dig_list))</span><br><span class="line">    str4 = replace</span><br><span class="line">    <span class="keyword">for</span> dig <span class="keyword">in</span> dig_list:</span><br><span class="line">        dig = <span class="built_in">int</span>(dig)</span><br><span class="line">        <span class="keyword">if</span> dig % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            sub1 = replace[dig - <span class="number">1</span>:dig]</span><br><span class="line">            <span class="keyword">if</span> zm_constant.index(sub1) != -<span class="number">1</span>:</span><br><span class="line">                indexOf = (zm_constant.index(sub1) + (dig * dig)) % <span class="number">52</span></span><br><span class="line">                str4 = replaceSomeWhere(str4, zm_constant[indexOf:indexOf + <span class="number">1</span>], dig)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sub2 = replace[dig - <span class="number">1</span>:dig]</span><br><span class="line">            <span class="keyword">if</span> zm_constant.index(sub2) != -<span class="number">1</span>:</span><br><span class="line">                indexOf = (zm_constant.index(sub2) + dig) % <span class="number">52</span></span><br><span class="line">                str4 = replaceSomeWhere(str4, zm_constant[indexOf:indexOf + <span class="number">1</span>], dig)</span><br><span class="line">    <span class="keyword">return</span> str4</span><br></pre></td></tr></table></figure>

<p>​    经过测试可以成功拿到“g5tlpe0”返回值。下面终于可以编写下载视频的代码了。</p>
<h3 id="2-编写下载视频代码"><a href="#2-编写下载视频代码" class="headerlink" title="2. 编写下载视频代码"></a>2. 编写下载视频代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> generateToken <span class="keyword">import</span> getToken</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置下载视频的开始时间和截止时间(下载当前天数的前一天)</span></span><br><span class="line">startTime = (datetime.datetime.now() - datetime.timedelta(days=<span class="number">1</span>)).strftime(<span class="string">&quot;%Y-%m-%d 17:25:00&quot;</span>)</span><br><span class="line">end_time = (datetime.datetime.now() - datetime.timedelta(days=<span class="number">1</span>)).strftime(<span class="string">&quot;%Y-%m-%d 18:45:00&quot;</span>)</span><br><span class="line"></span><br><span class="line">video_url = <span class="string">&quot;https://dyhhplus.sxrtv.com/apiv3.8//m3u8.php?token=&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置视频url集合的下载地址</span></span><br><span class="line">urlDownload = <span class="string">&quot;https://livehhhttps.sxrtv.com/lsdream/%s/800/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频下载目录</span></span><br><span class="line">ts_path = <span class="string">&quot;D:/谁是高手/&quot;</span> + startTime.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>] + <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接视频的url地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDownload</span>():</span></span><br><span class="line">    startTimeStamp = <span class="built_in">int</span>(time.mktime(time.strptime(startTime, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))) * <span class="number">1000</span></span><br><span class="line">    endTimeStamp = <span class="built_in">int</span>(time.mktime(time.strptime(end_time, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))) * <span class="number">1000</span></span><br><span class="line">    <span class="keyword">return</span> urlDownload + <span class="built_in">str</span>(startTimeStamp) + <span class="string">&quot;,&quot;</span> + <span class="built_in">str</span>(endTimeStamp) + <span class="string">&quot;.m3u8&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取视频的所有下载链接集合</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getUrlList</span>(<span class="params">resp</span>):</span></span><br><span class="line">    text = resp.text</span><br><span class="line">    urlList = queue.Queue()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> text.split(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span> line.find(<span class="string">&quot;.ts&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">            urlList.put(line)</span><br><span class="line">    <span class="keyword">return</span> urlList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始下载所有ts文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            url = data.get_nowait()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        resp = requests.get(urlDownload + url, stream=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ts_path):</span><br><span class="line">            os.makedirs(ts_path)</span><br><span class="line">        ts_file = ts_path + <span class="built_in">str</span>(url).split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ts_file):</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(ts_file, <span class="string">&quot;wb+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">for</span> chunk <span class="keyword">in</span> resp.iter_content(chunk_size=<span class="number">1024</span>):</span><br><span class="line">                    <span class="keyword">if</span> chunk:</span><br><span class="line">                        f.write(chunk)</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(url).split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>] + <span class="string">&quot;下载完成&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(url).split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>] + <span class="string">&quot;文件已经存在&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的ts文件合并为一个mp4视频文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTsToMp4</span>(<span class="params">ts_file_path</span>):</span></span><br><span class="line">    fileList = os.listdir(ts_file_path)</span><br><span class="line">    ts_list = []</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> fileList:</span><br><span class="line">        ts_list.append(file)</span><br><span class="line">    shell_str = <span class="string">&#x27;+&#x27;</span>.join(ts_list)</span><br><span class="line">    shell_str = <span class="string">&quot;copy /b &quot;</span> + shell_str + <span class="string">&quot; &quot;</span> + startTime.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>] + <span class="string">&quot;谁是高手.mp4&quot;</span></span><br><span class="line">    os.chdir(ts_file_path)</span><br><span class="line">    subprocess.run(shell_str, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> fileList:</span><br><span class="line">        <span class="keyword">if</span> file.find(<span class="string">&quot;ts&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">            os.remove(file)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ts文件合并完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    token = getToken(<span class="string">&quot;lce1mC4&quot;</span>, <span class="string">&quot;jushilive&quot;</span>)</span><br><span class="line">    text = requests.get(video_url + token).text</span><br><span class="line">    rand_str = json.loads(text)[<span class="string">&#x27;tss&#x27;</span>]</span><br><span class="line">    url_download = getDownload() % rand_str</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在获取所有的ts文件下载地址：&quot;</span> + url_download)</span><br><span class="line">    response = requests.get(url_download)</span><br><span class="line">    threadNum = <span class="number">5</span></span><br><span class="line">    thread_list = []</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        data_url = getUrlList(response)</span><br><span class="line">        size = data_url.qsize()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(threadNum):</span><br><span class="line">            t = threading.Thread(target=download, args=(data_url,))</span><br><span class="line">            thread_list.append(t)</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">            t.start()</span><br><span class="line">            t.join()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(size) + <span class="string">&quot;个文件全部下载完成&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;总共用时 &quot;</span> + <span class="built_in">str</span>(end_time - start_time) + <span class="string">&quot;秒&quot;</span>)</span><br><span class="line">        mergeTsToMp4(ts_path)</span><br><span class="line">        <span class="built_in">input</span>(<span class="string">&quot;请按任意键结束...&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用失败&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​    核心代码已经进行了注释，代码的编写思路如下：</p>
<ol>
<li><p> 生成Token</p>
</li>
<li><p> 利用Token从指定url地址获取“随机字符串”的值</p>
</li>
<li><p> 指定需要下载视频的时间范围(谁是高手的时间范围为17:25 - 18:45，共计1小时20分钟)</p>
</li>
<li><p> 从给定url地址下载m3u8文件，并从中获取所有需要下载的ts文件</p>
</li>
<li><p> 多线程下载所有的ts文件，并将所有的ts文件合并为一个mp4视频文件</p>
</li>
<li><p> 删除下载的所有ts文件</p>
</li>
</ol>
<h3 id="3-收尾"><a href="#3-收尾" class="headerlink" title="3. 收尾"></a>3. 收尾</h3><p>​    将Python程序打包为exe可执行文件后，加入到Window的任务计划程序中，每天凌晨2点执行一次即可。至此整个爬取《谁是高手 · 双升》的流程到此结束。</p>
<p><img src="/2022/01/08/Python%E7%88%AC%E5%8F%96%E3%80%8A%E8%B0%81%E6%98%AF%E9%AB%98%E6%89%8B%C2%B7%E5%8F%8C%E5%8D%87%E3%80%8B%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5/window%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8Cmain.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
