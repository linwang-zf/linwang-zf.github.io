---
title: Java系列---Java虚拟机
author: linWang
date: 2022-08-13 16:39:12
tags: Java虚拟机
categories: Java系列
---

> 对于Java程序员来说，虚拟机是一个熟悉且陌生的词汇，熟悉是因为我们天天在用它，而陌生是我们对它的了解比较少。
>
> Java虚拟机是实现Java语言平台无关性的关键。它帮我们屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。
>
> 并且Java虚拟机提供了自动内存管理机制，我们无需像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。

<!--more-->

## 一、Java内存模型

### 1.1 运行时数据区域

![image-20230416124511371](image-20230416124511371.png)

线程私有：

* 程序计数器

  字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

* Java虚拟机栈

  Java虚拟机栈描述的是Java方法执行的线程内存模型：每个方法执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接和方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。当虚拟机栈扩展无法申请到更多的内存时，就会OOM，当虚拟机中栈深度大于虚拟机允许的最大深度时，会StackOverflow。

* 本地方法栈

  本地方法栈和Java虚拟机栈所发挥的作用非常相似，其区别只是Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的本地方法服务。同样本地方法栈也会在栈深度溢出或者栈扩展失败时抛出StackOverflow和OOM异常。

线程共享：

* 堆

  Java堆内存是虚拟机所管理的内存中最大的一块，是被所有线程共享的一块区域，此内存区域的唯一目的就是存放对象实例。Java堆是GC收集器管理的内存区域。通过-Xms和-Xmx来使用初始堆大小和最大的堆大小。如果在Java堆中没有内存完成实例分配，并且堆也无法在扩展时，Java虚拟机将会抛出OOM的异常。

* 方法区（元空间）

  方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类型信息、常量、静态变量和即时编译后的代码缓存等数据。根据Java虚拟机规范的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常

* 直接内存

  直接内存并不是Java虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁的使用到，而且也有可能导致OOM异常。在JDK1.4中新加入的NIO类，引入了一种基于通道与缓冲区的I/O方式，可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。在一些场景中提高性能，避免了在Java堆和Native堆中来回复制数据。直接内存不会受到Java堆大小的限制，但是既然是内存，肯定会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OOM异常。

### 1.2 对象创建和定位

对象创建过程：

* 当Java虚拟机遇到一条new字节码指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化，如果没有，则必须先执行相应的类加载过程。
* 在类加载检查通过后，虚拟机将为新生对象分配内存，Java虚拟机为对象分配内存有两种方式：**指针碰撞、空闲列表**。指针碰撞指的是Java堆中已用区域和空闲区域时分开的，中间用一个指针来分界，在分配内存的时候，仅需要向空闲区域移动对象大小的距离即可。空闲列表则是虚拟机维护一个列表，用来记录哪些内存块是可用的，哪些是已用的，分配对象内存时，从可用的区域中找到一块足够大的空间划分给对象实例。
* 对象创建时一个十分频繁的行为，所以如果多个线程同时创建对象需要进行同步处理，或者采用**TLAB**方式（本地线程分配缓冲Thread Local Allocation Buffer），即哪个线程要分配内存，就在哪个线程的本地缓冲区中分配。
* 给对象分配完内存空间后，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头中。
* 对象产生后，然后调用对象的构造函数，即class文件中的init方法。
* 将引用指向对象的内存起始地址

对象布局：

* 对象头：对象头包含两个部分，第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；第二类是类型指针，即对象指向它的类型元数据的指针。Java虚拟机通过这个指针来确定对象是哪个类的实例。如果对象是数组，在对象头中还必须有一块用于记录数组长度的数据。
* 实例数据：示例数据是对象真正存储的有效信息，即我们在代码里面所定义的各种类型的字段内容，无论是从父类继承的，还是子类中定义的字段。Java虚拟机默认的分配顺序是相同宽度的字段放在一起，在这个前提下，父类中定义的字段会出现在子类之前。
* 对齐填充：Java虚拟机规范要求对象的起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。所以需要通过对齐填充来补全

对象定位：

* 句柄访问

  句柄访问就是在Java堆中维护一个句柄池，栈上的Reference数据只需要存储对象的句柄地址即可。而句柄中包含了对象实例数据与类型元数据的地址信息。这种方式的缺点是需要定位两次才可以访问对象，优点是对象的移动不需要修改Reference的存储内容，仅需要修改句柄中存储的地址。

* 直接指针访问

  Reference直接存储对象的地址，这种方式的优点就是访问对象速度快，比第一种方式少了一次指针定位的时间开销。缺点就是Java对象的内存布局需要考虑如何放置访问类型元数据的相关信息。HotSpot虚拟机采用第二种方式进行对象访问。

### 1.3 OOM异常

* Java堆异常

  Java堆中存储对象的实例，所以我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后，就会产生OOM异常，详情请看代码。

  ```java
  // VM Args : -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
  public class JavaHeapOOM {
      public static void main(String[] args) {
          List<OOMObject> arrays = new ArrayList<>();
          int i = 0;
          while (true) {
              System.out.println("创建对象个数:" + ++i);
              arrays.add(new OOMObject());
          }
      }
      private static class OOMObject {}
  }
  
  //output:
  创建对象个数:810326
  java.lang.OutOfMemoryError: Java heap space
  Dumping heap to java_pid9044.hprof ...
  Heap dump file created [28945836 bytes in 0.079 secs]
  Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
  ```

* Java虚拟机栈和本地方法栈异常

  * 线程请求的栈深度大于虚拟机允许的最大栈深度，抛出StackOverflow异常（其实Java虚拟机并没有规定最大的栈深度，这里抛出异常仅仅是因为超过了Java虚拟机栈的容量而已）

  * 如果虚拟机栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，抛出OOM异常

  在HotSpot虚拟机中，不支持虚拟机栈的动态扩展，所以除非在**创建线程申请内存时就因无法获得足够内存而出现OOM异常**，否则在线程运行过程时不会出现因为扩展而导致的OOM异常。

  在线程运行的过程中，有两种情况会抛出StackOverflow异常，一种是栈深度过深（方法递归调用太多），第二种是栈帧很大，导致栈容量无法容纳栈帧。这两种异常其实本质是相同的，都是由于Java虚拟机栈的容量不够导致的。

* 方法区和本地内存异常

  使用CGLIB在运行时直接生成动态代理类，将方法区打满。

  通过Unsafe类的AllocateMemory可以申请本地直接内存。

## 二、类文件结构

### 2.1 Class文件结构格式

Class文件是一组以字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有任何的分隔符。当遇到需要占用单个字节以上空间的数据项时，则会按照高位在前（大端存储）的方式分割成若干字节进行存储。

Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。

*   无符号数：基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节的无符号数。
*   表是由多个无符号数或者其他表作为数据项构成的复合数据类型。所有表的命名都习惯性地以_info结尾。

![image-20230416131808068](image-20230416131808068.png)

如上图所示，整个 Class 文件 按如下排列：**魔数(4) – 次版本号(2) – 主版本号(2) – 常量池常量数(2) – 常量池表(不确定长度) – 访问标志(2) – 类索引(2) – 父类索引(2) – 实现的接口数(2) – 实现的接口集合(2) – 实现的字段数(2) – 字段集合表(不确定长度) – 方法数(2) – 方法集合表(不确定长度) – 属性数(2) – 属性集合表(不确定长度)。**

### 2.2 具体组成部分

* 魔数

  每个Class文件的头4个字节被称为魔数，0xCAFEBABE，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。

* 版本号

  紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。 Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。

* 常量池

  常量池是Class文件里的资源仓库，常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（从1开始，如果计数值为22，代表常量索引从1~21），常量池0空出来是表示如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。

  常量池中主要存放两大类常量：`字面量（Literal）和符号引用（Symbolic References）`，字面量比较接近于Java语言层面的常量概念，如文本字符串、 声明为final的常量值等。 而符号引用则属于编译原理方面的概念，包括了下面三类常量：

  -   类和接口的全限定名
  -   字段的名称和描述符
  -   方法的名称和描述符

* 访问标志

  常量池结束后，紧接着的2个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为Public类型；是否定义为Abstract类型；如果是类的话，是否被声明为final。

* 类索引、父类索引、接口集合

  类索引用于确定这个类的全限定名（指向一个常量池中一个表项），父类索引用于确定这个类的父类的全限定名。接口集合用于描述这个类实现了哪些接口。

* 字段表集合

  Class文件中的集合全部都由一个计数值 + 数据构成的，字段表用于描述接口或者类中声明的变量，字段表最后跟随着一个属性表集合，用于存储一些额外的信息（比如常量的值）

* 方法表集合

  用来描述接口或者类中的方法的，方法表的最后也跟随着一个属性表集合，用来存储每个方法的信息。

* 属性表集合

  Class文件、字段表、方法表都可以携带自己的属性表集合。

  *   Code属性：存储该方法的字节码指令
  *   Exceptions属性：和Code属性平级的一项属性，该属性的作用是列举出方法中可能抛出的受查异常。
  *   LineNumberTable属性：字节码行号和源码行号的对应关系
  *   LocalVariableTable属性：局部变量表与Java源码中定义的变量之间的关系
  *   ...

### 2.3 常用字节码指令

* 加载和存储指令

  *   将一个局部变量加载到操作数栈：iload、iload_<n>、lload、aload.....

  *   将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、astore......

  *   将一个常量加载到操作数栈：iconst、iconst_<n>、ldc、bipush、sipush


* 运算指令
  *   iadd、isub、imul、idiv.....


* 类型转换
  *   i2b、i2c、i2s....


- 创建对象和访问指令

  *   创建类实例的指令：new

  *   创建数组的指令：newarray

  *   访问类字段和实例字段：getfield、getstatic、putfield、putstatic

  *   把一个数组元素加载到操作数栈的指令：iaload、laload

  *   将一个操作数栈的值存储到数组元素中的指令：iastore、lastore....

  *   取数组长度的指令：arraylength


- 操作数栈管理指令

  *   出栈：pop、pop2

  *   复制栈顶元素并重新压入栈：dup、dup2

  *   交换栈顶两个数值：swap


- 控制转移指令
  *   ifeq、ifgt、iflt、goto、


- 方法调用和返回指令

  *   invokevirtual：调用对象的实例方法

  *   invokeinterface：调用接口方法

  *   invokespecial：调用私有方法、父类方法、实例初始化方法（构造函数）

  *   invokestatic：调用静态方法


- 异常处理指令
  *   throw


- 同步指令

  *   monitorenter

  *   monitorexit

## 三、类加载过程

类从加载至虚拟机内存 开始到 卸载出内存，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，加载后的三个阶段可以统称为连接（Linking）。

### 2.1 加载

类加载过程的第一步，主要进行下面几个步骤：

1. 通过全类名获取定义此类的二进制字节流。
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。
3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口。

### 2.2 验证

验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

* 文件格式验证：
* 元数据验证
* 字节码验证
* 符号引用验证

![image-20230414091338577](image-20230414091338577.png)

### 2.3 准备

**准备阶段主要是给静态变量和常量分配内存并赋初始值。**

![image-20230414091600975](image-20230414091600975.png)

### 2.4 解析

**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。** 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。

### 2.5 初始化

初始化阶段主要执行类中的<Clinit>方法，是类加载的最后一步

> <Clinit>方法是编译之后自动生成的。并且Java虚拟机会保证其在多线程环境下的安全性（加锁，所以多线程下进行类的初始化有可能会阻塞线程）

类初始化的几个触发时机

* 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有初始化，必须先对类进行初始化（实例化对象、读取类的静态变量、修改类的静态变量、调用类的静态方法）
* 对类进行反射调用时，如果类未初始化，需要先进行初始化
* 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
* 入口函数Main所在的类会在Java虚拟机启动时被初始化
* 一个接口中存在默认方法时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

### 2.6 类卸载

类卸载指的是Class对象被GC回收

GC回收Class对象的3个要求：

* 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象
* 该类的类加载器的实例已被 GC
* 该类没有在其他任何地方被引用，即无法通过反射调用类的方法

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

## 四、垃圾收集器

### 4.1 对象是否存活算法

*   引用计数法
*   可达性分析算法
    *   GC ROOTS
        1.   虚拟机栈（栈帧中的本地变量表）中引用的对象
        2.   方法区中的类静态属性引用的对象，常量引用的对象
        3.   本地方法栈中JNI引用的对象
        4.   Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException，OutOfMemoryError等）还有系统类加载器。
        5.   被同步锁持有的对象
        6.   反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
    *   引用类型
        *   强引用：程序代码中普遍存在的引用赋值，只要强引用关系存在，垃圾收集器就不会回收掉被引用的对象
        *   软引用：描述一些还有用，但非必须的对象，被软引用关联的对象，在发生内存异常前，会把这些对象列进回收范围内进行二次回收，如果这次回收还没有足够的内存，才会排除内存溢出异常。
        *   弱引用：被弱引用关联的对象只能生存到下次垃圾收集发生为止。
        *   虚引用：是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取对象实例，为一个对象设置虚引用关联的唯一目的就是为了能在这个对象被收集器回收时收到一个系统通知。

### 4.2 对象自救

​		对象在被标记为不存活之后，还可以有一次自救的机会。Java虚拟机会看该对象是否实现了finalize()方法，如果实现了这个方法，虚拟机会将该对象加入队列中，等待执行，在finalize方法中，如果对象可以和引用链上的任一一个对象建立起引用关系，即自救成功。另外，虚拟机会触发对象的finalize方法，但是并不保证一定会等方法执行完，这样做的原因是，如果某个对象的finalize方法执行缓慢，将导致队列中的其他对象永久处于等待，甚至导致内存回收子系统的崩溃。

### 4.3 方法区回收

*   类对象回收的条件
    *   类的所有实例被回收
    *   类的加载器被回收
    *   类的Class对象在任何地方没有被引用

### 4.4 垃圾收集算法

分代收集理论：

 	1. 弱分代假说：绝大多数对象都是朝生夕灭的
 	2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
 	3. 跨代引用假说：跨代引用相对于同代引用来说仅占少数

* 标记-清除算法（CMS使用的算法）

  该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：

  * 效率问题
  * 内存碎片问题

  <img src="image-20230416133731064.png" alt="image-20230416133731064" style="zoom:67%;" />

* 标记-复制算法（Serial、ParNew、Parallel Scavenge新生代收集器）

  为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

  <img src="image-20230416133748841.png" alt="image-20230416133748841" style="zoom:67%;" />

* 标记-整理算法（Serial Old，Parallel Old、G1、Shenandoah等收集器采用此算法）

  根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

  <img src="image-20230416133959914.png" alt="image-20230416133959914" style="zoom:67%;" />

### 4.5 垃圾收集器

#### 新生代收集器

*   Serial收集器

Serial收集器是单线程模型，运行在客户端模式的Java虚拟机中，是新生代的收集器，和Serial Old配合使用。Serial采用标记复制算法。

*   ParNew收集器

ParNew是多线程的垃圾收集器，是CMS的默认新生代收集器(JDK 5推出了CMS收集器)。ParNew收集器采用标记复制算法。

*   Parallel Scavenge收集器

也是多线程的垃圾收集器，同样是基于标记-复制算法。目标是提高吞吐量。(吞吐量是处理器用于运行用户代码的时间与处理器总消耗时间的比值)，在JDK 6之前和Serial Old配合来使用，但是Serial Old由于是单线程的，导致效果不太好，对不起Parallel Scavenge的名字，直到Parallel Old的出现，它是一个多线程的老年代收集器。

#### 老年代收集器

* Serial Old收集器

  Serial Old是Serial收集器的老年代版本，同样是一个单线程收集器，采用标记-整理算法。

* Parallel Old收集器

  Parallel Old收集器是Parallel Scavenge的老年代版本，支持多线程收集，基于标记-整理算法，JDK 6才提供。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

* CMS收集器（Concurrent Mark Sweep）

  -   CMS收集器是一种以获取最短停顿时间为目标的老年代收集器，采用标记-清除算法。

  -   由于CMS和用户线程是并发执行的，所以垃圾回收时需要预留一部分内存空闲给用户线程使用，当预留的内存空间不足时，会发生Concurrent Mode Failure，此时虚拟机会临时启用Serial Old收集器来进行老年代的垃圾回收。

  -   另外CMS由于采用的是标记-清除算法， 会造成大量的空间碎片，可能出现老年代还有很多剩余空间，但是无法找到足够大的连续空间来分配当前对象，而不得不提前出发一次FULL GC。所以CMS为了解决这个问题，CMS收集器提供了一个开关参数，用于FULL GC时开启内存碎片的整理工作（标记-整理算法）。但是由于整理空间碎片需要移动存活对象，需要暂停用户线程，所以会增加停顿时间，所以CMS又提供了另一个参数，用来设置在进行几次Full GC后，下一次Full GC开启内存碎片整理（默认为0，即每次Full GC都进行碎片整理）。
  -   CMS收集器的步骤：
      1.   初始标记（STW）
      2.   并发标记
      3.   重新标记（STW + 增量更新）
      4.   并发清除

* G1收集器（Garbage First收集器）

  *   G1收集器采用了面向局部收集的设计思路和基于Region的内存布局形式。是一款主要面向服务端应用的垃圾收集器。
  *   G1可以实现在指定的停顿时间内，优先处理回收价值收益最大的Region
  *   G1将堆内存划分为了多个Region区域，并会计算每个Region区域的回收价值，并组成一个回收集，在回收的时候，根据用户指定的允许停顿时间，计算出收益最大化的回收集，并回收。
  *   G1依然采用记忆集的形式来记录不同Region间的跨代引用，不过比CMS的记忆集要复杂， CMS中用数组来表示，但是G1中采用类似与哈希表的数据结构来存储，key是其他Region的起始地址，value是该Region中卡表的索引号（表明哪些索引中的对象存在指向其的跨代引用）。
  *   G1收集器采用原始快照来实现并发标记
  *   G1收集器的步骤
      1.   初始标记（STW）
      2.   并发标记
      3.   重新标记（STW + 原始快照）
      4.   筛选回收（需要移动存活的对象，所以需要STW）

* Shenandoah收集器

  *   RedHat公司开发的一款低延迟的垃圾收集器
  *   和G1收集器的设计思路一致，也是基于Region的内存布局来进行回收
  *   通过“连接矩阵”来记录不同Region之间的跨代引用。
  *   采用原始快照来实现并发标记

  *   Shenandoah收集器的步骤

      1.   初始标记（STW）

      2.   并发标记

      3.   最终标记（STW + 原始快照，并计算各Region的回收价值）

      4.   并发清理：清理掉那些整个区域没有一个存活对象的Region

      5.   并发回收：采用Brooks Pointers将回收集Region中的存活对象复制到其他未使用的Region中

      6.   初始引用更新：确保并发回收阶段中进行的收集器线程都已经完成分配给它们的对象移动任务。（STW）
      7.   并发引用更新：将对象的引用从旧值改为新值
      8.   最终引用更新：更新GC Roots中的引用。（STW）
      9.   并发清理

  *   Brooks解决复制对象和用户线程并发访问的方法是：在对象头中增加了一个新的引用字段，在正常不处于并发移动的情况下，指向对象自己，在移动时，将其指向复制后的对象地址。这样用户线程在访问对象的时候就会被转发到新的对象地址进行访问。Brooks操作需要同步。

* ZGC收集器

  *   在JDK11中新加入的具有实验性质的低延迟垃圾收集器，是Oracle公司研发的。
  *   和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。
  *   ZGC也采用基于Region的堆内存布局，但与它们不同的是，ZGC的Region具有动态性，并且有大、中、小三类容量
      *   小型Region：2MB，用于放置小于256KB的小对象。
      *   中型Region：32MB，用于放置大于等于256KB但是小于4MB的对象
      *   大型Region：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象。大型Region在ZGC的实现中是不会被重分配的。
  *   ZGC采用了染色指针技术，其是一种直接将少量额外的信息存储在指针上的技术。有4TB的内存限制，不支持32位平台，不能支持压缩指针。
      *   染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能被释放和重用掉。
      *   染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量。
  *   ZGC收集的步骤
      *   初始标记（STW）
      *   并发标记
      *   最终标记（STW）
      *   并发预备重分配：统计得出本次收集过程要清理哪些Region
      *   并发重分配：将存活的对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表，记录从旧对象到新对象的转向关系。
      *   并发重映射：修正整个堆中指向重分配集中旧对象的所有引用。ZGC这一阶段并不迫切，所以ZGC将这一操作放到了下一次垃圾收集的并发标记阶段。

### 4.6 内存分配与回收策略

* 对象优先在Eden分配

  大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间时，虚拟机将发起一次MinorGC。

* 大对象直接进入老年代

  -XX:PretenureSizeThreshold参数指定大于该设置值的对象直接在老年代分配。只对Serial和ParNew有效。

* 长期存活的对象将进入老年代

  -XX:MaxTenuringThreshold参数为晋升老年代的年龄阈值，Eden中的对象每熬过一次MinorGC后，年龄加1。

* 动态对象年龄判断

  如果在Survivor空间中低于或等于某年龄的所有对象大小综合大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。

* 空间分配担保

  * 计算老年代的最大连续可用内存空间，为oldMax

  * 当oldMax >= 新生代所有对象总大小 ||  oldMax >= 历年晋升到老年代对象的平均大小时，触发Minor GC，否则出发Full GC

## 五、JVM相关参数

### JVM相关参数

| JVM参数                                                      |                             说明                             |
| :----------------------------------------------------------- | :----------------------------------------------------------: |
| -Xms                                                         |                       初始化堆内存大小                       |
| -Xmx                                                         |                        最大堆内存大小                        |
|                                                              |                                                              |
| -XX:NewSize                                                  |                      新生代最小内存大小                      |
| -XX:MaxNewSize                                               |                      新生代最大内存大小                      |
| -Xmn                                                         |      新生代分配内存大小（和上面两个含义一，最大=最小）       |
| -XX:NewRatio                                                 |                     老年代和新生代的比例                     |
| -XX:SurvivorRatio                                            |                     eden和survivor的比例                     |
| -XX:MaxTenuringThreshold                                     |                  对象晋升至老年代的年龄阈值                  |
| XX:TargetSurvivorRatio                                       | 当<=某个年龄的对象内存达到这个比例时，将>该年龄的对象存放到老年代 |
|                                                              |                                                              |
| -XX:PermSize                                                 |                 永久代初始大小（JDK1.8之前）                 |
| -XX:MaxPermSize                                              |                 永久代最大大小（JDK1.8之前）                 |
|                                                              |                                                              |
| -XX:MetaspaceSize                                            |  当元空间扩容到此阈值时，触发full gc，之后每次扩容都会触发   |
| -XX:MaxMetaspaceSize                                         |                  元空间的最大大小（JDK1.8）                  |
|                                                              |                                                              |
| -XX:+UseSerialGC <br />-XX:+UseParallelGC<br />-XX:+UseParNewGC<br />-XX:+UseG1GC |                   选择不同类型的垃圾收集器                   |
|                                                              |                                                              |
| -XX:+PrintGCDetails                                          |                       打印GC的详细日志                       |
|                                                              |                                                              |
| -XX:+HeapDumpOnOutOfMemoryError<br /> -XX:+HeapDumpPath      |                发生OOM时，将heap转储到文件中                 |
|                                                              |                                                              |
| -Xss                                                         |                       线程栈的空间大小                       |
