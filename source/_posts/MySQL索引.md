---
title: MySQL索引
author: linWang
date: 2022-05-15 20:07:00
tags: MySQL索引
categories: MySQL系列
---

> MySQL索引是MySQL中非常重要的一个知识点，不仅在面试中会被经常问道，而且是我们优化SQL语句，提高SQL性能常见的一种手段。

<!--more-->

## 索引介绍

索引本质上是一个排序后的数据结构，可以用来快速查询数据。

我们都知道MySQL底层采用B+树来实现索引，那为什么要用B+树，而不是采用其他的比如：Hash表等数据结构呢，下面我们就一起来分析一下：

### Hash表

Hash表采用Key-Value的形式来保存数据，底层通常采用一个数组来实现，通过计算Key的Hash值来确定数组的下标，数组下标处对应的值为Value。如果出现Hash值冲突的情况，可以采用拉链法解决（HashMap就是采用这种数据结构来保存数据，这里不展开描述啦）。

![image-20230422103621817](image-20230422103621817.png)

从图中可以看出，Hash表在绝大部分情况下获取数据的时间复杂度都是O(1)，那这么来看感觉MySQL应该采用Hash表才对。

我们不妨在仔细想想，假如现在我们想要获取[100, 500]之间的数据，那么会发生什么情况呢？

在Hash表中你需要遍历所有的数据，然后看是否在[100，500]之间，才能找到满足要求的所有数据；对于数据库来说，范围查询和等值查询都是我们非常频繁的查询语句，所以如果索引采用Hash表来存储，那么范围查询将只能进行全量扫描，没有起到索引的效果。

### 数组

有序数组在范围查询和等值查询中都有很好的性能表现，那为什么MySQL索引没有采用有序数组，这是因为对排好序的数组插入一个元素，我们需要移动后面的所有元素，当数据很多的时候，性能会很差。

那就没有在范围查询、等值查询、插入、删除时，表现都很好的数据结构么？嘿嘿，还真的有，这就是我们下面要介绍的B+树

### B树 & B+树

B树又叫多路平衡查找树，我们可以把它理解为多叉的平衡搜索树，那B树和B+树又有什么区别呢？

（1）B树的非叶子节点保存Key和Value值，B+树的非叶子节点仅保存Key，叶子节点保存Value值（即B+树的搜索更稳定，每次都会到叶子节点）

（2）B树的叶子节点之间是独立的，和二叉树一样，而B+树叶子节点有一条引用链指向其相邻的叶子节点（支持范围查询）

![image-20230422131150221](image-20230422131150221.png)

首先我们来分析下为什么采用多叉树而不是而二叉树，这就因为假如我们要存储100万条数据，采用二叉树的话，树的高度大约在20层左右，我们知道文件系统的存储方式是数据块（对于树来讲，每个节点就是一个数据块），那么对于20层的树来说，我们访问一个数据需要访问20次数据块，在传统的机械硬盘下，每个数据块访问大概需要10ms，那么访问一个数据就是200ms，如果访问多个数据那么将会更长。当我们采用多叉树的方式存储时，对于InnoDB的整型类型的4字节主键索引，我们每个节点可以保存1000个关键字（即1000叉树），那么当层高为4的时候，可以存储的节点数据大概为10亿条，已经可以满足绝大部分场景了。

所以MySQL采用B+树作为索引的数据结构，除了很好的查询、插入、删除的性能表现外，也有减少磁盘的访问次数的原因。

在MySQL中，MyISAM存储引擎和InnoDB存储引擎均采用B+树作为索引结构，但是底层的存储方式有所不同：

> MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“**非聚簇索引（非聚集索引）**”。
>
> InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“**聚簇索引（聚集索引）**”，而其余的索引都作为 **辅助索引** ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

![image-20230422153101891](image-20230422153101891.png)

## 索引类型  

![image-20230422165456946](image-20230422165456946.png)

按照索引和数据的底层存储结构，可以将索引分为聚簇索引和非聚簇索引（上面介绍MyISAM和InnoDB存储方式不同时已经做过介绍）

* 聚簇索引

  （1）叶子节点中索引和数据一起存放的索引，叫做聚簇索引，在InnoDB中，主键索引是聚簇索引（主键索引的叶子节点包含整行数据）

  （2）MyISAM存储引擎底层将索引和数据分为两个文件存储，所以在MyISAM中，主键索引也仅仅保存指向数据文件的指针，索引和数据没有存放在一起，所以在MyISAM中，主键索引不是聚簇索引。

* 非聚簇索引

  索引和数据分开存放的索引叫做非聚簇索引，二级索引就是非聚簇索引。在MyISAM中，不管是主键还是非主键，全都是非聚簇索引。

按照应用维度，索引可以分为下面几类：

* 主键索引：表的主键上建立的索引，非空性、唯一性，用来加速查询。
* 普通索引：在表的非主键字段上建立的普通索引，仅用来加速查询（**前缀索引：**是专门针对字符串类型的前几个字符创建的索引，可以降低索引的存储消耗）。
* 唯一索引：在表的非主键字段上建立的唯一索引，唯一性，可加速查询
* 联合索引：将表中的多列值组合在一起建立的索引，专门用于组合搜查（当查询所需的字段全部都在索引中时，此时就是**覆盖索引**，覆盖索引有效降低了回表次数）
* 全文索引：对文本类型的内容进行分词，用来搜索使用，在CHAR、VARCHAR、TEXT上可以创建全文索引。

下面我们对上面的几种索引类型进行简单的介绍

聚簇索引和非聚簇索引在上面已经进行过介绍，在此不再赘述。

### 主键索引

数据表的主键列使用的就是主键索引，一张数据表只能有一个主键，并且主键不能为 null，不能重复。

在MySQL的InnoDB中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。

在InnoDB中，主键索引的叶子节点保存了主键所在行的完整数据。

### 二级索引

二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。

普通索引，唯一索引，联合索引、前缀索引等索引都属于二级索引。

二级索引在查询时，首先需要查询主键的位置，然后在主键索引中在查询对应的字段（非覆盖索引的情况），即需要回表。

### 覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 **覆盖索引（Covering Index）** 。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

### 联合索引

使用表中的多个字段创建索引，就是 联合索引。

联合索引中有一个最左前缀匹配原则，大概含义是：

在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 **`>`**、**`<`**）才会停止匹配。对于 **`>=`**、**`<=`**、**`BETWEEN`**、**`like`** 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

> [关于最左匹配原则，全网都在说的一个错误结论](https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ)

### 索引下推

索引下推是MySQL 5.6版本中提供的一种索引优化功能。

在5.6版本之前遍历非聚簇索引时，需要读取一个主键ID，然后回表查看是否满足查询要求，然后在读取一个主键ID，在回表查看，一直不满足要求为止。5.6版本之后，会先对索引中包含的字段进行判断，如果不满足，就无需回表了，直接下一个值继续判断，这种做法可以过滤掉一些不符合条件的记录，降低回表次数。

## 正确使用索引的建议

**需要建立索引的情况**

* 频繁查询的字段
* 经常作为where条件的字段
* 频繁需要排序的字段

**无需建立索引的情况**

* 频繁被更新的字段

**索引失效的几种情况**

* 未遵循最左匹配原则
* 在索引字段上使用函数计算（对索引字段做函数处理，有可能会破坏索引的有序性，哪怕函数不会破坏有序性，也不走了，这里仅仅是放弃了索引的搜索功能，但并不意味着要走全表扫描，优化器会评估全表扫描和全索引扫描，哪个好走哪个）
* 隐式类型转换（其实本质也是在索引字段上使用了函数操作，索引字段上不能进行函数操作，但是索引的参数值上可以进行函数操作）
* 以%开头的模糊匹配： like  "%abc"
* OR 语句的前后有一个查询字段没有索引时，本次查询不会走索引

**常用建议**

* 一张表上的索引不是越多越好，索引的创建和维护需要代价的，在插入和删除时需要修改索引，太多的索引可能会导致查询性能降低（优化器会根据可选索引计算执行计划，用来选择一个最优的索引，过多的索引会增加优化器的分析时间，进而影响查询性能）
* 尽可能的考虑联合索引，而不是单列索引
* 避免冗余索引，联合索引（a，b）和索引（a）中索引a就是冗余索引
* 字符串类型中可以使用前缀索引来建立索引，降低存储消耗

