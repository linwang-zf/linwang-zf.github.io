---
title: MySQL的高可用保证
author: linWang
date: 2022-05-20 20:02:35
tags: MySQL的高可用保证
categories: MySQL系列
---

>   在上一篇文章中，我们介绍了MySQL主备一致性的原理，通过binlog可以实现主库和备库的最终一致性。但是对于MySQL的高可用来说，除了最终一致性外，主备延迟也是很重要的，因为它影响了主备切换时的策略选择。
>
>   这篇文章我们就一起来看下MySQL的高可用是如何保证的？

<!--more-->

主备切换是MySQL高可用的基础。常用的切换策略有两种

*   可靠性优先策略
*   可用性优先策略

在介绍两种策略之前，我们先来介绍下主备延迟是什么，以及有哪些原因可能会造成主备延迟。

### 主备延迟

主备延迟是同一个事务在备库执行完成的时间与主库执行完成的时间差值。

主备同步的流程：

1.   主库A执行完一个事务，并写入binlog，此时时间为T1
2.   binlog传给备库B后，备库B执行完成，此时时间为T2

那么T2-T1就是主备延迟的时间。

在备库上可以通过`show slave status`命令查看`seconds_behind_master`参数的值，用来表示备库此时延迟的时间。

#### **主备的延迟是如何造成的呢？**

当主库A将binlog传递给备库B后，B会将binlog写入relay log中，这个时间其实是很快的，延迟的时间其实基本上是SQL线程执行relay log更新数据所消耗的时间。

#### **有哪些场景会造成主备延迟呢？**

*   主库和备库机器性能不一致
*   备库的查询请求很多，QPS高
*   大事务，备库需要执行很长时间才能执行完成
*   备库正在进行备份等

### 可靠性优先策略

可靠性优先策略会优先保证数据的一致性，所以其主备切换流程如下：

![image-20221011220724591](image-20221011220724591.png)

从上述流程中可以发现，可靠性优先策略可能会使系统处于不可写状态，当主库A的readOnly设置为true后，一直到业务请求切换到备库B后才能恢复。所以为了减少系统不可写状态的时间，主库A在设置只读状态前需要保证主备延迟足够小，这样才能保证系统服务的可用性。不然如果在主备延迟很高的情况下就进行主备切换，那么这个不可写的时间是业务无法接受的。

如果系统必须要每时每刻都提供服务，即无法忍受存在不可写状态，那么可以采用下面的策略。

### 可用性优先策略

可用性优先策略的流程如下所示：

![image-20221011221801351](image-20221011221801351.png)

从图中可以看到，相比于可靠性优先策略来说，就是去掉了主备延迟的判断逻辑，直接将业务请求发送到备库B，从而保证了系统几乎没有不可用时间。

但是这种策略有一个问题：可能造成数据不一致。

给大家举个栗子：

![](举个栗子.png)

假设现在有一张学生表student，包含主键Id（自增）、学生姓名name、学生班级class等等。初始化状态中主库A和备库B中均存在三条数据（即两个库中的student表都保存了三个学生的信息）。下面我们做如下操作：

*   往主库A的student表中插入一条数据：```insert into student(name, class) values('zhangyi','class A');```

*   继续往主库A的student表中插入一条数据：```insert into student(name, class) values('lisi','class B');```

按照正常的操作流程，我们希望的过程如下图所示：

![image-20221011224602869](image-20221011224602869.png)

如果不出意外的话，也确实会按照上述的流程就行，最终达到主库A和备库B的数据一致性。

但是假如出现了这个场景：在执行完第一条语句后，主备按照可用性优先策略进行了切换，此时第二条语句发送给了备库B（假设主备之间存在延迟），我们再来看看此时的流程：

![image-20221011224619617](image-20221011224619617.png)

从上图中可以发现，由于第一条语句在主库A执行，第二条语句在备库B执行，并且因为主键Id自增的缘故，导致两条数据出现了不一致，并且在主备同步完后，数据不一致的记录变为了2条。此时对于可靠性要求高的系统来说，这种情况显然是无法接受的。

回想我们上一篇文章中介绍的binlog的存储格式，我们设想下：如果binlog_format=row会出现什么情况？（注：上述的流程是在binlog_format=mixed下的流程图）

从上一篇文章中我们已经知道了在row格式下，binlog会保存插入语句中涉及的所有字段信息，包括主键Id（[上篇文章回顾：MySQL的主备一致性原理](https://zhuanlan.zhihu.com/p/572301710)）。

那么主库A的binlog中会保存（id=4,name='zhangyi',class='class A'），备库B的binlog会保存（id=4,name='lisi',class='class B'），当备库B在同步主库A的binlog时，由于此时已经存在主键Id=4的数据，此时备库B会抛出异常：duplicate key error。同理主库A同步备库B的binlog时也会抛出这个异常。

所以，在实际情况中推荐大家使用row格式，可以尽早发现数据的不一致问题。

### 总结

*   在条件允许的情况下，尽量选择可靠性优先策略，除非不允许系统有不可用时间
*   可靠性优先策略可能出现系统完全不可用状态（比如主库A的异常掉电，此时系统处于完全不可用状态，必须等到备库B的延迟为0后才能恢复）
*   在保证数据可靠性的前提下，主备延迟的时间越短，出现异常情况后，服务恢复的时间就越短，可用性就越高。

### 参考

>   MySQL实战45讲-----第25讲 MySQL是怎么保证高可用的？
