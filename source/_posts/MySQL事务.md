---
title: MySQL事务
author: linWang
date: 2022-05-19 18:15:22
tags: MySQL事务
categories: MySQL系列
---

> MySQL事务是MySQL系统引擎层的核心能力之一，MyISAM存储引擎是不支持事务的，后来的InnoDB才支持事务，下面就以InnoDB为例介绍下MySQL的事务。

<!--more-->

## 事务定义

事务是逻辑上的一组操作，要么都执行，要么都不执行。

而数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：**要么全部执行成功,要么全部不执行** 。 

```shell
# 开启一个事务
BEGIN;
# 多条 SQL 语句
SQL1,SQL2...
## 提交事务
COMMIT;
```

## 事务的四大特性

提到事务，我们肯定会想到ACID（就和提到开发，就想到CRUD一样），其中ACID具体指：

（1）原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性保证要么全部执行成功，要么全部不执行

（2）一致性（Consistency）：执行事务前后，数据要保证一致性。比如转账系统中，事务执行前后，转账人和收款人的总额要保持不变

（3）隔离性（Isolation）：并发访问数据库时，一个事务不能被其他事务给影响，各并发事务之间应该是独立的

（4）持久性（Durability）：一个事务被提交后，它对数据库的修改是持久的，即使数据库发生故障也不应该有任何的影响

对于上面的四个特性来说，原子性、隔离性、持久性是手段，一致性是目标。换句话说，**只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。**

## 并发事务的问题

当一个数据库上多个事务同时运行时，可能会造成一些问题（类似与多线程模式下访问共享资源）：

### 脏读

脏读指的是一个事务读到的数据是错误的，具体原因看下图：

![image-20230423191414175](image-20230423191414175.png)

脏读的原因是因为读取到了另一个事务还未提交的修改，之后另一个事务将本次修改回滚掉了，导致事务2出现了脏读。

### 更新丢失

当两个事务在同一时刻都在对相同的数据进行访问修改时，可能造成某个事务对数据的修改丢失

![image-20230423194034254](image-20230423194034254.png)

图中事务1和事务2同时对T进行修改，但是可以发现事务1的修改结果被事务2覆盖。

### 不可重复读

一个事务在执行期间多次读取相同的数据，但是两次读取的数据不一致（和幻读很像，不过幻读是范围不一样，注意区分），具体可以看下图：

![image-20230423194842180](image-20230423194842180.png)

事务2第一次读到的T为2，当第二次在读取的时候T变为了3，其原因是在两次读取的过程中，事务1对T进行了修改，导致事务2读取到了新修改的值

### 幻读

幻读和不可重复读很类似，不过幻读指的是两次读取的某个范围的数据不一致，具体原因看下图：

![image-20230423200010457](image-20230423200010457.png)

事务1在某时刻获取 T > 5的结果共有10条，在第二次获取的时候，由于事务2之前往数据库里面插入了一条T = 6的数据，所以此时事务1获取 T > 5的结果共有11条。两次读取的结果出现了不一致，就好像出现了幻读。

##  事务隔离级别

MySQL中定义了四种隔离基本，用来解决上述问题：

* 读未提交：最低的隔离级别，允许读取并发事务尚未提交的数据，可能会导致脏读、幻读或不可重复读。

* 读已提交：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
* 可重复读：在一个事务执行过程中，对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
* 可串行化：最高的隔离级别，所有的事务依次逐个执行（通过加锁来实现），这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

InnoDB存储引擎默认的隔离级别为可重复读。

### 隔离级别原理（MVCC）

* MySQL中InnoDB存储引擎默认的隔离级别是可重复读（RR），其实就是在事务开始时创建一个视图，相当于对数据库做了一个快照，其他事务在此之后做的插入、更新操作对当前事务都是不可见的；

* 读已提交和可重复读的原理类似，区别在于读已提交是在每个SQL执行之前创建一个视图；

- 读未提交的话，由于读取的都是最新的数据，所有无需做任何操作，直接返回最新数据即可；

- 可串行化直接采用加锁的方式来避免事务的并行访问；

下面我们以可重复读RR为例，介绍下其实现原理：

这里面根据SQL语句的形式又分为两种情况：

（1）快照读：普通的select语句

（2）当前读：select ... lock in share mode、 select ... for update、insert、update、delete

对于快照读，是允许读取数据的历史版本的；但是对于当前读，必须获取数据的最新版本

不同的读类型，InnoDB对可重复读的实现方式不同，对于快照读，InnoDB通过**read view 和 undo log** 来实现。我们先解释下这些概念。

#### Read View（一致性读视图）

我们之前说可重复读是在事务开始时创建一个视图，相当于一次快照；但是这肯定是不可能实现的，假如一个数据库100G，那如果每次做一次快照，那也太浪费存储了，所以肯定不是我们理解的快照，实际上InnoDB就是通过Read View来实现快照的。

具体做法是：

（1）事务启动时，InnoDB为每个事务构造一个数组，数组中保存当前时刻前，系统中所有的活跃事务的ID列表（活跃事务是还未提交的事务）

（2）以当前数组的最小值为低水位min，系统中分配的最大的事务ID为高水位max，得到一个闭区间：[min, max]

#### Undo log日志

我们在MySQL日志中其实简单介绍过undo log日志，它是用来在事务发生异常后，对事务进行回滚操作的；那么在这里undo log日志又是怎么发挥作用的呢？

我们都知道在InnoDB存储引擎中，每行数据有多个版本，其实在每个版本中，还存在两个非常重要的字段，一个是TRX_ID：表示该版本对应的事务ID；另一个是ROLL_PTR：回滚指针，指向该行数据的undo log日志。

所以我们会发现，通过当前版本，我们可以轻易的回到之前的所有历史版本，只需要通过回滚指针一直往前追溯即可。

OK，到目前位置，Read View有了，每行数据的历史版本记录也有了，就差最后一个问题了：如何确定当前事务能看到哪个版本的数据？

我们直接看下具体步骤：

（1）从该行数据的最新版本开始，先查看该版本中的事务ID，如果和当前事务Id相同，表示本次修改是当前事务做的，肯定是可见的，则直接结束，否则分为三种情况：

* 版本中事务ID < min : 表示该版本在事务开始前已经提交，则数据对当前事务可见
* 版本中事务ID > max ：表示当前事务开始时，这个事务还没有创建呢，数据对当前事务肯定是不可见的
* 版本中事务ID 在 [min, max]这个范围内：这个又分为两种情况，第一种是版本的事务ID在Read View维护的数组中，此时表示当前事务创建时，这个版本的数据还未提交，正在执行，所以此数据不可见；如果版本的事务ID不在Read View维护的数组中，则表示在当前事务开始时，该版本数据已经提交，所以此时数据可见。

（2）如果版本的数据对当前事务可见，则遍历结束；如果不可见，则利用版本中的ROLL_PTR回滚指针和undo log日志来回滚到上一版本，然后继续步骤（1）的判断，直到某个版本对当前事务可见或者没有版本为止。

![image-20230423224343046](image-20230423224343046.png)

上图表示事务的可见性判断逻辑，和上面文字描述的一致。

其实用一句话总结下：**Read View视图创建之前就已经提交的版本数据一律可见，之后的版本数据（不管提没提交）一律不可见。**

上面介绍了快照读时，InnoDB存储引擎是如何保证RR的，从上面我们看出，对于快照读来说，RR隔离级别下，不管是脏读、不可重复读还是幻读都不会发生；那么对于当前读呢，业务必须要读取最新版本的数据，此时InnoDB又如何保证RR的呢？

其实方法也很简单，就是加锁，这里的锁有三种，一种是行锁（**如果读的话加共享锁，如果更新的话加排他锁**），一种是间隙锁（gap lock），一种是临键锁（Next-Key lock）；行锁用来保证不会出现脏读和不可重复读，间隙锁用来防止幻读。临键锁是行锁 + 间隙锁，用来锁住包括记录本身及其范围的一个锁（**RR下当前读就是采用这个锁来防止幻读**）。
