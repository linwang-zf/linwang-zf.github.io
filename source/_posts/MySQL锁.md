---
title: MySQL锁
author: linWang
date: 2022-05-18 18:28:13
tags: MySQL锁
categories: MySQL系列
---

> MySQL锁是一种常见的并发事务的控制方式，通过对表、数据进行加锁、释放锁，保障了并发事务数据访问的一致性。下面对MySQL中锁的概念进行介绍。

<!--more-->

![image-20230424233018091](image-20230424233018091.png)

## 锁的介绍

MySQL中锁按照加锁的粒度，可以分为三类：全局锁、表锁和行锁；

其中全局锁是直接对整个数据库进行加锁，表锁和行锁顾名思义就是对表和行进行加锁，下面我们一个一个来介绍。

### 全局锁

全局锁用来对整个数据库进行加锁，通过命令`Flush tables with read lock(FTWRL)`。

加全局锁后，整个数据库将处于只读状态，其他线程的数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句将被阻塞。

**全局锁的典型使用场景是，做全库逻辑备份。**

但是大家一定会有疑问，我只要在可重复读的隔离级别下开启一个事务来做数据备份，不是就可以做到数据一致性了么，为什么还要加锁呢？

其实原因也很简单，不是所有的表都支持事务的，MyISAM存储引擎就不支持事务，所以如果一个表的存储引擎是MyISAM，那么将无法采用事务的方式去做数据备份，那就只好采用全局锁的方式了。

这也是为什么推荐大家在建表的时候尽量选择InnoDB存储引擎。

### 表级锁

MySQL表级锁其实分为两种：一种是表锁，还有一种是元数据锁（MDL锁）

#### 表锁

使用`lock tables ... read/write`命令对表加表锁，用`unlock tables`可以释放锁（客户端断开时也会主动释放锁）。

表锁和常见的锁一样，读锁是共享的，写锁是互斥的。举个例子：当某个线程`lock tables t1 read, t2 write`时，那么其他线程仅能对`t1`读，`t2`的读写会被阻塞，并且本线程也仅能对t1进行读、t2进行读写，不能对其他表进行操作。

对于不支持行锁的数据库，表锁是最常见的处理并发的方式。

#### MDL锁

MDL锁是MySQL中Server层提供的一个能力，无需客户端做任何操作，在访问一个表的时候，会自动对MDL加锁。

如果语句是DML语句，那么会加MDL读锁，如果是DDL语句，那么会加MDL写锁，其中读锁共享，写锁互斥，并且当一个DDL语句由于获取MDL写锁被阻塞时，将阻塞后面的所有请求（大坑）。

#### 意向锁

除了上面的表锁和MDL锁之外，MySQL还有一个表锁，叫意向锁，也是InnoDB存储引擎实现的，无需客户端自己控制。

意向锁分为两类：

（1）意向共享锁（IS）：事务对表中的数据持有S锁，对数据行加共享锁前，必须获取该表的IS锁

（2）意向排他锁（IX）：事务对表中的数据持有X锁，对数据行加排他锁前，必须获取该表的IX锁

意向锁之前互相兼容（那TM有啥作用呀？），意向锁和表级别的锁存在互斥关系，具体关系如下：

|            | IS锁 | IX锁 |
| ---------- | ---- | ---- |
| 表级共享锁 | 兼容 | 互斥 |
| 表级排他锁 | 互斥 | 互斥 |

其实还真有作用，大家可以参考下面文中的介绍

> [MySQL中意向锁的作用](https://juejin.cn/post/6844903666332368909)

总结如下：

* 意向锁之间互相兼容，保证了不同事务在对数据行加 S 或者 X锁时的并发性
* 意向锁和表级别的锁互斥，在对表`lock tables ... read/write`进行加锁时，无需扫描全表去获取是否有行锁，通过表上的意向锁即可判断加锁是否能成功。

### 行锁

行锁是InnoDB存储引擎特有的能力，是锁粒度最小的一把锁，按照锁定的方式行锁分为三类：

（1）记录锁（Record Lock）：对单条记录进行加锁

（2）间隙锁（Gap Lock）：锁定一个范围，不包含记录本身（前开后开区间）在RR隔离级别下生效

（3）临键锁（Next-Key Lock）：记录锁 + 间隙锁，锁定一个范围，包含记录本身（前开后闭区间），可以用来解决幻读问题。

按照锁的类型，行锁可以分为两类：

（1）共享锁（S锁）：读锁，`select ... lock in share mode`时会对数据加S锁

（2）排他锁（X锁）：写锁，`select ... for update`、`insert`、`update`以及`delete`等语句会对数据加X锁

我们常见的读锁和写锁，基本都是读读不互斥、写读和写写互斥，这两个锁也不例外。

在InnoDB中，加锁的基本单位是临键锁（前开后闭区间），但是在以下几种情况下，可能会出现锁降级：

（1）索引上的等值查询，给唯一索引加锁时，临键锁退化为记录锁

（2）索引上的等值查询，向右遍历时且最后一个值不满足遍历条件时，临键锁退化为间隙锁

（2）如果查询条件是没有索引的字段，则会对整个表中所有的行以及间隙加锁（现象就是对表的所有更新语句都会被阻塞）

### 二阶段锁

在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

简单点说就是在执行SQL语句时，判断是否要加行锁，一旦加上，事务结束后才会释放。
